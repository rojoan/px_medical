function GetQueryString(name) {
    var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)");
    var r = window.location.search.substr(1).match(reg);
    if (r != null) return unescape(r[2]); return null;
}
(function() {
	
    var global = this,
    objectPrototype = Object.prototype,
    toString = objectPrototype.toString,
    enumerables = true,
    enumerablesTest = {
        toString: 1
    },
    emptyFn = function() {},
    i;
    if (typeof Ext === "undefined") {
        global.Ext = {}
    }
    Ext.global = global;
    for (i in enumerablesTest) {
        enumerables = null
    }
    if (enumerables) {
        enumerables = ["hasOwnProperty", "valueOf", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "constructor"]
    }
    Ext.enumerables = enumerables;
    Ext.apply = function(object, config, defaults) {
        if (defaults) {
            Ext.apply(object, defaults)
        }
        if (object && config && typeof config === "object") {
            var i, j, k;
            for (i in config) {
                object[i] = config[i]
            }
            if (enumerables) {
                for (j = enumerables.length; j--;) {
                    k = enumerables[j];
                    if (config.hasOwnProperty(k)) {
                        object[k] = config[k]
                    }
                }
            }
        }
        return object
    };
    Ext.buildSettings = Ext.apply({
        baseCSSPrefix: "x-",
        scopeResetCSS: false
    },
    Ext.buildSettings || {});
    Ext.apply(Ext, {
        emptyFn: emptyFn,
        baseCSSPrefix: Ext.buildSettings.baseCSSPrefix,
        applyIf: function(object, config) {
            var property;
            if (object) {
                for (property in config) {
                    if (object[property] === undefined) {
                        object[property] = config[property]
                    }
                }
            }
            return object
        },
        iterate: function(object, fn, scope) {
            if (Ext.isEmpty(object)) {
                return
            }
            if (scope === undefined) {
                scope = object
            }
            if (Ext.isIterable(object)) {
                Ext.Array.each.call(Ext.Array, object, fn, scope)
            } else {
                Ext.Object.each.call(Ext.Object, object, fn, scope)
            }
        }
    });
    Ext.apply(Ext, {
        extend: function() {
            var objectConstructor = objectPrototype.constructor,
            inlineOverrides = function(o) {
                for (var m in o) {
                    if (!o.hasOwnProperty(m)) {
                        continue
                    }
                    this[m] = o[m]
                }
            };
            return function(subclass, superclass, overrides) {
                if (Ext.isObject(superclass)) {
                    overrides = superclass;
                    superclass = subclass;
                    subclass = overrides.constructor !== objectConstructor ? overrides.constructor: function() {
                        superclass.apply(this, arguments)
                    }
                }
                var F = function() {},
                subclassProto,
                superclassProto = superclass.prototype;
                F.prototype = superclassProto;
                subclassProto = subclass.prototype = new F();
                subclassProto.constructor = subclass;
                subclass.superclass = superclassProto;
                if (superclassProto.constructor === objectConstructor) {
                    superclassProto.constructor = superclass
                }
                subclass.override = function(overrides) {
                    Ext.override(subclass, overrides)
                };
                subclassProto.override = inlineOverrides;
                subclassProto.proto = subclassProto;
                subclass.override(overrides);
                subclass.extend = function(o) {
                    return Ext.extend(subclass, o)
                };
                return subclass
            }
        } (),
        override: function(cls, overrides) {
            if (cls.$isClass) {
                return cls.override(overrides)
            } else {
                Ext.apply(cls.prototype, overrides)
            }
        }
    });
    Ext.apply(Ext, {
        valueFrom: function(value, defaultValue, allowBlank) {
            return Ext.isEmpty(value, allowBlank) ? defaultValue: value
        },
        typeOf: function(value) {
            if (value === null) {
                return "null"
            }
            var type = typeof value;
            if (type === "undefined" || type === "string" || type === "number" || type === "boolean") {
                return type
            }
            var typeToString = toString.call(value);
            switch (typeToString) {
            case "[object Array]":
                return "array";
            case "[object Date]":
                return "date";
            case "[object Boolean]":
                return "boolean";
            case "[object Number]":
                return "number";
            case "[object RegExp]":
                return "regexp"
            }
            if (type === "function") {
                return "function"
            }
            if (type === "object") {
                if (value.nodeType !== undefined) {
                    if (value.nodeType === 3) {
                        return (/\S/).test(value.nodeValue) ? "textnode": "whitespace"
                    } else {
                        return "element"
                    }
                }
                return "object"
            }
        },
        isEmpty: function(value, allowEmptyString) {
            return (value === null) || (value === undefined) || (!allowEmptyString ? value === "": false) || (Ext.isArray(value) && value.length === 0)
        },
        isArray: ("isArray" in Array) ? Array.isArray: function(value) {
            return toString.call(value) === "[object Array]"
        },
        isDate: function(value) {
            return toString.call(value) === "[object Date]"
        },
        isMSDate: function(value) {
            if (!Ext.isString(value)) {
                return false
            } else {
                return value.match("\\\\?/Date\\(([-+])?(\\d+)(?:[+-]\\d{4})?\\)\\\\?/") !== null
            }
        },
        isObject: (toString.call(null) === "[object Object]") ?
        function(value) {
            return value !== null && value !== undefined && toString.call(value) === "[object Object]" && value.ownerDocument === undefined
        }: function(value) {
            return toString.call(value) === "[object Object]"
        },
        isSimpleObject: function(value) {
            return value instanceof Object && value.constructor === Object
        },
        isPrimitive: function(value) {
            var type = typeof value;
            return type === "string" || type === "number" || type === "boolean"
        },
        isFunction: (typeof document !== "undefined" && typeof document.getElementsByTagName("body") === "function") ?
        function(value) {
            return toString.call(value) === "[object Function]"
        }: function(value) {
            return typeof value === "function"
        },
        isNumber: function(value) {
            return typeof value === "number" && isFinite(value)
        },
        isNumeric: function(value) {
            return ! isNaN(parseFloat(value)) && isFinite(value)
        },
        isString: function(value) {
            return typeof value === "string"
        },
        isBoolean: function(value) {
            return typeof value === "boolean"
        },
        isElement: function(value) {
            return value ? value.nodeType === 1 : false
        },
        isTextNode: function(value) {
            return value ? value.nodeName === "#text": false
        },
        isDefined: function(value) {
            return typeof value !== "undefined"
        },
        isIterable: function(value) {
            return (value && typeof value !== "string") ? value.length !== undefined: false
        }
    });
    Ext.apply(Ext, {
        clone: function(item) {
            if (item === null || item === undefined) {
                return item
            }
            if (item.nodeType && item.cloneNode) {
                return item.cloneNode(true)
            }
            var type = toString.call(item);
            if (type === "[object Date]") {
                return new Date(item.getTime())
            }
            var i, j, k, clone, key;
            if (type === "[object Array]") {
                i = item.length;
                clone = [];
                while (i--) {
                    clone[i] = Ext.clone(item[i])
                }
            } else {
                if (type === "[object Object]" && item.constructor === Object) {
                    clone = {};
                    for (key in item) {
                        clone[key] = Ext.clone(item[key])
                    }
                    if (enumerables) {
                        for (j = enumerables.length; j--;) {
                            k = enumerables[j];
                            clone[k] = item[k]
                        }
                    }
                }
            }
            return clone || item
        },
        getUniqueGlobalNamespace: function() {
            var uniqueGlobalNamespace = this.uniqueGlobalNamespace;
            if (uniqueGlobalNamespace === undefined) {
                var i = 0;
                do {
                    uniqueGlobalNamespace = "ExtBox" + (++i)
                } while ( Ext . global [ uniqueGlobalNamespace ] !== undefined);
                Ext.global[uniqueGlobalNamespace] = Ext;
                this.uniqueGlobalNamespace = uniqueGlobalNamespace
            }
            return uniqueGlobalNamespace
        },
        functionFactory: function() {
            var args = Array.prototype.slice.call(arguments),
            ln = args.length;
            if (ln > 0) {
                args[ln - 1] = "var Ext=window." + this.getUniqueGlobalNamespace() + ";" + args[ln - 1]
            }
            return Function.prototype.constructor.apply(Function.prototype, args)
        },
        globalEval: ("execScript" in global) ?
        function(code) {
            global.execScript(code)
        }: function(code) { (function() {
                eval(code)
            })()
        }
    });
    Ext.type = Ext.typeOf
})(); (function() {
    var a = "2.3.1.410",
    b;
    Ext.Version = b = Ext.extend(Object, {
        constructor: function(e) {
            var d = this.toNumber,
            g, f;
            if (e instanceof b) {
                return e
            }
            this.version = this.shortVersion = String(e).toLowerCase().replace(/_/g, ".").replace(/[\-+]/g, "");
            f = this.version.search(/([^\d\.])/);
            if (f !== -1) {
                this.release = this.version.substr(f, e.length);
                this.shortVersion = this.version.substr(0, f)
            }
            this.shortVersion = this.shortVersion.replace(/[^\d]/g, "");
            g = this.version.split(".");
            this.major = d(g.shift());
            this.minor = d(g.shift());
            this.patch = d(g.shift());
            this.build = d(g.shift());
            return this
        },
        toNumber: function(d) {
            d = parseInt(d || 0, 10);
            if (isNaN(d)) {
                d = 0
            }
            return d
        },
        toString: function() {
            return this.version
        },
        valueOf: function() {
            return this.version
        },
        getMajor: function() {
            return this.major || 0
        },
        getMinor: function() {
            return this.minor || 0
        },
        getPatch: function() {
            return this.patch || 0
        },
        getBuild: function() {
            return this.build || 0
        },
        getRelease: function() {
            return this.release || ""
        },
        isGreaterThan: function(d) {
            return b.compare(this.version, d) === 1
        },
        isGreaterThanOrEqual: function(d) {
            return b.compare(this.version, d) >= 0
        },
        isLessThan: function(d) {
            return b.compare(this.version, d) === -1
        },
        isLessThanOrEqual: function(d) {
            return b.compare(this.version, d) <= 0
        },
        equals: function(d) {
            return b.compare(this.version, d) === 0
        },
        match: function(d) {
            d = String(d);
            return this.version.substr(0, d.length) === d
        },
        toArray: function() {
            return [this.getMajor(), this.getMinor(), this.getPatch(), this.getBuild(), this.getRelease()]
        },
        getShortVersion: function() {
            return this.shortVersion
        },
        gt: function() {
            return this.isGreaterThan.apply(this, arguments)
        },
        lt: function() {
            return this.isLessThan.apply(this, arguments)
        },
        gtEq: function() {
            return this.isGreaterThanOrEqual.apply(this, arguments)
        },
        ltEq: function() {
            return this.isLessThanOrEqual.apply(this, arguments)
        }
    });
    Ext.apply(b, {
        releaseValueMap: {
            dev: -6,
            alpha: -5,
            a: -5,
            beta: -4,
            b: -4,
            rc: -3,
            "#": -2,
            p: -1,
            pl: -1
        },
        getComponentValue: function(d) {
            return ! d ? 0 : (isNaN(d) ? this.releaseValueMap[d] || d: parseInt(d, 10))
        },
        compare: function(h, g) {
            var e, f, d;
            h = new b(h).toArray();
            g = new b(g).toArray();
            for (d = 0; d < Math.max(h.length, g.length); d++) {
                e = this.getComponentValue(h[d]);
                f = this.getComponentValue(g[d]);
                if (e < f) {
                    return - 1
                } else {
                    if (e > f) {
                        return 1
                    }
                }
            }
            return 0
        }
    });
    Ext.apply(Ext, {
        versions: {},
        lastRegisteredVersion: null,
        setVersion: function(e, d) {
            Ext.versions[e] = new b(d);
            Ext.lastRegisteredVersion = Ext.versions[e];
            return this
        },
        getVersion: function(d) {
            if (d === undefined) {
                return Ext.lastRegisteredVersion
            }
            return Ext.versions[d]
        },
        deprecate: function(d, f, g, e) {
            if (b.compare(Ext.getVersion(d), f) < 1) {
                g.call(e)
            }
        }
    });
    Ext.setVersion("core", a)
})();
Ext.String = {
    trimRegex: /^[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+|[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+$/g,
    escapeRe: /('|\\)/g,
    formatRe: /\{(\d+)\}/g,
    escapeRegexRe: /([-.*+?^${}()|[\]\/\\])/g,
    htmlEncode: (function() {
        var e = {
            "&": "&amp;",
            ">": "&gt;",
            "<": "&lt;",
            '"': "&quot;"
        },
        b = [],
        d,
        a;
        for (d in e) {
            b.push(d)
        }
        a = new RegExp("(" + b.join("|") + ")", "g");
        return function(f) {
            return (!f) ? f: String(f).replace(a,
            function(h, g) {
                return e[g]
            })
        }
    })(),
    htmlDecode: (function() {
        var e = {
            "&amp;": "&",
            "&gt;": ">",
            "&lt;": "<",
            "&quot;": '"'
        },
        b = [],
        d,
        a;
        for (d in e) {
            b.push(d)
        }
        a = new RegExp("(" + b.join("|") + "|&#[0-9]{1,5};)", "g");
        return function(f) {
            return (!f) ? f: String(f).replace(a,
            function(h, g) {
                if (g in e) {
                    return e[g]
                } else {
                    return String.fromCharCode(parseInt(g.substr(2), 10))
                }
            })
        }
    })(),
    urlAppend: function(b, a) {
        if (!Ext.isEmpty(a)) {
            return b + (b.indexOf("?") === -1 ? "?": "&") + a
        }
        return b
    },
    trim: function(a) {
        return a.replace(Ext.String.trimRegex, "")
    },
    capitalize: function(a) {
        return a.charAt(0).toUpperCase() + a.substr(1)
    },
    ellipsis: function(d, a, e) {
        if (d && d.length > a) {
            if (e) {
                var f = d.substr(0, a - 2),
                b = Math.max(f.lastIndexOf(" "), f.lastIndexOf("."), f.lastIndexOf("!"), f.lastIndexOf("?"));
                if (b !== -1 && b >= (a - 15)) {
                    return f.substr(0, b) + "..."
                }
            }
            return d.substr(0, a - 3) + "..."
        }
        return d
    },
    escapeRegex: function(a) {
        return a.replace(Ext.String.escapeRegexRe, "\\$1")
    },
    escape: function(a) {
        return a.replace(Ext.String.escapeRe, "\\$1")
    },
    toggle: function(b, d, a) {
        return b === d ? a: d
    },
    leftPad: function(b, d, e) {
        var a = String(b);
        e = e || " ";
        while (a.length < d) {
            a = e + a
        }
        return a
    },
    format: function(b) {
        var a = Ext.Array.toArray(arguments, 1);
        return b.replace(Ext.String.formatRe,
        function(d, e) {
            return a[e]
        })
    },
    repeat: function(f, e, b) {
        for (var a = [], d = e; d--;) {
            a.push(f)
        }
        return a.join(b || "")
    }
};
Ext.htmlEncode = Ext.String.htmlEncode;
Ext.htmlDecode = Ext.String.htmlDecode;
Ext.urlAppend = Ext.String.urlAppend; (function() {
    var g = Array.prototype,
    p = g.slice,
    r = function() {
        var D = [],
        e,
        C = 20;
        if (!D.splice) {
            return false
        }
        while (C--) {
            D.push("A")
        }
        D.splice(15, 0, "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F");
        e = D.length;
        D.splice(13, 0, "XXX");
        if (e + 1 != D.length) {
            return false
        }
        return true
    } (),
    j = "forEach" in g,
    v = "map" in g,
    q = "indexOf" in g,
    B = "every" in g,
    d = "some" in g,
    f = "filter" in g,
    o = function() {
        var e = [1, 2, 3, 4, 5].sort(function() {
            return 0
        });
        return e[0] === 1 && e[1] === 2 && e[2] === 3 && e[3] === 4 && e[4] === 5
    } (),
    k = true,
    a;
    try {
        if (typeof document !== "undefined") {
            p.call(document.getElementsByTagName("body"))
        }
    } catch(t) {
        k = false
    }
    function n(C, e) {
        return (e < 0) ? Math.max(0, C.length + e) : Math.min(C.length, e)
    }
    function A(J, I, C, M) {
        var N = M ? M.length: 0,
        E = J.length,
        K = n(J, I);
        if (K === E) {
            if (N) {
                J.push.apply(J, M)
            }
        } else {
            var H = Math.min(C, E - K),
            L = K + H,
            D = L + N - H,
            e = E - L,
            F = E - H,
            G;
            if (D < L) {
                for (G = 0; G < e; ++G) {
                    J[D + G] = J[L + G]
                }
            } else {
                if (D > L) {
                    for (G = e; G--;) {
                        J[D + G] = J[L + G]
                    }
                }
            }
            if (N && K === F) {
                J.length = F;
                J.push.apply(J, M)
            } else {
                J.length = F + N;
                for (G = 0; G < N; ++G) {
                    J[K + G] = M[G]
                }
            }
        }
        return J
    }
    function i(E, e, D, C) {
        if (C && C.length) {
            if (e < E.length) {
                E.splice.apply(E, [e, D].concat(C))
            } else {
                E.push.apply(E, C)
            }
        } else {
            E.splice(e, D)
        }
        return E
    }
    function b(D, e, C) {
        return A(D, e, C)
    }
    function s(D, e, C) {
        D.splice(e, C);
        return D
    }
    function m(F, e, D) {
        var E = n(F, e),
        C = F.slice(e, n(F, E + D));
        if (arguments.length < 4) {
            A(F, E, D)
        } else {
            A(F, E, D, p.call(arguments, 3))
        }
        return C
    }
    function h(e) {
        return e.splice.apply(e, p.call(arguments, 1))
    }
    var z = r ? s: b,
    u = r ? i: A,
    y = r ? h: m;
    a = Ext.Array = {
        each: function(G, E, D, e) {
            G = a.from(G);
            var C, F = G.length;
            if (e !== true) {
                for (C = 0; C < F; C++) {
                    if (E.call(D || G[C], G[C], C, G) === false) {
                        return C
                    }
                }
            } else {
                for (C = F - 1; C > -1; C--) {
                    if (E.call(D || G[C], G[C], C, G) === false) {
                        return C
                    }
                }
            }
            return true
        },
        forEach: j ?
        function(D, C, e) {
            return D.forEach(C, e)
        }: function(F, D, C) {
            var e = 0,
            E = F.length;
            for (; e < E; e++) {
                D.call(C, F[e], e, F)
            }
        },
        indexOf: (q) ?
        function(D, e, C) {
            return D.indexOf(e, C)
        }: function(F, D, E) {
            var e, C = F.length;
            for (e = (E < 0) ? Math.max(0, C + E) : E || 0; e < C; e++) {
                if (F[e] === D) {
                    return e
                }
            }
            return - 1
        },
        contains: q ?
        function(C, e) {
            return C.indexOf(e) !== -1
        }: function(E, D) {
            var e, C;
            for (e = 0, C = E.length; e < C; e++) {
                if (E[e] === D) {
                    return true
                }
            }
            return false
        },
        toArray: function(D, F, e) {
            if (!D || !D.length) {
                return []
            }
            if (typeof D === "string") {
                D = D.split("")
            }
            if (k) {
                return p.call(D, F || 0, e || D.length)
            }
            var E = [],
            C;
            F = F || 0;
            e = e ? ((e < 0) ? D.length + e: e) : D.length;
            for (C = F; C < e; C++) {
                E.push(D[C])
            }
            return E
        },
        pluck: function(G, e) {
            var C = [],
            D,
            F,
            E;
            for (D = 0, F = G.length; D < F; D++) {
                E = G[D];
                C.push(E[e])
            }
            return C
        },
        map: v ?
        function(D, C, e) {
            return D.map(C, e)
        }: function(G, F, E) {
            var D = [],
            C = 0,
            e = G.length;
            for (; C < e; C++) {
                D[C] = F.call(E, G[C], C, G)
            }
            return D
        },
        every: function(F, D, C) {
            if (B) {
                return F.every(D, C)
            }
            var e = 0,
            E = F.length;
            for (; e < E; ++e) {
                if (!D.call(C, F[e], e, F)) {
                    return false
                }
            }
            return true
        },
        some: function(F, D, C) {
            if (d) {
                return F.some(D, C)
            }
            var e = 0,
            E = F.length;
            for (; e < E; ++e) {
                if (D.call(C, F[e], e, F)) {
                    return true
                }
            }
            return false
        },
        clean: function(F) {
            var C = [],
            e = 0,
            E = F.length,
            D;
            for (; e < E; e++) {
                D = F[e];
                if (!Ext.isEmpty(D)) {
                    C.push(D)
                }
            }
            return C
        },
        unique: function(F) {
            var E = [],
            e = 0,
            D = F.length,
            C;
            for (; e < D; e++) {
                C = F[e];
                if (a.indexOf(E, C) === -1) {
                    E.push(C)
                }
            }
            return E
        },
        filter: function(G, E, D) {
            if (f) {
                return G.filter(E, D)
            }
            var C = [],
            e = 0,
            F = G.length;
            for (; e < F; e++) {
                if (E.call(D, G[e], e, G)) {
                    C.push(G[e])
                }
            }
            return C
        },
        from: function(C, e) {
            if (C === undefined || C === null) {
                return []
            }
            if (Ext.isArray(C)) {
                return (e) ? p.call(C) : C
            }
            if (C && C.length !== undefined && typeof C !== "string") {
                return a.toArray(C)
            }
            return [C]
        },
        remove: function(D, C) {
            var e = a.indexOf(D, C);
            if (e !== -1) {
                z(D, e, 1)
            }
            return D
        },
        include: function(C, e) {
            if (!a.contains(C, e)) {
                C.push(e)
            }
        },
        clone: function(e) {
            return p.call(e)
        },
        merge: function() {
            var e = p.call(arguments),
            E = [],
            C,
            D;
            for (C = 0, D = e.length; C < D; C++) {
                E = E.concat(e[C])
            }
            return a.unique(E)
        },
        intersect: function() {
            var e = [],
            F = p.call(arguments),
            E,
            G,
            D,
            C;
            if (!F.length) {
                return e
            }
            F = F.sort(function(I, H) {
                if (I.length > H.length) {
                    return 1
                } else {
                    if (I.length < H.length) {
                        return - 1
                    } else {
                        return 0
                    }
                }
            });
            G = a.unique(F[0]);
            for (D = 0; D < G.length; D++) {
                E = G[D];
                for (C = 1; C < F.length; C++) {
                    if (F[C].indexOf(E) === -1) {
                        break
                    }
                    if (C == (F.length - 1)) {
                        e.push(E)
                    }
                }
            }
            return e
        },
        difference: function(C, e) {
            var H = p.call(C),
            F = H.length,
            E,
            D,
            G;
            for (E = 0, G = e.length; E < G; E++) {
                for (D = 0; D < F; D++) {
                    if (H[D] === e[E]) {
                        z(H, D, 1);
                        D--;
                        F--
                    }
                }
            }
            return H
        },
        slice: function(D, C, e) {
            return p.call(D, C, e)
        },
        sort: function(I, H) {
            if (o) {
                if (H) {
                    return I.sort(H)
                } else {
                    return I.sort()
                }
            }
            var F = I.length,
            E = 0,
            G, e, D, C;
            for (; E < F; E++) {
                D = E;
                for (e = E + 1; e < F; e++) {
                    if (H) {
                        G = H(I[e], I[D]);
                        if (G < 0) {
                            D = e
                        }
                    } else {
                        if (I[e] < I[D]) {
                            D = e
                        }
                    }
                }
                if (D !== E) {
                    C = I[E];
                    I[E] = I[D];
                    I[D] = C
                }
            }
            return I
        },
        flatten: function(D) {
            var C = [];
            function e(E) {
                var G, H, F;
                for (G = 0, H = E.length; G < H; G++) {
                    F = E[G];
                    if (Ext.isArray(F)) {
                        e(F)
                    } else {
                        C.push(F)
                    }
                }
                return C
            }
            return e(D)
        },
        min: function(G, F) {
            var C = G[0],
            e,
            E,
            D;
            for (e = 0, E = G.length; e < E; e++) {
                D = G[e];
                if (F) {
                    if (F(C, D) === 1) {
                        C = D
                    }
                } else {
                    if (D < C) {
                        C = D
                    }
                }
            }
            return C
        },
        max: function(G, F) {
            var e = G[0],
            C,
            E,
            D;
            for (C = 0, E = G.length; C < E; C++) {
                D = G[C];
                if (F) {
                    if (F(e, D) === -1) {
                        e = D
                    }
                } else {
                    if (D > e) {
                        e = D
                    }
                }
            }
            return e
        },
        mean: function(e) {
            return e.length > 0 ? a.sum(e) / e.length: undefined
        },
        sum: function(F) {
            var C = 0,
            e, E, D;
            for (e = 0, E = F.length; e < E; e++) {
                D = F[e];
                C += D
            }
            return C
        },
        erase: z,
        insert: function(D, C, e) {
            return u(D, C, 0, e)
        },
        replace: u,
        splice: y
    };
    Ext.each = a.each;
    a.union = a.merge;
    Ext.min = a.min;
    Ext.max = a.max;
    Ext.sum = a.sum;
    Ext.mean = a.mean;
    Ext.flatten = a.flatten;
    Ext.clean = a.clean;
    Ext.unique = a.unique;
    Ext.pluck = a.pluck;
    Ext.toArray = function() {
        return a.toArray.apply(a, arguments)
    }
})(); (function() {
    var a = (0.9).toFixed() !== "1";
    Ext.Number = {
        constrain: function(e, d, b) {
            e = parseFloat(e);
            if (!isNaN(d)) {
                e = Math.max(e, d)
            }
            if (!isNaN(b)) {
                e = Math.min(e, b)
            }
            return e
        },
        snap: function(f, d, e, h) {
            var g = f,
            b;
            if (! (d && f)) {
                return f
            }
            b = f % d;
            if (b !== 0) {
                g -= b;
                if (b * 2 >= d) {
                    g += d
                } else {
                    if (b * 2 < -d) {
                        g -= d
                    }
                }
            }
            return Ext.Number.constrain(g, e, h)
        },
        toFixed: function(e, b) {
            if (a) {
                b = b || 0;
                var d = Math.pow(10, b);
                return (Math.round(e * d) / d).toFixed(b)
            }
            return e.toFixed(b)
        },
        from: function(d, b) {
            if (isFinite(d)) {
                d = parseFloat(d)
            }
            return ! isNaN(d) ? d: b
        }
    }
})();
Ext.num = function() {
    return Ext.Number.from.apply(this, arguments)
}; (function() {
    var a = function() {};
    var b = Ext.Object = {
        chain: ("create" in Object) ?
        function(d) {
            return Object.create(d)
        }: function(e) {
            a.prototype = e;
            var d = new a();
            a.prototype = null;
            return d
        },
        toQueryObjects: function(f, k, e) {
            var d = b.toQueryObjects,
            j = [],
            g,
            h;
            if (Ext.isArray(k)) {
                for (g = 0, h = k.length; g < h; g++) {
                    if (e) {
                        j = j.concat(d(f + "[" + g + "]", k[g], true))
                    } else {
                        j.push({
                            name: f,
                            value: k[g]
                        })
                    }
                }
            } else {
                if (Ext.isObject(k)) {
                    for (g in k) {
                        if (k.hasOwnProperty(g)) {
                            if (e) {
                                j = j.concat(d(f + "[" + g + "]", k[g], true))
                            } else {
                                j.push({
                                    name: f,
                                    value: k[g]
                                })
                            }
                        }
                    }
                } else {
                    j.push({
                        name: f,
                        value: k
                    })
                }
            }
            return j
        },
        toQueryString: function(g, e) {
            var h = [],
            f = [],
            m,
            k,
            n,
            d,
            o;
            for (m in g) {
                if (g.hasOwnProperty(m)) {
                    h = h.concat(b.toQueryObjects(m, g[m], e))
                }
            }
            for (k = 0, n = h.length; k < n; k++) {
                d = h[k];
                o = d.value;
                if (Ext.isEmpty(o)) {
                    o = ""
                } else {
                    if (Ext.isDate(o)) {
                        o = Ext.Date.toString(o)
                    }
                }
                f.push(encodeURIComponent(d.name) + "=" + encodeURIComponent(String(o)))
            }
            return f.join("&")
        },
        fromQueryString: function(e, s) {
            var n = e.replace(/^\?/, "").split("&"),
            v = {},
            t,
            k,
            z,
            o,
            r,
            g,
            p,
            q,
            d,
            h,
            u,
            m,
            y,
            f;
            for (r = 0, g = n.length; r < g; r++) {
                p = n[r];
                if (p.length > 0) {
                    k = p.split("=");
                    z = decodeURIComponent(k[0]);
                    o = (k[1] !== undefined) ? decodeURIComponent(k[1]) : "";
                    if (!s) {
                        if (v.hasOwnProperty(z)) {
                            if (!Ext.isArray(v[z])) {
                                v[z] = [v[z]]
                            }
                            v[z].push(o)
                        } else {
                            v[z] = o
                        }
                    } else {
                        h = z.match(/(\[):?([^\]]*)\]/g);
                        u = z.match(/^([^\[]+)/);
                        z = u[0];
                        m = [];
                        if (h === null) {
                            v[z] = o;
                            continue
                        }
                        for (q = 0, d = h.length; q < d; q++) {
                            y = h[q];
                            y = (y.length === 2) ? "": y.substring(1, y.length - 1);
                            m.push(y)
                        }
                        m.unshift(z);
                        t = v;
                        for (q = 0, d = m.length; q < d; q++) {
                            y = m[q];
                            if (q === d - 1) {
                                if (Ext.isArray(t) && y === "") {
                                    t.push(o)
                                } else {
                                    t[y] = o
                                }
                            } else {
                                if (t[y] === undefined || typeof t[y] === "string") {
                                    f = m[q + 1];
                                    t[y] = (Ext.isNumeric(f) || f === "") ? [] : {}
                                }
                                t = t[y]
                            }
                        }
                    }
                }
            }
            return v
        },
        each: function(d, f, e) {
            for (var g in d) {
                if (d.hasOwnProperty(g)) {
                    if (f.call(e || d, g, d[g], d) === false) {
                        return
                    }
                }
            }
        },
        merge: function(d) {
            var j = 1,
            k = arguments.length,
            e = b.merge,
            g = Ext.clone,
            h, n, m, f;
            for (; j < k; j++) {
                h = arguments[j];
                for (n in h) {
                    m = h[n];
                    if (m && m.constructor === Object) {
                        f = d[n];
                        if (f && f.constructor === Object) {
                            e(f, m)
                        } else {
                            d[n] = g(m)
                        }
                    } else {
                        d[n] = m
                    }
                }
            }
            return d
        },
        mergeIf: function(k) {
            var g = 1,
            h = arguments.length,
            e = Ext.clone,
            d, f, j;
            for (; g < h; g++) {
                d = arguments[g];
                for (f in d) {
                    if (! (f in k)) {
                        j = d[f];
                        if (j && j.constructor === Object) {
                            k[f] = e(j)
                        } else {
                            k[f] = j
                        }
                    }
                }
            }
            return k
        },
        getKey: function(d, f) {
            for (var e in d) {
                if (d.hasOwnProperty(e) && d[e] === f) {
                    return e
                }
            }
            return null
        },
        getValues: function(e) {
            var d = [],
            f;
            for (f in e) {
                if (e.hasOwnProperty(f)) {
                    d.push(e[f])
                }
            }
            return d
        },
        getKeys: ("keys" in Object) ? Object.keys: function(d) {
            var e = [],
            f;
            for (f in d) {
                if (d.hasOwnProperty(f)) {
                    e.push(f)
                }
            }
            return e
        },
        getSize: function(d) {
            var e = 0,
            f;
            for (f in d) {
                if (d.hasOwnProperty(f)) {
                    e++
                }
            }
            return e
        },
        classify: function(g) {
            var j = [],
            d = [],
            f = {},
            e = function() {
                var m = 0,
                n = j.length,
                o;
                for (; m < n; m++) {
                    o = j[m];
                    this[o] = new f[o]
                }
                n = d.length;
                for (m = 0; m < n; m++) {
                    o = d[m];
                    this[o] = g[o].slice()
                }
            },
            h,
            k,
            i;
            for (h in g) {
                if (g.hasOwnProperty(h)) {
                    k = g[h];
                    if (k) {
                        i = k.constructor;
                        if (i === Object) {
                            j.push(h);
                            f[h] = b.classify(k)
                        } else {
                            if (i === Array) {
                                d.push(h)
                            }
                        }
                    }
                }
            }
            e.prototype = g;
            return e
        },
        equals: function(d, g) {
            var h = typeof d,
            f = typeof g,
            e;
            if (f === f) {
                if (h === "object") {
                    for (e in d) {
                        if (! (e in g)) {
                            return false
                        }
                        if (!b.equals(d[e], g[e])) {
                            return false
                        }
                    }
                    for (e in g) {
                        if (! (e in d)) {
                            return false
                        }
                    }
                    return true
                } else {
                    return d === g
                }
            }
            return false
        },
        defineProperty: ("defineProperty" in Object) ? Object.defineProperty: function(e, d, f) {
            if (f.get) {
                e.__defineGetter__(d, f.get)
            }
            if (f.set) {
                e.__defineSetter__(d, f.set)
            }
        }
    };
    Ext.merge = Ext.Object.merge;
    Ext.mergeIf = Ext.Object.mergeIf;
    Ext.urlEncode = function() {
        var d = Ext.Array.from(arguments),
        e = "";
        if ((typeof d[1] === "string")) {
            e = d[1] + "&";
            d[1] = false
        }
        return e + b.toQueryString.apply(b, d)
    };
    Ext.urlDecode = function() {
        return b.fromQueryString.apply(b, arguments)
    }
})();
Ext.Function = {
    flexSetter: function(a) {
        return function(e, d) {
            var f, g;
            if (e === null) {
                return this
            }
            if (typeof e !== "string") {
                for (f in e) {
                    if (e.hasOwnProperty(f)) {
                        a.call(this, f, e[f])
                    }
                }
                if (Ext.enumerables) {
                    for (g = Ext.enumerables.length; g--;) {
                        f = Ext.enumerables[g];
                        if (e.hasOwnProperty(f)) {
                            a.call(this, f, e[f])
                        }
                    }
                }
            } else {
                a.call(this, e, d)
            }
            return this
        }
    },
    bind: function(e, d, b, a) {
        if (arguments.length === 2) {
            return function() {
                return e.apply(d, arguments)
            }
        }
        var g = e,
        f = Array.prototype.slice;
        return function() {
            var h = b || arguments;
            if (a === true) {
                h = f.call(arguments, 0);
                h = h.concat(b)
            } else {
                if (typeof a == "number") {
                    h = f.call(arguments, 0);
                    Ext.Array.insert(h, a, b)
                }
            }
            return g.apply(d || window, h)
        }
    },
    pass: function(d, a, b) {
        if (!Ext.isArray(a)) {
            a = Ext.Array.clone(a)
        }
        return function() {
            a.push.apply(a, arguments);
            return d.apply(b || this, a)
        }
    },
    alias: function(b, a) {
        return function() {
            return b[a].apply(b, arguments)
        }
    },
    clone: function(a) {
        return function() {
            return a.apply(this, arguments)
        }
    },
    createInterceptor: function(e, d, b, a) {
        var f = e;
        if (!Ext.isFunction(d)) {
            return e
        } else {
            return function() {
                var h = this,
                g = arguments;
                d.target = h;
                d.method = e;
                return (d.apply(b || h || window, g) !== false) ? e.apply(h || window, g) : a || null
            }
        }
    },
    createDelayed: function(f, d, e, b, a) {
        if (e || b) {
            f = Ext.Function.bind(f, e, b, a)
        }
        return function() {
            var h = this,
            g = Array.prototype.slice.call(arguments);
            setTimeout(function() {
                f.apply(h, g)
            },
            d)
        }
    },
    defer: function(f, d, e, b, a) {
        f = Ext.Function.bind(f, e, b, a);
        if (d > 0) {
            return setTimeout(f, d)
        }
        f();
        return 0
    },
    createSequence: function(b, d, a) {
        if (!d) {
            return b
        } else {
            return function() {
                var e = b.apply(this, arguments);
                d.apply(a || this, arguments);
                return e
            }
        }
    },
    createBuffered: function(f, b, e, d) {
        var a;
        return function() {
            var h = d || Array.prototype.slice.call(arguments, 0),
            g = e || this;
            if (a) {
                clearTimeout(a)
            }
            a = setTimeout(function() {
                f.apply(g, h)
            },
            b)
        }
    },
    createThrottled: function(f, b, e) {
        var g, a, d, i, h = function() {
            f.apply(e || this, d);
            g = new Date().getTime()
        };
        return function() {
            a = new Date().getTime() - g;
            d = arguments;
            clearTimeout(i);
            if (!g || (a >= b)) {
                h()
            } else {
                i = setTimeout(h, b - a)
            }
        }
    },
    interceptBefore: function(b, a, e, d) {
        var f = b[a] || Ext.emptyFn;
        return (b[a] = function() {
            var g = e.apply(d || this, arguments);
            f.apply(this, arguments);
            return g
        })
    },
    interceptAfter: function(b, a, e, d) {
        var f = b[a] || Ext.emptyFn;
        return (b[a] = function() {
            f.apply(this, arguments);
            return e.apply(d || this, arguments)
        })
    }
};
Ext.defer = Ext.Function.alias(Ext.Function, "defer");
Ext.pass = Ext.Function.alias(Ext.Function, "pass");
Ext.bind = Ext.Function.alias(Ext.Function, "bind");
Ext.JSON = new(function() {
    var useHasOwn = !!{}.hasOwnProperty,
    isNative = function() {
        var useNative = null;
        return function() {
            if (useNative === null) {
                useNative = Ext.USE_NATIVE_JSON && window.JSON && JSON.toString() == "[object JSON]"
            }
            return useNative
        }
    } (),
    pad = function(n) {
        return n < 10 ? "0" + n: n
    },
    doDecode = function(json) {
        return eval("(" + json + ")")
    },
    doEncode = function(o) {
        if (!Ext.isDefined(o) || o === null) {
            return "null"
        } else {
            if (Ext.isArray(o)) {
                return encodeArray(o)
            } else {
                if (Ext.isDate(o)) {
                    return Ext.JSON.encodeDate(o)
                } else {
                    if (Ext.isString(o)) {
                        if (Ext.isMSDate(o)) {
                            return encodeMSDate(o)
                        } else {
                            return encodeString(o)
                        }
                    } else {
                        if (typeof o == "number") {
                            return isFinite(o) ? String(o) : "null"
                        } else {
                            if (Ext.isBoolean(o)) {
                                return String(o)
                            } else {
                                if (Ext.isObject(o)) {
                                    return encodeObject(o)
                                } else {
                                    if (typeof o === "function") {
                                        return "null"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return "undefined"
    },
    m = {
        "\b": "\\b",
        "\t": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\",
        "\x0b": "\\u000b"
    },
    charToReplace = /[\\\"\x00-\x1f\x7f-\uffff]/g,
    encodeString = function(s) {
        return '"' + s.replace(charToReplace,
        function(a) {
            var c = m[a];
            return typeof c === "string" ? c: "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice( - 4)
        }) + '"'
    },
    encodeArray = function(o) {
        var a = ["[", ""],
        len = o.length,
        i;
        for (i = 0; i < len; i += 1) {
            a.push(doEncode(o[i]), ",")
        }
        a[a.length - 1] = "]";
        return a.join("")
    },
    encodeObject = function(o) {
        var a = ["{", ""],
        i;
        for (i in o) {
            if (!useHasOwn || o.hasOwnProperty(i)) {
                a.push(doEncode(i), ":", doEncode(o[i]), ",")
            }
        }
        a[a.length - 1] = "}";
        return a.join("")
    },
    encodeMSDate = function(o) {
        return '"' + o + '"'
    };
    this.encodeDate = function(o) {
        return '"' + o.getFullYear() + "-" + pad(o.getMonth() + 1) + "-" + pad(o.getDate()) + "T" + pad(o.getHours()) + ":" + pad(o.getMinutes()) + ":" + pad(o.getSeconds()) + '"'
    };
    this.encode = function() {
        var ec;
        return function(o) {
            if (!ec) {
                ec = isNative() ? JSON.stringify: doEncode
            }
            return ec(o)
        }
    } ();
    this.decode = function() {
        var dc;
        return function(json, safe) {
            if (!dc) {
                dc = isNative() ? JSON.parse: doDecode
            }
            try {
                return dc(json)
            } catch(e) {
                if (safe === true) {
                    return null
                }
                Ext.Error.raise({
                    sourceClass: "Ext.JSON",
                    sourceMethod: "decode",
                    msg: "You're trying to decode an invalid JSON String: " + json
                })
            }
        }
    } ()
})();
Ext.encode = Ext.JSON.encode;
Ext.decode = Ext.JSON.decode;
Ext.Error = {
    raise: function(a) {
        throw new Error(a.msg)
    }
};
Ext.Date = {
    now: Date.now,
    toString: function(a) {
        if (!a) {
            a = new Date()
        }
        var b = Ext.String.leftPad;
        return a.getFullYear() + "-" + b(a.getMonth() + 1, 2, "0") + "-" + b(a.getDate(), 2, "0") + "T" + b(a.getHours(), 2, "0") + ":" + b(a.getMinutes(), 2, "0") + ":" + b(a.getSeconds(), 2, "0")
    }
}; (function(a) {
    var d = [],
    b = function() {};
    Ext.apply(b, {
        $className: "Ext.Base",
        $isClass: true,
        create: function() {
            return Ext.create.apply(Ext, [this].concat(Array.prototype.slice.call(arguments, 0)))
        },
        extend: function(j) {
            var e = j.prototype,
            g, h, k, f, m;
            g = this.prototype = Ext.Object.chain(e);
            g.self = this;
            this.superclass = g.superclass = e;
            if (!j.$isClass) {
                Ext.apply(g, Ext.Base.prototype);
                g.constructor = function() {
                    e.constructor.apply(this, arguments)
                }
            }
            m = e.$inheritableStatics;
            if (m) {
                for (h = 0, k = m.length; h < k; h++) {
                    f = m[h];
                    if (!this.hasOwnProperty(f)) {
                        this[f] = j[f]
                    }
                }
            }
            if (j.$onExtended) {
                this.$onExtended = j.$onExtended.slice()
            }
            g.config = g.defaultConfig = new g.configClass;
            g.initConfigList = g.initConfigList.slice();
            g.initConfigMap = Ext.Object.chain(g.initConfigMap)
        },
        "$onExtended": [],
        triggerExtended: function() {
            var g = this.$onExtended,
            f = g.length,
            e, h;
            if (f > 0) {
                for (e = 0; e < f; e++) {
                    h = g[e];
                    h.fn.apply(h.scope || this, arguments)
                }
            }
        },
        onExtended: function(f, e) {
            this.$onExtended.push({
                fn: f,
                scope: e
            });
            return this
        },
        addConfig: function(g, j) {
            var k = this.prototype,
            h = k.initConfigList,
            f = k.initConfigMap,
            i = k.defaultConfig,
            n, e, m;
            j = Boolean(j);
            for (e in g) {
                if (g.hasOwnProperty(e) && (j || !(e in i))) {
                    m = g[e];
                    n = f[e];
                    if (m !== null) {
                        if (!n) {
                            f[e] = true;
                            h.push(e)
                        }
                    } else {
                        if (n) {
                            f[e] = false;
                            Ext.Array.remove(h, e)
                        }
                    }
                }
            }
            if (j) {
                Ext.merge(i, g)
            } else {
                Ext.mergeIf(i, g)
            }
            k.configClass = Ext.Object.classify(i)
        },
        addStatics: function(e) {
            var g, f;
            for (f in e) {
                if (e.hasOwnProperty(f)) {
                    g = e[f];
                    this[f] = g
                }
            }
            return this
        },
        addInheritableStatics: function(f) {
            var i, e, h = this.prototype,
            g, j;
            i = h.$inheritableStatics;
            e = h.$hasInheritableStatics;
            if (!i) {
                i = h.$inheritableStatics = [];
                e = h.$hasInheritableStatics = {}
            }
            for (g in f) {
                if (f.hasOwnProperty(g)) {
                    j = f[g];
                    this[g] = j;
                    if (!e[g]) {
                        e[g] = true;
                        i.push(g)
                    }
                }
            }
            return this
        },
        addMembers: function(e) {
            var g = this.prototype,
            h = [],
            f,
            i;
            for (f in e) {
                if (e.hasOwnProperty(f)) {
                    i = e[f];
                    if (typeof i == "function" && !i.$isClass && i !== Ext.emptyFn) {
                        i.$owner = this;
                        i.$name = f
                    }
                    g[f] = i
                }
            }
            return this
        },
        addMember: function(e, f) {
            if (typeof f == "function" && !f.$isClass && f !== Ext.emptyFn) {
                f.$owner = this;
                f.$name = e
            }
            this.prototype[e] = f;
            return this
        },
        implement: function() {
            this.addMembers.apply(this, arguments)
        },
        borrow: function(j, g) {
            var o = this.prototype,
            n = j.prototype,
            h, k, f, m, e;
            g = Ext.Array.from(g);
            for (h = 0, k = g.length; h < k; h++) {
                f = g[h];
                e = n[f];
                if (typeof e == "function") {
                    m = function() {
                        return e.apply(this, arguments)
                    };
                    m.$owner = this;
                    m.$name = f;
                    o[f] = m
                } else {
                    o[f] = e
                }
            }
            return this
        },
        override: function(h) {
            var q = this,
            s = Ext.enumerables,
            o = q.prototype,
            j = Ext.Function.clone,
            m = o.config,
            f, n, i, r, p, k, g, e;
            if (arguments.length === 2) {
                f = h;
                h = {};
                h[f] = arguments[1];
                s = null
            }
            do {
                p = [];
                r = null;
                for (f in h) {
                    if (f == "statics") {
                        r = h[f]
                    } else {
                        if (f == "config") {
                            g = h[f];
                            q.addConfig(g, true)
                        } else {
                            p.push(f)
                        }
                    }
                }
                if (s) {
                    p.push.apply(p, s)
                }
                for (n = p.length; n--;) {
                    f = p[n];
                    if (h.hasOwnProperty(f)) {
                        i = h[f];
                        if (typeof i == "function" && !i.$className && i !== Ext.emptyFn) {
                            if (typeof i.$owner != "undefined") {
                                i = j(i)
                            }
                            i.$owner = q;
                            i.$name = f;
                            k = o[f];
                            if (k) {
                                i.$previous = k
                            }
                        }
                        o[f] = i
                    }
                }
                o = q;
                h = r
            } while ( h );
            return this
        },
        callParent: function(e) {
            var f;
            return (f = this.callParent.caller) && (f.$previous || ((f = f.$owner ? f: f.caller) && f.$owner.superclass.$class[f.$name])).apply(this, e || d)
        },
        mixin: function(g, i) {
            var e = i.prototype,
            f = this.prototype,
            h;
            if (typeof e.onClassMixedIn != "undefined") {
                e.onClassMixedIn.call(i, this)
            }
            if (!f.hasOwnProperty("mixins")) {
                if ("mixins" in f) {
                    f.mixins = Ext.Object.chain(f.mixins)
                } else {
                    f.mixins = {}
                }
            }
            for (h in e) {
                if (h === "mixins") {
                    Ext.merge(f.mixins, e[h])
                } else {
                    if (typeof f[h] == "undefined" && h != "mixinId" && h != "config") {
                        f[h] = e[h]
                    }
                }
            }
            if ("config" in e) {
                this.addConfig(e.config, false)
            }
            f.mixins[g] = e
        },
        getName: function() {
            return Ext.getClassName(this)
        },
        createAlias: a(function(f, e) {
            this.override(f,
            function() {
                return this[e].apply(this, arguments)
            })
        }),
        addXtype: function(i) {
            var f = this.prototype,
            h = f.xtypesMap,
            g = f.xtypes,
            e = f.xtypesChain;
            if (!f.hasOwnProperty("xtypesMap")) {
                h = f.xtypesMap = Ext.merge({},
                f.xtypesMap || {});
                g = f.xtypes = f.xtypes ? [].concat(f.xtypes) : [];
                e = f.xtypesChain = f.xtypesChain ? [].concat(f.xtypesChain) : [];
                f.xtype = i
            }
            if (!h[i]) {
                h[i] = true;
                g.push(i);
                e.push(i);
                Ext.ClassManager.setAlias(this, "widget." + i)
            }
            return this
        }
    });
    b.implement({
        isInstance: true,
        $className: "Ext.Base",
        configClass: Ext.emptyFn,
        initConfigList: [],
        initConfigMap: {},
        statics: function() {
            var f = this.statics.caller,
            e = this.self;
            if (!f) {
                return e
            }
            return f.$owner
        },
        callParent: function(f) {
            var g, e = (g = this.callParent.caller) && (g.$previous || ((g = g.$owner ? g: g.caller) && g.$owner.superclass[g.$name]));
            return e.apply(this, f || d)
        },
        callSuper: function(f) {
            var g, e = (g = this.callSuper.caller) && ((g = g.$owner ? g: g.caller) && g.$owner.superclass[g.$name]);
            return e.apply(this, f || d)
        },
        callOverridden: function(e) {
            var f = this.callOverridden.caller;
            return f && f.$previous.apply(this, e || d)
        },
        self: b,
        constructor: function() {
            return this
        },
        wasInstantiated: false,
        initConfig: function(o) {
            var n = Ext.Class.configNameCache,
            r = this.self.prototype,
            j = this.initConfigList,
            g = this.initConfigMap,
            h = new this.configClass,
            k = this.defaultConfig,
            m, q, f, s, p, e;
            this.initConfig = Ext.emptyFn;
            this.initialConfig = o || {};
            if (o) {
                Ext.merge(h, o)
            }
            this.config = h;
            if (!r.hasOwnProperty("wasInstantiated")) {
                r.wasInstantiated = true;
                for (m = 0, q = j.length; m < q; m++) {
                    f = j[m];
                    p = n[f];
                    s = k[f];
                    if (! (p.apply in r) && !(p.update in r) && r[p.set].$isDefault && typeof s != "object") {
                        r[p.internal] = k[f];
                        g[f] = false;
                        Ext.Array.remove(j, f);
                        m--;
                        q--
                    }
                }
            }
            if (o) {
                j = j.slice();
                for (f in o) {
                    if (f in k && !g[f]) {
                        j.push(f)
                    }
                }
            }
            for (m = 0, q = j.length; m < q; m++) {
                f = j[m];
                p = n[f];
                this[p.get] = this[p.initGet]
            }
            this.beforeInitConfig(h);
            for (m = 0, q = j.length; m < q; m++) {
                f = j[m];
                p = n[f];
                e = p.get;
                if (this.hasOwnProperty(e)) {
                    this[p.set].call(this, h[f]);
                    delete this[e]
                }
            }
            return this
        },
        beforeInitConfig: Ext.emptyFn,
        getCurrentConfig: function() {
            var e = this.defaultConfig,
            h = Ext.Class.configNameCache,
            g = {},
            f, i;
            for (f in e) {
                i = h[f];
                g[f] = this[i.get].call(this)
            }
            return g
        },
        setConfig: function(f, n) {
            if (!f) {
                return this
            }
            var j = Ext.Class.configNameCache,
            k = this.config,
            g = this.defaultConfig,
            q = this.initialConfig,
            m = [],
            e,
            h,
            p,
            o;
            n = Boolean(n);
            for (e in f) {
                if ((n && (e in q))) {
                    continue
                }
                k[e] = f[e];
                if (e in g) {
                    m.push(e);
                    o = j[e];
                    this[o.get] = this[o.initGet]
                }
            }
            for (h = 0, p = m.length; h < p; h++) {
                e = m[h];
                o = j[e];
                this[o.set].call(this, f[e]);
                delete this[o.get]
            }
            return this
        },
        set: function(e, f) {
            return this[Ext.Class.configNameCache[e].set].call(this, f)
        },
        get: function(e) {
            return this[Ext.Class.configNameCache[e].get].call(this)
        },
        getConfig: function(e) {
            return this[Ext.Class.configNameCache[e].get].call(this)
        },
        hasConfig: function(e) {
            return (e in this.defaultConfig)
        },
        getInitialConfig: function(f) {
            var e = this.config;
            if (!f) {
                return e
            } else {
                return e[f]
            }
        },
        onConfigUpdate: function(k, n, o) {
            var p = this.self,
            g, j, e, h, m, f;
            k = Ext.Array.from(k);
            o = o || this;
            for (g = 0, j = k.length; g < j; g++) {
                e = k[g];
                h = "update" + Ext.String.capitalize(e);
                m = this[h] || Ext.emptyFn;
                f = function() {
                    m.apply(this, arguments);
                    o[n].apply(o, arguments)
                };
                f.$name = h;
                f.$owner = p;
                this[h] = f
            }
        },
        link: function(e, f) {
            this.$links = {};
            this.link = this.doLink;
            return this.link.apply(this, arguments)
        },
        doLink: function(e, f) {
            this.$links[e] = true;
            this[e] = f;
            return f
        },
        unlink: function() {
            var e, g, f, h;
            for (e = 0, g = arguments.length; e < g; e++) {
                f = arguments[e];
                if (this.hasOwnProperty(f)) {
                    h = this[f];
                    if (h) {
                        if (h.isInstance && !h.isDestroyed) {
                            h.destroy()
                        } else {
                            if (h.parentNode && "nodeType" in h) {
                                h.parentNode.removeChild(h)
                            }
                        }
                    }
                    delete this[f]
                }
            }
            return this
        },
        destroy: function() {
            this.destroy = Ext.emptyFn;
            this.isDestroyed = true;
            if (this.hasOwnProperty("$links")) {
                this.unlink.apply(this, Ext.Object.getKeys(this.$links));
                delete this.$links
            }
        }
    });
    Ext.Base = b
})(Ext.Function.flexSetter); (function() {
    var b, a = Ext.Base,
    f = [],
    e,
    d;
    for (e in a) {
        if (a.hasOwnProperty(e)) {
            f.push(e)
        }
    }
    d = f.length;
    Ext.Class = b = function(h, i, g) {
        if (typeof h != "function") {
            g = i;
            i = h;
            h = null
        }
        if (!i) {
            i = {}
        }
        h = b.create(h);
        b.process(h, i, g);
        return h
    };
    Ext.apply(b, {
        onBeforeCreated: function(h, i, g) {
            h.addMembers(i);
            g.onCreated.call(h, h)
        },
        create: function(g) {
            var h, j;
            if (!g) {
                g = function() {
                    return this.constructor.apply(this, arguments)
                }
            }
            for (j = 0; j < d; j++) {
                h = f[j];
                g[h] = a[h]
            }
            return g
        },
        process: function(h, o, m) {
            var k = o.preprocessors || b.defaultPreprocessors,
            s = this.preprocessors,
            v = {
                onBeforeCreated: this.onBeforeCreated,
                onCreated: m || Ext.emptyFn
            },
            p = 0,
            g,
            y,
            r,
            n,
            q,
            t,
            u,
            j;
            delete o.preprocessors;
            j = function(z, A, i) {
                t = null;
                while (t === null) {
                    g = k[p++];
                    if (g) {
                        y = s[g];
                        r = y.properties;
                        if (r === true) {
                            t = y.fn
                        } else {
                            for (n = 0, q = r.length; n < q; n++) {
                                u = r[n];
                                if (A.hasOwnProperty(u)) {
                                    t = y.fn;
                                    break
                                }
                            }
                        }
                    } else {
                        i.onBeforeCreated.apply(this, arguments);
                        return
                    }
                }
                if (t.call(this, z, A, i, j) !== false) {
                    j.apply(this, arguments)
                }
            };
            j.call(this, h, o, v)
        },
        preprocessors: {},
        registerPreprocessor: function(h, k, i, g, j) {
            if (!g) {
                g = "last"
            }
            if (!i) {
                i = [h]
            }
            this.preprocessors[h] = {
                name: h,
                properties: i || false,
                fn: k
            };
            this.setDefaultPreprocessorPosition(h, g, j);
            return this
        },
        getPreprocessor: function(g) {
            return this.preprocessors[g]
        },
        getPreprocessors: function() {
            return this.preprocessors
        },
        defaultPreprocessors: [],
        getDefaultPreprocessors: function() {
            return this.defaultPreprocessors
        },
        setDefaultPreprocessors: function(g) {
            this.defaultPreprocessors = Ext.Array.from(g);
            return this
        },
        setDefaultPreprocessorPosition: function(i, k, j) {
            var g = this.defaultPreprocessors,
            h;
            if (typeof k == "string") {
                if (k === "first") {
                    g.unshift(i);
                    return this
                } else {
                    if (k === "last") {
                        g.push(i);
                        return this
                    }
                }
                k = (k === "after") ? 1 : -1
            }
            h = Ext.Array.indexOf(g, j);
            if (h !== -1) {
                Ext.Array.splice(g, Math.max(0, h + k), 0, i)
            }
            return this
        },
        configNameCache: {},
        getConfigNameMap: function(i) {
            var h = this.configNameCache,
            j = h[i],
            g;
            if (!j) {
                g = i.charAt(0).toUpperCase() + i.substr(1);
                j = h[i] = {
                    name: i,
                    internal: "_" + i,
                    initializing: "is" + g + "Initializing",
                    apply: "apply" + g,
                    update: "update" + g,
                    set: "set" + g,
                    get: "get" + g,
                    initGet: "initGet" + g,
                    doSet: "doSet" + g,
                    changeEvent: i.toLowerCase() + "change"
                }
            }
            return j
        },
        generateSetter: function(j) {
            var h = j.internal,
            i = j.get,
            g = j.apply,
            m = j.update,
            k;
            k = function(p) {
                var o = this[h],
                n = this[g],
                q = this[m];
                delete this[i];
                if (n) {
                    p = n.call(this, p, o);
                    if (typeof p == "undefined") {
                        return this
                    }
                }
                this[h] = p;
                if (q && p !== o) {
                    q.call(this, p, o)
                }
                return this
            };
            k.$isDefault = true;
            return k
        },
        generateInitGetter: function(k) {
            var g = k.name,
            j = k.set,
            h = k.get,
            i = k.initializing;
            return function() {
                this[i] = true;
                delete this[h];
                this[j].call(this, this.config[g]);
                delete this[i];
                return this[h].apply(this, arguments)
            }
        },
        generateGetter: function(h) {
            var g = h.internal;
            return function() {
                return this[g]
            }
        }
    });
    b.registerPreprocessor("extend",
    function(g, j) {
        var i = Ext.Base,
        k = j.extend,
        h;
        delete j.extend;
        if (k && k !== Object) {
            h = k
        } else {
            h = i
        }
        g.extend(h);
        g.triggerExtended.apply(g, arguments);
        if (j.onClassExtended) {
            g.onExtended(j.onClassExtended, g);
            delete j.onClassExtended
        }
    },
    true);
    b.registerPreprocessor("statics",
    function(g, h) {
        g.addStatics(h.statics);
        delete h.statics
    });
    b.registerPreprocessor("inheritableStatics",
    function(g, h) {
        g.addInheritableStatics(h.inheritableStatics);
        delete h.inheritableStatics
    });
    b.registerPreprocessor("platformConfig",
    function(k, s, v) {
        var t = s.platformConfig,
        o = s.config || {},
        n, r, h, q, u, p, g, m;
        delete s.platformConfig;
        if (!Ext.filterPlatform) {
            Ext.filterPlatform = function(B) {
                var K = false,
                z = navigator.userAgent,
                D, H;
                B = [].concat(B);
                function G(j) {
                    var i = /Mobile(\/|\s)/.test(j);
                    return /(iPhone|iPod)/.test(j) || (!/(Silk)/.test(j) && (/(Android)/.test(j) && (/(Android 2)/.test(j) || i))) || (/(BlackBerry|BB)/.test(j) && i) || /(Windows Phone)/.test(j)
                }
                function F(i) {
                    return ! G(i) && (/iPad/.test(i) || /Android/.test(i) || /(RIM Tablet OS)/.test(i) || (/MSIE 10/.test(i) && /; Touch/.test(i)))
                }
                var y = window.location.search.substr(1),
                A = y.split("&"),
                C = {},
                I,
                E;
                for (E = 0; E < A.length; E++) {
                    var J = A[E].split("=");
                    C[J[0]] = J[1]
                }
                I = C.platform;
                if (I) {
                    return B.indexOf(I) != -1
                }
                for (D = 0, H = B.length; D < H; D++) {
                    switch (B[D]) {
                    case "phone":
                        K = G(z);
                        break;
                    case "tablet":
                        K = F(z);
                        break;
                    case "desktop":
                        K = !G(z) && !F(z);
                        break;
                    case "ios":
                        K = /(iPad|iPhone|iPod)/.test(z);
                        break;
                    case "android":
                        K = /(Android|Silk)/.test(z);
                        break;
                    case "blackberry":
                        K = /(BlackBerry|BB)/.test(z);
                        break;
                    case "safari":
                        K = /Safari/.test(z) && !(/(BlackBerry|BB)/.test(z));
                        break;
                    case "chrome":
                        K = /Chrome/.test(z);
                        break;
                    case "ie10":
                        K = /MSIE 10/.test(z);
                        break;
                    case "windows":
                        K = /MSIE 10/.test(z) || /Trident/.test(z);
                        break;
                    case "tizen":
                        K = /Tizen/.test(z);
                        break;
                    case "firefox":
                        K = /Firefox/.test(z)
                    }
                    if (K) {
                        return true
                    }
                }
                return false
            }
        }
        for (q = 0, u = t.length; q < u; q++) {
            h = t[q];
            n = h.platform;
            m = h.exclude || [];
            delete h.platform;
            r = [].concat(h.theme);
            g = r.length;
            delete h.theme;
            if (n && Ext.filterPlatform(n) && !Ext.filterPlatform(m)) {
                Ext.merge(o, h)
            }
            if (g) {
                for (p = 0; p < g; p++) {
                    if (Ext.theme.name == r[p]) {
                        Ext.merge(o, h)
                    }
                }
            }
        }
    });
    b.registerPreprocessor("config",
    function(i, o) {
        var k = o.config,
        r = i.prototype,
        n = r.config,
        q, h, p, g, j, m, s;
        delete o.config;
        for (h in k) {
            if (k.hasOwnProperty(h) && !(h in n)) {
                s = k[h];
                q = this.getConfigNameMap(h);
                p = q.set;
                g = q.get;
                j = q.initGet;
                m = q.internal;
                o[j] = this.generateInitGetter(q);
                if (s === null && !o.hasOwnProperty(m)) {
                    o[m] = null
                }
                if (!o.hasOwnProperty(g)) {
                    o[g] = this.generateGetter(q)
                }
                if (!o.hasOwnProperty(p)) {
                    o[p] = this.generateSetter(q)
                }
            }
        }
        i.addConfig(k, true)
    });
    b.registerPreprocessor("mixins",
    function(k, p, g) {
        var h = p.mixins,
        m, j, n, o;
        delete p.mixins;
        Ext.Function.interceptBefore(g, "onCreated",
        function() {
            if (h instanceof Array) {
                for (n = 0, o = h.length; n < o; n++) {
                    j = h[n];
                    m = j.prototype.mixinId || j.$className;
                    k.mixin(m, j)
                }
            } else {
                for (m in h) {
                    if (h.hasOwnProperty(m)) {
                        k.mixin(m, h[m])
                    }
                }
            }
        })
    });
    Ext.extend = function(i, j, h) {
        if (arguments.length === 2 && Ext.isObject(j)) {
            h = j;
            j = i;
            i = null
        }
        var g;
        if (!j) {
            throw new Error("[Ext.extend] Attempting to extend from a class which has not been loaded on the page.")
        }
        h.extend = j;
        h.preprocessors = ["extend", "statics", "inheritableStatics", "mixins", "platformConfig", "config"];
        if (i) {
            g = new b(i, h)
        } else {
            g = new b(h)
        }
        g.prototype.override = function(n) {
            for (var k in n) {
                if (n.hasOwnProperty(k)) {
                    this[k] = n[k]
                }
            }
        };
        return g
    }
})(); (function(b, e, g, d, f) {
    var a = Ext.ClassManager = {
        classes: {},
        existCache: {},
        namespaceRewrites: [{
            from: "Ext.",
            to: Ext
        }],
        maps: {
            alternateToName: {},
            aliasToName: {},
            nameToAliases: {},
            nameToAlternates: {}
        },
        enableNamespaceParseCache: true,
        namespaceParseCache: {},
        instantiators: [],
        isCreated: function(n) {
            var m = this.existCache,
            k, o, j, h, p;
            if (this.classes[n] || m[n]) {
                return true
            }
            h = f;
            p = this.parseNamespace(n);
            for (k = 0, o = p.length; k < o; k++) {
                j = p[k];
                if (typeof j != "string") {
                    h = j
                } else {
                    if (!h || !h[j]) {
                        return false
                    }
                    h = h[j]
                }
            }
            m[n] = true;
            this.triggerCreated(n);
            return true
        },
        createdListeners: [],
        nameCreatedListeners: {},
        triggerCreated: function(s) {
            var u = this.createdListeners,
            m = this.nameCreatedListeners,
            n = this.maps.nameToAlternates[s],
            t = [s],
            p,
            r,
            o,
            q,
            k,
            h;
            for (p = 0, r = u.length; p < r; p++) {
                k = u[p];
                k.fn.call(k.scope, s)
            }
            if (n) {
                t.push.apply(t, n)
            }
            for (p = 0, r = t.length; p < r; p++) {
                h = t[p];
                u = m[h];
                if (u) {
                    for (o = 0, q = u.length; o < q; o++) {
                        k = u[o];
                        k.fn.call(k.scope, h)
                    }
                    delete m[h]
                }
            }
        },
        onCreated: function(m, k, j) {
            var i = this.createdListeners,
            h = this.nameCreatedListeners,
            n = {
                fn: m,
                scope: k
            };
            if (j) {
                if (this.isCreated(j)) {
                    m.call(k, j);
                    return
                }
                if (!h[j]) {
                    h[j] = []
                }
                h[j].push(n)
            } else {
                i.push(n)
            }
        },
        parseNamespace: function(k) {
            var h = this.namespaceParseCache;
            if (this.enableNamespaceParseCache) {
                if (h.hasOwnProperty(k)) {
                    return h[k]
                }
            }
            var m = [],
            o = this.namespaceRewrites,
            q = f,
            j = k,
            t,
            s,
            r,
            n,
            p;
            for (n = 0, p = o.length; n < p; n++) {
                t = o[n];
                s = t.from;
                r = t.to;
                if (j === s || j.substring(0, s.length) === s) {
                    j = j.substring(s.length);
                    if (typeof r != "string") {
                        q = r
                    } else {
                        m = m.concat(r.split("."))
                    }
                    break
                }
            }
            m.push(q);
            m = m.concat(j.split("."));
            if (this.enableNamespaceParseCache) {
                h[k] = m
            }
            return m
        },
        setNamespace: function(m, p) {
            var j = f,
            q = this.parseNamespace(m),
            o = q.length - 1,
            h = q[o],
            n,
            k;
            for (n = 0; n < o; n++) {
                k = q[n];
                if (typeof k != "string") {
                    j = k
                } else {
                    if (!j[k]) {
                        j[k] = {}
                    }
                    j = j[k]
                }
            }
            j[h] = p;
            return j[h]
        },
        createNamespaces: function() {
            var h = f,
            p, m, n, k, o, q;
            for (n = 0, o = arguments.length; n < o; n++) {
                p = this.parseNamespace(arguments[n]);
                for (k = 0, q = p.length; k < q; k++) {
                    m = p[k];
                    if (typeof m != "string") {
                        h = m
                    } else {
                        if (!h[m]) {
                            h[m] = {}
                        }
                        h = h[m]
                    }
                }
            }
            return h
        },
        set: function(h, m) {
            var k = this,
            o = k.maps,
            n = o.nameToAlternates,
            j = k.getName(m),
            i;
            k.classes[h] = k.setNamespace(h, m);
            if (j && j !== h) {
                o.alternateToName[h] = j;
                i = n[j] || (n[j] = []);
                i.push(h)
            }
            return this
        },
        get: function(k) {
            var n = this.classes;
            if (n[k]) {
                return n[k]
            }
            var h = f,
            p = this.parseNamespace(k),
            j,
            m,
            o;
            for (m = 0, o = p.length; m < o; m++) {
                j = p[m];
                if (typeof j != "string") {
                    h = j
                } else {
                    if (!h || !h[j]) {
                        return null
                    }
                    h = h[j]
                }
            }
            return h
        },
        setAlias: function(h, i) {
            var k = this.maps.aliasToName,
            m = this.maps.nameToAliases,
            j;
            if (typeof h == "string") {
                j = h
            } else {
                j = this.getName(h)
            }
            if (i && k[i] !== j) {
                k[i] = j
            }
            if (!m[j]) {
                m[j] = []
            }
            if (i) {
                Ext.Array.include(m[j], i)
            }
            return this
        },
        addNameAliasMappings: function(h) {
            var o = this.maps.aliasToName,
            p = this.maps.nameToAliases,
            m, n, k, j;
            for (m in h) {
                n = p[m] || (p[m] = []);
                for (j = 0; j < h[m].length; j++) {
                    k = h[m][j];
                    if (!o[k]) {
                        o[k] = m;
                        n.push(k)
                    }
                }
            }
            return this
        },
        addNameAlternateMappings: function(m) {
            var h = this.maps.alternateToName,
            p = this.maps.nameToAlternates,
            k, n, o, j;
            for (k in m) {
                n = p[k] || (p[k] = []);
                for (j = 0; j < m[k].length; j++) {
                    o = m[k];
                    if (!h[o]) {
                        h[o] = k;
                        n.push(o)
                    }
                }
            }
            return this
        },
        getByAlias: function(h) {
            return this.get(this.getNameByAlias(h))
        },
        getNameByAlias: function(h) {
            return this.maps.aliasToName[h] || ""
        },
        getNameByAlternate: function(h) {
            return this.maps.alternateToName[h] || ""
        },
        getAliasesByName: function(h) {
            return this.maps.nameToAliases[h] || []
        },
        getName: function(h) {
            return h && h.$className || ""
        },
        getClass: function(h) {
            return h && h.self || null
        },
        create: function(i, j, h) {
            j.$className = i;
            return new b(j,
            function() {
                var n = j.postprocessors || a.defaultPostprocessors,
                u = a.postprocessors,
                r = 0,
                v = [],
                t,
                k,
                o,
                s,
                m,
                q,
                p,
                y;
                delete j.postprocessors;
                for (o = 0, s = n.length; o < s; o++) {
                    t = n[o];
                    if (typeof t == "string") {
                        t = u[t];
                        p = t.properties;
                        if (p === true) {
                            v.push(t.fn)
                        } else {
                            if (p) {
                                for (m = 0, q = p.length; m < q; m++) {
                                    y = p[m];
                                    if (j.hasOwnProperty(y)) {
                                        v.push(t.fn);
                                        break
                                    }
                                }
                            }
                        }
                    } else {
                        v.push(t)
                    }
                }
                k = function(A, z, B) {
                    t = v[r++];
                    if (!t) {
                        a.set(i, z);
                        if (h) {
                            h.call(z, z)
                        }
                        a.triggerCreated(i);
                        return
                    }
                    if (t.call(this, A, z, B, k) !== false) {
                        k.apply(this, arguments)
                    }
                };
                k.call(a, i, this, j)
            })
        },
        createOverride: function(j, m, h) {
            var k = m.override,
            i = Ext.Array.from(m.requires);
            delete m.override;
            delete m.requires;
            this.existCache[j] = true;
            Ext.require(i,
            function() {
                this.onCreated(function() {
                    var n = this.get(k);
                    if (n.singleton) {
                        n.self.override(m)
                    } else {
                        n.override(m)
                    }
                    if (h) {
                        h.call(n, n)
                    }
                    this.triggerCreated(j)
                },
                this, k)
            },
            this);
            return this
        },
        instantiateByAlias: function() {
            var i = arguments[0],
            h = g.call(arguments),
            j = this.getNameByAlias(i);
            if (!j) {
                j = this.maps.aliasToName[i];
                Ext.syncRequire(j)
            }
            h[0] = j;
            return this.instantiate.apply(this, h)
        },
        instantiate: function() {
            var j = arguments[0],
            i = g.call(arguments, 1),
            k = j,
            m,
            h;
            if (typeof j != "function") {
                h = this.get(j)
            } else {
                h = j
            }
            if (!h) {
                m = this.getNameByAlias(j);
                if (m) {
                    j = m;
                    h = this.get(j)
                }
            }
            if (!h) {
                m = this.getNameByAlternate(j);
                if (m) {
                    j = m;
                    h = this.get(j)
                }
            }
            if (!h) {
                Ext.syncRequire(j);
                h = this.get(j)
            }
            return this.getInstantiator(i.length)(h, i)
        },
        dynInstantiate: function(i, h) {
            h = d(h, true);
            h.unshift(i);
            return this.instantiate.apply(this, h)
        },
        getInstantiator: function(m) {
            var k = this.instantiators,
            n;
            n = k[m];
            if (!n) {
                var j = m,
                h = [];
                for (j = 0; j < m; j++) {
                    h.push("a[" + j + "]")
                }
                n = k[m] = new Function("c", "a", "return new c(" + h.join(",") + ")")
            }
            return n
        },
        postprocessors: {},
        defaultPostprocessors: [],
        registerPostprocessor: function(i, m, j, h, k) {
            if (!h) {
                h = "last"
            }
            if (!j) {
                j = [i]
            }
            this.postprocessors[i] = {
                name: i,
                properties: j || false,
                fn: m
            };
            this.setDefaultPostprocessorPosition(i, h, k);
            return this
        },
        setDefaultPostprocessors: function(h) {
            this.defaultPostprocessors = d(h);
            return this
        },
        setDefaultPostprocessorPosition: function(i, m, k) {
            var j = this.defaultPostprocessors,
            h;
            if (typeof m == "string") {
                if (m === "first") {
                    j.unshift(i);
                    return this
                } else {
                    if (m === "last") {
                        j.push(i);
                        return this
                    }
                }
                m = (m === "after") ? 1 : -1
            }
            h = Ext.Array.indexOf(j, k);
            if (h !== -1) {
                Ext.Array.splice(j, Math.max(0, h + m), 0, i)
            }
            return this
        },
        getNamesByExpression: function(q) {
            var o = this.maps.nameToAliases,
            r = [],
            h,
            n,
            k,
            j,
            s,
            m,
            p;
            if (q.indexOf("*") !== -1) {
                q = q.replace(/\*/g, "(.*?)");
                s = new RegExp("^" + q + "$");
                for (h in o) {
                    if (o.hasOwnProperty(h)) {
                        k = o[h];
                        if (h.search(s) !== -1) {
                            r.push(h)
                        } else {
                            for (m = 0, p = k.length; m < p; m++) {
                                n = k[m];
                                if (n.search(s) !== -1) {
                                    r.push(h);
                                    break
                                }
                            }
                        }
                    }
                }
            } else {
                j = this.getNameByAlias(q);
                if (j) {
                    r.push(j)
                } else {
                    j = this.getNameByAlternate(q);
                    if (j) {
                        r.push(j)
                    } else {
                        r.push(q)
                    }
                }
            }
            return r
        }
    };
    a.registerPostprocessor("alias",
    function(k, j, o) {
        var h = o.alias,
        m, n;
        for (m = 0, n = h.length; m < n; m++) {
            e = h[m];
            this.setAlias(j, e)
        }
    },
    ["xtype", "alias"]);
    a.registerPostprocessor("singleton",
    function(i, h, k, j) {
        j.call(this, i, new h(), k);
        return false
    });
    a.registerPostprocessor("alternateClassName",
    function(j, h, o) {
        var m = o.alternateClassName,
        k, n, p;
        if (! (m instanceof Array)) {
            m = [m]
        }
        for (k = 0, n = m.length; k < n; k++) {
            p = m[k];
            this.set(p, h)
        }
    });
    Ext.apply(Ext, {
        create: e(a, "instantiate"),
        widget: function(i) {
            var h = g.call(arguments);
            h[0] = "widget." + i;
            return a.instantiateByAlias.apply(a, h)
        },
        createByAlias: e(a, "instantiateByAlias"),
        define: function(i, j, h) {
            if ("override" in j) {
                return a.createOverride.apply(a, arguments)
            }
            return a.create.apply(a, arguments)
        },
        getClassName: e(a, "getName"),
        getDisplayName: function(h) {
            if (h) {
                if (h.displayName) {
                    return h.displayName
                }
                if (h.$name && h.$class) {
                    return Ext.getClassName(h.$class) + "#" + h.$name
                }
                if (h.$className) {
                    return h.$className
                }
            }
            return "Anonymous"
        },
        getClass: e(a, "getClass"),
        namespace: e(a, "createNamespaces")
    });
    Ext.createWidget = Ext.widget;
    Ext.ns = Ext.namespace;
    b.registerPreprocessor("className",
    function(h, i) {
        if (i.$className) {
            h.$className = i.$className
        }
    },
    true, "first");
    b.registerPreprocessor("alias",
    function(u, o) {
        var s = u.prototype,
        k = d(o.xtype),
        h = d(o.alias),
        v = "widget.",
        t = v.length,
        p = Array.prototype.slice.call(s.xtypesChain || []),
        m = Ext.merge({},
        s.xtypesMap || {}),
        n,
        r,
        q,
        j;
        for (n = 0, r = h.length; n < r; n++) {
            q = h[n];
            if (q.substring(0, t) === v) {
                j = q.substring(t);
                Ext.Array.include(k, j)
            }
        }
        u.xtype = o.xtype = k[0];
        o.xtypes = k;
        for (n = 0, r = k.length; n < r; n++) {
            j = k[n];
            if (!m[j]) {
                m[j] = true;
                p.push(j)
            }
        }
        o.xtypesChain = p;
        o.xtypesMap = m;
        Ext.Function.interceptAfter(o, "onClassCreated",
        function() {
            var i = s.mixins,
            z, y;
            for (z in i) {
                if (i.hasOwnProperty(z)) {
                    y = i[z];
                    k = y.xtypes;
                    if (k) {
                        for (n = 0, r = k.length; n < r; n++) {
                            j = k[n];
                            if (!m[j]) {
                                m[j] = true;
                                p.push(j)
                            }
                        }
                    }
                }
            }
        });
        for (n = 0, r = k.length; n < r; n++) {
            j = k[n];
            Ext.Array.include(h, v + j)
        }
        o.alias = h
    },
    ["xtype", "alias"])
})(Ext.Class, Ext.Function.alias, Array.prototype.slice, Ext.Array.from, Ext.global); (function(a, d, e, i, k, j, h, m) {
    var f = ["extend", "mixins", "requires"],
    b,
    g = 0;
    b = Ext.Loader = {
        isInHistory: {},
        history: [],
        config: {
            enabled: true,
            disableCaching: true,
            disableCachingParam: "_dc",
            paths: {
                Ext: "."
            }
        },
        setConfig: function(n, o) {
            if (Ext.isObject(n) && arguments.length === 1) {
                Ext.merge(this.config, n)
            } else {
                this.config[n] = (Ext.isObject(o)) ? Ext.merge(this.config[n], o) : o
            }
            g += 1;
            return this
        },
        getConfig: function(n) {
            if (n) {
                return this.config[n]
            }
            return this.config
        },
        setPath: e(function(n, o) {
            this.config.paths[n] = o;
            g += 1;
            return this
        }),
        addClassPathMappings: function(o) {
            var n;
            if (g == 0) {
                b.config.paths = o
            } else {
                for (n in o) {
                    b.config.paths[n] = o[n]
                }
            }
            g++;
            return b
        },
        getPath: function(n) {
            var p = "",
            q = this.config.paths,
            o = this.getPrefix(n);
            if (o.length > 0) {
                if (o === n) {
                    return q[o]
                }
                p = q[o];
                n = n.substring(o.length + 1)
            }
            if (p.length > 0) {
                p += "/"
            }
            return p.replace(/\/\.\//g, "/") + n.replace(/\./g, "/") + ".js"
        },
        getPrefix: function(o) {
            var q = this.config.paths,
            p, n = "";
            if (q.hasOwnProperty(o)) {
                return o
            }
            for (p in q) {
                if (q.hasOwnProperty(p) && p + "." === o.substring(0, p.length + 1)) {
                    if (p.length > n.length) {
                        n = p
                    }
                }
            }
            return n
        },
        require: function(p, o, n, q) {
            if (o) {
                o.call(n)
            }
        },
        syncRequire: function() {},
        exclude: function(o) {
            var n = this;
            return {
                require: function(r, q, p) {
                    return n.require(r, q, p, o)
                },
                syncRequire: function(r, q, p) {
                    return n.syncRequire(r, q, p, o)
                }
            }
        },
        onReady: function(q, p, r, n) {
            var o;
            if (r !== false && Ext.onDocumentReady) {
                o = q;
                q = function() {
                    Ext.onDocumentReady(o, p, n)
                }
            }
            q.call(p)
        }
    };
    Ext.apply(b, {
        documentHead: typeof document != "undefined" && (document.head || document.getElementsByTagName("head")[0]),
        isLoading: false,
        queue: [],
        isClassFileLoaded: {},
        isFileLoaded: {},
        readyListeners: [],
        optionalRequires: [],
        requiresMap: {},
        numPendingFiles: 0,
        numLoadedFiles: 0,
        hasFileLoadError: false,
        classNameToFilePathMap: {},
        syncModeEnabled: false,
        scriptElements: {},
        refreshQueue: function() {
            var n = this.queue,
            t = n.length,
            q, s, o, r, p;
            if (t === 0) {
                this.triggerReady();
                return
            }
            for (q = 0; q < t; q++) {
                s = n[q];
                if (s) {
                    r = s.requires;
                    p = s.references;
                    if (r.length > this.numLoadedFiles) {
                        continue
                    }
                    o = 0;
                    do {
                        if (a.isCreated(r[o])) {
                            h(r, o, 1)
                        } else {
                            o++
                        }
                    } while ( o < r . length );
                    if (s.requires.length === 0) {
                        h(n, q, 1);
                        s.callback.call(s.scope);
                        this.refreshQueue();
                        break
                    }
                }
            }
            return this
        },
        injectScriptElement: function(n, t, q, v, o) {
            var u = document.createElement("script"),
            s = this,
            r = function() {
                s.cleanupScriptElement(u);
                t.call(v)
            },
            p = function() {
                s.cleanupScriptElement(u);
                q.call(v)
            };
            u.type = "text/javascript";
            u.src = n;
            u.onload = r;
            u.onerror = p;
            u.onreadystatechange = function() {
                if (this.readyState === "loaded" || this.readyState === "complete") {
                    r()
                }
            };
            if (o) {
                u.charset = o
            }
            this.documentHead.appendChild(u);
            return u
        },
        removeScriptElement: function(o) {
            var n = this.scriptElements;
            if (n[o]) {
                this.cleanupScriptElement(n[o], true);
                delete n[o]
            }
            return this
        },
        cleanupScriptElement: function(o, n) {
            o.onload = null;
            o.onreadystatechange = null;
            o.onerror = null;
            if (n) {
                this.documentHead.removeChild(o)
            }
            return this
        },
        loadScriptFile: function(o, v, r, B, n) {
            var u = this,
            C = this.isFileLoaded,
            p = this.scriptElements,
            A = o + (this.getConfig("disableCaching") ? ("?" + this.getConfig("disableCachingParam") + "=" + Ext.Date.now()) : ""),
            z,
            q,
            t,
            y;
            if (C[o]) {
                return this
            }
            B = B || this;
            this.isLoading = true;
            if (!n) {
                y = function() {};
                if (!Ext.isReady && Ext.onDocumentReady) {
                    Ext.onDocumentReady(function() {
                        if (!C[o]) {
                            p[o] = u.injectScriptElement(A, v, y, B)
                        }
                    })
                } else {
                    p[o] = this.injectScriptElement(A, v, y, B)
                }
            } else {
                if (typeof XMLHttpRequest != "undefined") {
                    z = new XMLHttpRequest()
                } else {
                    z = new ActiveXObject("Microsoft.XMLHTTP")
                }
                try {
                    z.open("GET", A, false);
                    z.send(null)
                } catch(s) {}
                q = (z.status == 1223) ? 204 : z.status;
                t = z.responseText;
                if ((q >= 200 && q < 300) || q == 304 || (q == 0 && t.length > 0)) {
                    Ext.globalEval(t + "\n//@ sourceURL=" + o);
                    v.call(B)
                } else {}
                z = null
            }
        },
        syncRequire: function() {
            var n = this.syncModeEnabled;
            if (!n) {
                this.syncModeEnabled = true
            }
            this.require.apply(this, arguments);
            if (!n) {
                this.syncModeEnabled = false
            }
            this.refreshQueue()
        },
        require: function(K, y, q, t) {
            var A = {},
            p = {},
            D = this.queue,
            H = this.classNameToFilePathMap,
            F = this.isClassFileLoaded,
            v = [],
            M = [],
            J = [],
            o = [],
            u,
            L,
            C,
            B,
            n,
            s,
            I,
            G,
            E,
            z,
            r;
            if (t) {
                t = j(t);
                for (G = 0, z = t.length; G < z; G++) {
                    n = t[G];
                    if (typeof n == "string" && n.length > 0) {
                        v = a.getNamesByExpression(n);
                        for (E = 0, r = v.length; E < r; E++) {
                            A[v[E]] = true
                        }
                    }
                }
            }
            K = j(K);
            if (y) {
                if (y.length > 0) {
                    u = function() {
                        var P = [],
                        O,
                        Q,
                        N;
                        for (O = 0, Q = o.length; O < Q; O++) {
                            N = o[O];
                            P.push(a.get(N))
                        }
                        return y.apply(this, P)
                    }
                } else {
                    u = y
                }
            } else {
                u = Ext.emptyFn
            }
            q = q || Ext.global;
            for (G = 0, z = K.length; G < z; G++) {
                B = K[G];
                if (typeof B == "string" && B.length > 0) {
                    M = a.getNamesByExpression(B);
                    r = M.length;
                    for (E = 0; E < r; E++) {
                        I = M[E];
                        if (A[I] !== true) {
                            o.push(I);
                            if (!a.isCreated(I) && !p[I]) {
                                p[I] = true;
                                J.push(I)
                            }
                        }
                    }
                }
            }
            if (J.length > 0) {
                if (!this.config.enabled) {
                    throw new Error("Ext.Loader is not enabled, so dependencies cannot be resolved dynamically. Missing required class" + ((J.length > 1) ? "es": "") + ": " + J.join(", "))
                }
            } else {
                u.call(q);
                return this
            }
            L = this.syncModeEnabled;
            if (!L) {
                D.push({
                    requires: J.slice(),
                    callback: u,
                    scope: q
                })
            }
            z = J.length;
            for (G = 0; G < z; G++) {
                s = J[G];
                C = this.getPath(s);
                if (L && F.hasOwnProperty(s)) {
                    this.numPendingFiles--;
                    this.removeScriptElement(C);
                    delete F[s]
                }
                if (!F.hasOwnProperty(s)) {
                    F[s] = false;
                    H[s] = C;
                    this.numPendingFiles++;
                    this.loadScriptFile(C, k(this.onFileLoaded, [s, C], this), k(this.onFileLoadError, [s, C]), this, L)
                }
            }
            if (L) {
                u.call(q);
                if (z === 1) {
                    return a.get(s)
                }
            }
            return this
        },
        onFileLoaded: function(o, n) {
            this.numLoadedFiles++;
            this.isClassFileLoaded[o] = true;
            this.isFileLoaded[n] = true;
            this.numPendingFiles--;
            if (this.numPendingFiles === 0) {
                this.refreshQueue()
            }
        },
        onFileLoadError: function(p, o, n, q) {
            this.numPendingFiles--;
            this.hasFileLoadError = true
        },
        addOptionalRequires: function(p) {
            var r = this.optionalRequires,
            o, q, n;
            p = j(p);
            for (o = 0, q = p.length; o < q; o++) {
                n = p[o];
                m(r, n)
            }
            return this
        },
        triggerReady: function(o) {
            var q = this.readyListeners,
            p = this.optionalRequires,
            n;
            if (this.isLoading || o) {
                this.isLoading = false;
                if (p.length !== 0) {
                    p = p.slice();
                    this.optionalRequires.length = 0;
                    this.require(p, k(this.triggerReady, [true], this), this);
                    return this
                }
                while (q.length) {
                    n = q.shift();
                    n.fn.call(n.scope);
                    if (this.isLoading) {
                        return this
                    }
                }
            }
            return this
        },
        onReady: function(q, p, r, n) {
            var o;
            if (r !== false && Ext.onDocumentReady) {
                o = q;
                q = function() {
                    Ext.onDocumentReady(o, p, n)
                }
            }
            if (!this.isLoading) {
                q.call(p)
            } else {
                this.readyListeners.push({
                    fn: q,
                    scope: p
                })
            }
        },
        historyPush: function(o) {
            var n = this.isInHistory;
            if (o && this.isClassFileLoaded.hasOwnProperty(o) && !n[o]) {
                n[o] = true;
                this.history.push(o)
            }
            return this
        }
    });
    Ext.require = i(b, "require");
    Ext.syncRequire = i(b, "syncRequire");
    Ext.exclude = i(b, "exclude");
    Ext.onReady = function(p, o, n) {
        b.onReady(p, o, true, n)
    };
    d.registerPreprocessor("loader",
    function(C, p, B, A) {
        var y = this,
        u = [],
        v = a.getName(C),
        q,
        o,
        t,
        s,
        z,
        r,
        n;
        for (q = 0, t = f.length; q < t; q++) {
            r = f[q];
            if (p.hasOwnProperty(r)) {
                n = p[r];
                if (typeof n == "string") {
                    u.push(n)
                } else {
                    if (n instanceof Array) {
                        for (o = 0, s = n.length; o < s; o++) {
                            z = n[o];
                            if (typeof z == "string") {
                                u.push(z)
                            }
                        }
                    } else {
                        if (typeof n != "function") {
                            for (o in n) {
                                if (n.hasOwnProperty(o)) {
                                    z = n[o];
                                    if (typeof z == "string") {
                                        u.push(z)
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (u.length === 0) {
            return
        }
        b.require(u,
        function() {
            for (q = 0, t = f.length; q < t; q++) {
                r = f[q];
                if (p.hasOwnProperty(r)) {
                    n = p[r];
                    if (typeof n == "string") {
                        p[r] = a.get(n)
                    } else {
                        if (n instanceof Array) {
                            for (o = 0, s = n.length; o < s; o++) {
                                z = n[o];
                                if (typeof z == "string") {
                                    p[r][o] = a.get(z)
                                }
                            }
                        } else {
                            if (typeof n != "function") {
                                for (var D in n) {
                                    if (n.hasOwnProperty(D)) {
                                        z = n[D];
                                        if (typeof z == "string") {
                                            p[r][D] = a.get(z)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            A.call(y, C, p, B)
        });
        return false
    },
    true, "after", "className");
    a.registerPostprocessor("uses",
    function(q, o, u) {
        var n = j(u.uses),
        p = [],
        r,
        t,
        s;
        for (r = 0, t = n.length; r < t; r++) {
            s = n[r];
            if (typeof s == "string") {
                p.push(s)
            }
        }
        b.addOptionalRequires(p)
    });
    a.onCreated(function(n) {
        this.historyPush(n)
    },
    b)
})(Ext.ClassManager, Ext.Class, Ext.Function.flexSetter, Ext.Function.alias, Ext.Function.pass, Ext.Array.from, Ext.Array.erase, Ext.Array.include); (function() {
    var a = document.getElementsByTagName("script"),
    b = a[a.length - 1],
    e = b.src,
    d = e.substring(0, e.lastIndexOf("/") + 1),
    f = Ext.Loader;
    f.setConfig({
        enabled: true,
        disableCaching: !/[?&](cache|breakpoint)/i.test(location.search),
        paths: {
            Ext: d + "src"
        }
    })
})();
Ext.setVersion("touch", "2.3.1.410");
Ext.apply(Ext, {
    version: Ext.getVersion("touch"),
    idSeed: 0,
    repaint: function() {
        var a = Ext.getBody().createChild({
            cls: Ext.baseCSSPrefix + "mask " + Ext.baseCSSPrefix + "mask-transparent"
        });
        setTimeout(function() {
            a.destroy()
        },
        0)
    },
    id: function(a, b) {
        if (a && a.id) {
            return a.id
        }
        a = Ext.getDom(a) || {};
        if (a === document || a === document.documentElement) {
            a.id = "ext-app"
        } else {
            if (a === document.body) {
                a.id = "ext-body"
            } else {
                if (a === window) {
                    a.id = "ext-window"
                }
            }
        }
        a.id = a.id || ((b || "ext-") + (++Ext.idSeed));
        return a.id
    },
    getBody: function() {
        if (!Ext.documentBodyElement) {
            if (!document.body) {
                throw new Error("[Ext.getBody] document.body does not exist at this point")
            }
            Ext.documentBodyElement = Ext.get(document.body)
        }
        return Ext.documentBodyElement
    },
    getHead: function() {
        if (!Ext.documentHeadElement) {
            Ext.documentHeadElement = Ext.get(document.head || document.getElementsByTagName("head")[0])
        }
        return Ext.documentHeadElement
    },
    getDoc: function() {
        if (!Ext.documentElement) {
            Ext.documentElement = Ext.get(document)
        }
        return Ext.documentElement
    },
    getCmp: function(a) {
        return Ext.ComponentMgr.get(a)
    },
    copyTo: function(a, b, e, d) {
        if (typeof e == "string") {
            e = e.split(/[,;\s]/)
        }
        Ext.each(e,
        function(f) {
            if (d || b.hasOwnProperty(f)) {
                a[f] = b[f]
            }
        },
        this);
        return a
    },
    destroy: function() {
        var a = arguments,
        e = a.length,
        b, d;
        for (b = 0; b < e; b++) {
            d = a[b];
            if (d) {
                if (Ext.isArray(d)) {
                    this.destroy.apply(this, d)
                } else {
                    if (Ext.isFunction(d.destroy)) {
                        d.destroy()
                    }
                }
            }
        }
    },
    getDom: function(a) {
        if (!a || !document) {
            return null
        }
        return a.dom ? a.dom: (typeof a == "string" ? document.getElementById(a) : a)
    },
    removeNode: function(a) {
        if (a && a.parentNode && a.tagName != "BODY") {
            Ext.get(a).clearListeners();
            a.parentNode.removeChild(a);
            delete Ext.cache[a.id]
        }
    },
    defaultSetupConfig: {
        eventPublishers: {
            dom: {
                xclass: "Ext.event.publisher.Dom"
            },
            touchGesture: {
                xclass: "Ext.event.publisher.TouchGesture",
                recognizers: {
                    drag: {
                        xclass: "Ext.event.recognizer.Drag"
                    },
                    tap: {
                        xclass: "Ext.event.recognizer.Tap"
                    },
                    doubleTap: {
                        xclass: "Ext.event.recognizer.DoubleTap"
                    },
                    longPress: {
                        xclass: "Ext.event.recognizer.LongPress"
                    },
                    swipe: {
                        xclass: "Ext.event.recognizer.Swipe"
                    },
                    pinch: {
                        xclass: "Ext.event.recognizer.Pinch"
                    },
                    rotate: {
                        xclass: "Ext.event.recognizer.Rotate"
                    },
                    edgeSwipe: {
                        xclass: "Ext.event.recognizer.EdgeSwipe"
                    }
                }
            },
            componentDelegation: {
                xclass: "Ext.event.publisher.ComponentDelegation"
            },
            componentPaint: {
                xclass: "Ext.event.publisher.ComponentPaint"
            },
            elementPaint: {
                xclass: "Ext.event.publisher.ElementPaint"
            },
            elementSize: {
                xclass: "Ext.event.publisher.ElementSize"
            },
            seriesItemEvents: {
                xclass: "Ext.chart.series.ItemPublisher"
            }
        },
        animator: {
            xclass: "Ext.fx.Runner"
        },
        viewport: {
            xclass: "Ext.viewport.Viewport"
        }
    },
    isSetup: false,
    frameStartTime: +new Date(),
    setupListeners: [],
    onSetup: function(b, a) {
        if (Ext.isSetup) {
            b.call(a)
        } else {
            Ext.setupListeners.push({
                fn: b,
                scope: a
            })
        }
    },
    setup: function(u) {
        var m = Ext.defaultSetupConfig,
        o = Ext.emptyFn,
        b = u.onReady || o,
        g = u.onUpdated || o,
        a = u.scope,
        e = Ext.Array.from(u.requires),
        n = Ext.onReady,
        i = Ext.getHead(),
        h,
        s,
        j;
        Ext.setup = function() {
            throw new Error("Ext.setup has already been called before")
        };
        delete u.requires;
        delete u.onReady;
        delete u.onUpdated;
        delete u.scope;
        Ext.require(["Ext.event.Dispatcher"]);
        h = function() {
            var z = Ext.setupListeners,
            A = z.length,
            y, B;
            delete Ext.setupListeners;
            Ext.isSetup = true;
            for (y = 0; y < A; y++) {
                B = z[y];
                B.fn.call(B.scope)
            }
            Ext.onReady = n;
            Ext.onReady(b, a)
        };
        Ext.onUpdated = g;
        Ext.onReady = function(A, z) {
            var y = b;
            b = function() {
                y();
                Ext.onReady(A, z)
            }
        };
        u = Ext.merge({},
        m, u);
        Ext.onDocumentReady(function() {
            Ext.factoryConfig(u,
            function(z) {
                Ext.event.Dispatcher.getInstance().setPublishers(z.eventPublishers);
                if (z.logger) {
                    Ext.Logger = z.logger
                }
                if (z.animator) {
                    Ext.Animator = z.animator
                }
                if (z.viewport) {
                    Ext.Viewport = s = z.viewport;
                    if (!a) {
                        a = s
                    }
                    Ext.require(e,
                    function() {
                        Ext.Viewport.on("ready", h, null, {
                            single: true
                        })
                    })
                } else {
                    Ext.require(e, h)
                }
            });
            if (!Ext.microloaded && navigator.userAgent.match(/IEMobile\/10\.0/)) {
                var y = document.createElement("style");
                y.appendChild(document.createTextNode("@media screen and (orientation: portrait) {@-ms-viewport {width: 320px !important;}}@media screen and (orientation: landscape) {@-ms-viewport {width: 560px !important;}}"));
                i.appendChild(y)
            }
        });
        function k(y, z) {
            var A = document.createElement("meta");
            A.setAttribute("name", y);
            A.setAttribute("content", z);
            i.append(A)
        }
        function p(y, A, B) {
            var z = document.createElement("link");
            z.setAttribute("rel", "apple-touch-icon" + (B ? "-precomposed": ""));
            z.setAttribute("href", y);
            if (A) {
                z.setAttribute("sizes", A)
            }
            i.append(z)
        }
        function f(y, A) {
            var z = document.createElement("link");
            z.setAttribute("rel", "apple-touch-startup-image");
            z.setAttribute("href", y);
            if (A) {
                z.setAttribute("media", A)
            }
            i.append(z)
        }
        var r = u.icon,
        v = Boolean(u.isIconPrecomposed),
        t = u.startupImage || {},
        d = u.statusBarStyle || "black",
        q = window.devicePixelRatio || 1;
        if (navigator.standalone) {
            k("viewport", "width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0")
        } else {
            k("viewport", "initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0")
        }
        k("apple-mobile-web-app-capable", "yes");
        k("apple-touch-fullscreen", "yes");
        if (Ext.browser.is.ie) {
            k("msapplication-tap-highlight", "no")
        }
        if (d) {
            k("apple-mobile-web-app-status-bar-style", d)
        }
        if (Ext.isString(r)) {
            r = {
                57 : r,
                72 : r,
                114 : r,
                144 : r
            }
        } else {
            if (!r) {
                r = {}
            }
        }
        if (Ext.os.is.iPad) {
            if (q >= 2) {
                if ("1496x2048" in t) {
                    f(t["1496x2048"], "(orientation: landscape)")
                }
                if ("1536x2008" in t) {
                    f(t["1536x2008"], "(orientation: portrait)")
                }
                if ("144" in r) {
                    p(r["144"], "144x144", v)
                }
            } else {
                if ("748x1024" in t) {
                    f(t["748x1024"], "(orientation: landscape)")
                }
                if ("768x1004" in t) {
                    f(t["768x1004"], "(orientation: portrait)")
                }
                if ("72" in r) {
                    p(r["72"], "72x72", v)
                }
            }
        } else {
            if (q >= 2 && Ext.os.version.gtEq("4.3")) {
                if (Ext.os.is.iPhone5) {
                    f(t["640x1096"])
                } else {
                    f(t["640x920"])
                }
                if ("114" in r) {
                    p(r["114"], "114x114", v)
                }
            } else {
                f(t["320x460"]);
                if ("57" in r) {
                    p(r["57"], null, v)
                }
            }
        }
    },
    application: function(b) {
        var a = b.name,
        f, e, d;
        if (!b) {
            b = {}
        }
        if (!Ext.Loader.config.paths[a]) {
            Ext.Loader.setPath(a, b.appFolder || "app")
        }
        d = Ext.Array.from(b.requires);
        b.requires = ["Ext.app.Application"];
        f = b.onReady;
        e = b.scope;
        b.onReady = function() {
            b.requires = d;
            new Ext.app.Application(b);
            if (f) {
                f.call(e)
            }
        };
        Ext.setup(b)
    },
    factoryConfig: function(a, n) {
        var h = Ext.isSimpleObject(a);
        if (h && a.xclass) {
            var g = a.xclass;
            delete a.xclass;
            Ext.require(g,
            function() {
                Ext.factoryConfig(a,
                function(i) {
                    n(Ext.create(g, i))
                })
            });
            return
        }
        var e = Ext.isArray(a),
        o = [],
        m,
        k,
        d,
        f;
        if (h || e) {
            if (h) {
                for (m in a) {
                    if (a.hasOwnProperty(m)) {
                        k = a[m];
                        if (Ext.isSimpleObject(k) || Ext.isArray(k)) {
                            o.push(m)
                        }
                    }
                }
            } else {
                for (d = 0, f = a.length; d < f; d++) {
                    k = a[d];
                    if (Ext.isSimpleObject(k) || Ext.isArray(k)) {
                        o.push(d)
                    }
                }
            }
            d = 0;
            f = o.length;
            if (f === 0) {
                n(a);
                return
            }
            function j(i) {
                a[m] = i;
                d++;
                b()
            }
            function b() {
                if (d >= f) {
                    n(a);
                    return
                }
                m = o[d];
                k = a[m];
                Ext.factoryConfig(k, j)
            }
            b();
            return
        }
        n(a)
    },
    factory: function(b, f, a, g) {
        var e = Ext.ClassManager,
        d;
        if (!b || b.isInstance) {
            if (a && a !== b) {
                a.destroy()
            }
            return b
        }
        if (g) {
            if (typeof b == "string") {
                return e.instantiateByAlias(g + "." + b)
            } else {
                if (Ext.isObject(b) && "type" in b) {
                    return e.instantiateByAlias(g + "." + b.type, b)
                }
            }
        }
        if (b === true) {
            return a || e.instantiate(f)
        }
        if ("xtype" in b) {
            d = e.instantiateByAlias("widget." + b.xtype, b)
        } else {
            if ("xclass" in b) {
                d = e.instantiate(b.xclass, b)
            }
        }
        if (d) {
            if (a) {
                a.destroy()
            }
            return d
        }
        if (a) {
            return a.setConfig(b)
        }
        return e.instantiate(f, b)
    },
    deprecateClassMember: function(b, d, a, e) {
        return this.deprecateProperty(b.prototype, d, a, e)
    },
    deprecateClassMembers: function(b, d) {
        var e = b.prototype,
        f, a;
        for (f in d) {
            if (d.hasOwnProperty(f)) {
                a = d[f];
                this.deprecateProperty(e, f, a)
            }
        }
    },
    deprecateProperty: function(b, d, a, e) {
        if (!e) {
            e = "'" + d + "' is deprecated"
        }
        if (a) {
            e += ", please use '" + a + "' instead"
        }
        if (a) {
            Ext.Object.defineProperty(b, d, {
                get: function() {
                    return this[a]
                },
                set: function(f) {
                    this[a] = f
                },
                configurable: true
            })
        }
    },
    deprecatePropertyValue: function(b, a, e, d) {
        Ext.Object.defineProperty(b, a, {
            get: function() {
                return e
            },
            configurable: true
        })
    },
    deprecateMethod: function(b, a, e, d) {
        b[a] = function() {
            if (e) {
                return e.apply(this, arguments)
            }
        }
    },
    deprecateClassMethod: function(a, b, i, e) {
        if (typeof b != "string") {
            var h, g;
            for (h in b) {
                if (b.hasOwnProperty(h)) {
                    g = b[h];
                    Ext.deprecateClassMethod(a, h, g)
                }
            }
            return
        }
        var d = typeof i == "string",
        f;
        if (!e) {
            e = "'" + b + "()' is deprecated, please use '" + (d ? i: i.name) + "()' instead"
        }
        if (d) {
            f = function() {
                return this[i].apply(this, arguments)
            }
        } else {
            f = function() {
                return i.apply(this, arguments)
            }
        }
        if (b in a.prototype) {
            Ext.Object.defineProperty(a.prototype, b, {
                value: null,
                writable: true,
                configurable: true
            })
        }
        a.addMember(b, f)
    },
    isReady: false,
    readyListeners: [],
    triggerReady: function() {
        var b = Ext.readyListeners,
        a, d, e;
        if (!Ext.isReady) {
            Ext.isReady = true;
            for (a = 0, d = b.length; a < d; a++) {
                e = b[a];
                e.fn.call(e.scope)
            }
            delete Ext.readyListeners
        }
    },
    onDocumentReady: function(e, d) {
        if (Ext.isReady) {
            e.call(d)
        } else {
            var b = Ext.triggerReady;
            Ext.readyListeners.push({
                fn: e,
                scope: d
            });
            if ((Ext.browser.is.WebWorks || Ext.browser.is.PhoneGap) && !Ext.os.is.Desktop) {
                if (!Ext.readyListenerAttached) {
                    Ext.readyListenerAttached = true;
                    document.addEventListener(Ext.browser.is.PhoneGap ? "deviceready": "webworksready", b, false)
                }
            } else {
                var a = (/MSIE 10/.test(navigator.userAgent)) ? /complete|loaded/: /interactive|complete|loaded/;
                if (document.readyState.match(a) !== null) {
                    b()
                } else {
                    if (!Ext.readyListenerAttached) {
                        Ext.readyListenerAttached = true;
                        window.addEventListener("DOMContentLoaded",
                        function() {
                            if (navigator.standalone) {
                                setTimeout(function() {
                                    setTimeout(function() {
                                        b()
                                    },
                                    1)
                                },
                                1)
                            } else {
                                setTimeout(function() {
                                    b()
                                },
                                1)
                            }
                        },
                        false)
                    }
                }
            }
        }
    },
    callback: function(e, d, b, a) {
        if (Ext.isFunction(e)) {
            b = b || [];
            d = d || window;
            if (a) {
                Ext.defer(e, a, d, b)
            } else {
                e.apply(d, b)
            }
        }
    }
});
Ext.define("Ext.env.Browser", {
    statics: {
        browserNames: {
            ie: "IE",
            firefox: "Firefox",
            safari: "Safari",
            chrome: "Chrome",
            opera: "Opera",
            dolfin: "Dolfin",
            webosbrowser: "webOSBrowser",
            chromeMobile: "ChromeMobile",
            chromeiOS: "ChromeiOS",
            silk: "Silk",
            other: "Other"
        },
        engineNames: {
            webkit: "WebKit",
            gecko: "Gecko",
            presto: "Presto",
            trident: "Trident",
            other: "Other"
        },
        enginePrefixes: {
            webkit: "AppleWebKit/",
            gecko: "Gecko/",
            presto: "Presto/",
            trident: "Trident/"
        },
        browserPrefixes: {
            ie: "MSIE ",
            firefox: "Firefox/",
            chrome: "Chrome/",
            safari: "Version/",
            opera: "OPR/",
            dolfin: "Dolfin/",
            webosbrowser: "wOSBrowser/",
            chromeMobile: "CrMo/",
            chromeiOS: "CriOS/",
            silk: "Silk/"
        }
    },
    styleDashPrefixes: {
        WebKit: "-webkit-",
        Gecko: "-moz-",
        Trident: "-ms-",
        Presto: "-o-",
        Other: ""
    },
    stylePrefixes: {
        WebKit: "Webkit",
        Gecko: "Moz",
        Trident: "ms",
        Presto: "O",
        Other: ""
    },
    propertyPrefixes: {
        WebKit: "webkit",
        Gecko: "moz",
        Trident: "ms",
        Presto: "o",
        Other: ""
    },
    is: Ext.emptyFn,
    name: null,
    version: null,
    engineName: null,
    engineVersion: null,
    setFlag: function(a, b) {
        if (typeof b == "undefined") {
            b = true
        }
        this.is[a] = b;
        this.is[a.toLowerCase()] = b;
        return this
    },
    constructor: function(r) {
        this.userAgent = r;
        var n = this.statics(),
        d = r.match(new RegExp("((?:" + Ext.Object.getValues(n.browserPrefixes).join(")|(?:") + "))([\\w\\._]+)")),
        b = r.match(new RegExp("((?:" + Ext.Object.getValues(n.enginePrefixes).join(")|(?:") + "))([\\w\\._]+)")),
        h = n.browserNames,
        m = h.other,
        g = n.engineNames,
        q = g.other,
        p = "",
        o = "",
        j = false,
        f,
        e,
        a;
        f = this.is = function(i) {
            return f[i] === true
        };
        if (d) {
            m = h[Ext.Object.getKey(n.browserPrefixes, d[1])];
            p = new Ext.Version(d[2])
        }
        if (b) {
            q = g[Ext.Object.getKey(n.enginePrefixes, b[1])];
            o = new Ext.Version(b[2])
        }
        if (q == "Trident" && m != "IE") {
            m = "IE";
            var k = r.match(/.*rv:(\d+.\d+)/);
            if (k && k.length) {
                k = k[1];
                p = new Ext.Version(k)
            }
        }
        if (r.match(/FB/) && m == "Other") {
            m = h.safari;
            q = g.webkit
        }
        if (r.match(/Android.*Chrome/g)) {
            m = "ChromeMobile"
        }
        if (r.match(/OPR/)) {
            m = "Opera";
            d = r.match(/OPR\/(\d+.\d+)/);
            p = new Ext.Version(d[1])
        }
        Ext.apply(this, {
            engineName: q,
            engineVersion: o,
            name: m,
            version: p
        });
        this.setFlag(m);
        if (p) {
            this.setFlag(m + (p.getMajor() || ""));
            this.setFlag(m + p.getShortVersion())
        }
        for (e in h) {
            if (h.hasOwnProperty(e)) {
                a = h[e];
                this.setFlag(a, m === a)
            }
        }
        this.setFlag(a);
        if (o) {
            this.setFlag(q + (o.getMajor() || ""));
            this.setFlag(q + o.getShortVersion())
        }
        for (e in g) {
            if (g.hasOwnProperty(e)) {
                a = g[e];
                this.setFlag(a, q === a)
            }
        }
        this.setFlag("Standalone", !!navigator.standalone);
        this.setFlag("Ripple", !!document.getElementById("tinyhippos-injected") && !Ext.isEmpty(window.top.ripple));
        this.setFlag("WebWorks", !!window.blackberry);
        if (typeof window.PhoneGap != "undefined" || typeof window.Cordova != "undefined" || typeof window.cordova != "undefined") {
            j = true;
            this.setFlag("PhoneGap");
            this.setFlag("Cordova")
        } else {
            if ( !! window.isNK) {
                j = true;
                this.setFlag("Sencha")
            }
        }
        if (/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)(?!.*FBAN)/i.test(r)) {
            j = true
        }
        this.setFlag("WebView", j);
        this.isStrict = document.compatMode == "CSS1Compat";
        this.isSecure = /^https/i.test(window.location.protocol);
        return this
    },
    getStyleDashPrefix: function() {
        return this.styleDashPrefixes[this.engineName]
    },
    getStylePrefix: function() {
        return this.stylePrefixes[this.engineName]
    },
    getVendorProperyName: function(a) {
        var b = this.propertyPrefixes[this.engineName];
        if (b.length > 0) {
            return b + Ext.String.capitalize(a)
        }
        return a
    },
    getPreferredTranslationMethod: function(a) {
        if (typeof a == "object" && "translationMethod" in a && a.translationMethod !== "auto") {
            return a.translationMethod
        } else {
            if (this.is.AndroidStock2 || this.is.IE) {
                return "scrollposition"
            } else {
                return "csstransform"
            }
        }
    }
},
function() {
    var a = Ext.browser = new this(Ext.global.navigator.userAgent)
});
Ext.define("Ext.env.OS", {
    statics: {
        names: {
            ios: "iOS",
            android: "Android",
            windowsPhone: "WindowsPhone",
            webos: "webOS",
            blackberry: "BlackBerry",
            rimTablet: "RIMTablet",
            mac: "MacOS",
            win: "Windows",
            tizen: "Tizen",
            linux: "Linux",
            bada: "Bada",
            chrome: "ChromeOS",
            other: "Other"
        },
        prefixes: {
            tizen: "(Tizen )",
            ios: "i(?:Pad|Phone|Pod)(?:.*)CPU(?: iPhone)? OS ",
            android: "(Android |HTC_|Silk/)",
            windowsPhone: "Windows Phone ",
            blackberry: "(?:BlackBerry|BB)(?:.*)Version/",
            rimTablet: "RIM Tablet OS ",
            webos: "(?:webOS|hpwOS)/",
            bada: "Bada/",
            chrome: "CrOS "
        }
    },
    is: Ext.emptyFn,
    name: null,
    version: null,
    setFlag: function(a, b) {
        if (typeof b == "undefined") {
            b = true
        }
        this.is[a] = b;
        this.is[a.toLowerCase()] = b;
        return this
    },
    constructor: function(q, b, m) {
        var n = this.statics(),
        k = n.names,
        e = n.prefixes,
        a,
        j = "",
        d,
        h,
        g,
        p,
        f,
        o;
        m = m || Ext.browser;
        f = this.is = function(i) {
            return this.is[i] === true
        };
        for (d in e) {
            if (e.hasOwnProperty(d)) {
                h = e[d];
                g = q.match(new RegExp("(?:" + h + ")([^\\s;]+)"));
                if (g) {
                    a = k[d];
                    o = g[1];
                    if (o && o == "HTC_") {
                        j = new Ext.Version("2.3")
                    } else {
                        if (o && o == "Silk/") {
                            j = new Ext.Version("2.3")
                        } else {
                            j = new Ext.Version(g[g.length - 1])
                        }
                    }
                    break
                }
            }
        }
        if (!a) {
            a = k[(q.toLowerCase().match(/mac|win|linux/) || ["other"])[0]];
            j = new Ext.Version("")
        }
        this.name = a;
        this.version = j;
        if (b) {
            this.setFlag(b.replace(/ simulator$/i, ""))
        }
        this.setFlag(a);
        if (j) {
            this.setFlag(a + (j.getMajor() || ""));
            this.setFlag(a + j.getShortVersion())
        }
        for (d in k) {
            if (k.hasOwnProperty(d)) {
                p = k[d];
                if (!f.hasOwnProperty(a)) {
                    this.setFlag(p, (a === p))
                }
            }
        }
        if (this.name == "iOS" && window.screen.height == 568) {
            this.setFlag("iPhone5")
        }
        if (m.is.Safari || m.is.Silk) {
            if (this.is.Android2 || this.is.Android3 || m.version.shortVersion == 501) {
                m.setFlag("AndroidStock");
                m.setFlag("AndroidStock2")
            }
            if (this.is.Android4) {
                m.setFlag("AndroidStock");
                m.setFlag("AndroidStock4")
            }
        }
        return this
    }
},
function() {
    var a = Ext.global.navigator,
    f = a.userAgent,
    b, h, e;
    Ext.os = b = new this(f, a.platform);
    h = b.name;
    var d = window.location.search.match(/deviceType=(Tablet|Phone)/),
    g = window.deviceType;
    if (d && d[1]) {
        e = d[1]
    } else {
        if (g === "iPhone") {
            e = "Phone"
        } else {
            if (g === "iPad") {
                e = "Tablet"
            } else {
                if (!b.is.Android && !b.is.iOS && !b.is.WindowsPhone && /Windows|Linux|MacOS/.test(h)) {
                    e = "Desktop";
                    Ext.browser.is.WebView = Ext.browser.is.Ripple ? true: false
                } else {
                    if (b.is.iPad || b.is.RIMTablet || b.is.Android3 || Ext.browser.is.Silk || (b.is.Android4 && f.search(/mobile/i) == -1)) {
                        e = "Tablet"
                    } else {
                        e = "Phone"
                    }
                }
            }
        }
    }
    b.setFlag(e, true);
    b.deviceType = e
});
Ext.define("Ext.env.Feature", {
    constructor: function() {
        this.testElements = {};
        this.has = function(a) {
            return !! this.has[a]
        };
        if (!Ext.theme) {
            Ext.theme = {
                name: "Default"
            }
        }
        Ext.theme.is = {};
        Ext.theme.is[Ext.theme.name] = true;
        Ext.onDocumentReady(function() {
            this.registerTest({
                ProperHBoxStretching: function() {
                    var b = document.createElement("div"),
                    d = b.appendChild(document.createElement("div")),
                    e = d.appendChild(document.createElement("div")),
                    a;
                    b.setAttribute("style", "width: 100px; height: 100px; position: relative;");
                    d.setAttribute("style", "position: absolute; display: -ms-flexbox; display: -webkit-flex; display: -moz-flexbox; display: flex; -ms-flex-direction: row; -webkit-flex-direction: row; -moz-flex-direction: row; flex-direction: row; min-width: 100%;");
                    e.setAttribute("style", "width: 200px; height: 50px;");
                    document.body.appendChild(b);
                    a = d.offsetWidth;
                    document.body.removeChild(b);
                    return (a > 100)
                }
            })
        },
        this)
    },
    getTestElement: function(a, b) {
        if (a === undefined) {
            a = "div"
        } else {
            if (typeof a !== "string") {
                return a
            }
        }
        if (b) {
            return document.createElement(a)
        }
        if (!this.testElements[a]) {
            this.testElements[a] = document.createElement(a)
        }
        return this.testElements[a]
    },
    isStyleSupported: function(d, b) {
        var e = this.getTestElement(b).style,
        a = Ext.String.capitalize(d);
        if (typeof e[d] !== "undefined" || typeof e[Ext.browser.getStylePrefix(d) + a] !== "undefined") {
            return true
        }
        return false
    },
    isStyleSupportedWithoutPrefix: function(b, a) {
        var d = this.getTestElement(a).style;
        if (typeof d[b] !== "undefined") {
            return true
        }
        return false
    },
    isEventSupported: function(d, a) {
        if (a === undefined) {
            a = window
        }
        var f = this.getTestElement(a),
        b = "on" + d.toLowerCase(),
        e = (b in f);
        if (!e) {
            if (f.setAttribute && f.removeAttribute) {
                f.setAttribute(b, "");
                e = typeof f[b] === "function";
                if (typeof f[b] !== "undefined") {
                    f[b] = undefined
                }
                f.removeAttribute(b)
            }
        }
        return e
    },
    getSupportedPropertyName: function(b, a) {
        var d = Ext.browser.getVendorProperyName(a);
        if (d in b) {
            return d
        } else {
            if (a in b) {
                return a
            }
        }
        return null
    },
    registerTest: Ext.Function.flexSetter(function(a, b) {
        this.has[a] = b.call(this);
        return this
    })
},
function() {
    Ext.feature = new this;
    var a = Ext.feature.has;
    Ext.feature.registerTest({
        Canvas: function() {
            var b = this.getTestElement("canvas");
            return !! (b && b.getContext && b.getContext("2d"))
        },
        Svg: function() {
            var b = document;
            return !! (b.createElementNS && !!b.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect)
        },
        Vml: function() {
            var d = this.getTestElement(),
            b = false;
            d.innerHTML = "<!--[if vml]><br><![endif]-->";
            b = (d.childNodes.length === 1);
            d.innerHTML = "";
            return b
        },
        Touch: function() {
            return Ext.browser.is.Ripple || (this.isEventSupported("touchstart") && !(Ext.os && Ext.os.name.match(/Windows|MacOS|Linux/) && !Ext.os.is.BlackBerry6))
        },
        Pointer: function() {
            return !! window.navigator.msPointerEnabled
        },
        Orientation: function() {
            return ("orientation" in window) && this.isEventSupported("orientationchange")
        },
        OrientationChange: function() {
            return this.isEventSupported("orientationchange")
        },
        DeviceMotion: function() {
            return this.isEventSupported("devicemotion")
        },
        Geolocation: function() {
            return "geolocation" in window.navigator
        },
        SqlDatabase: function() {
            return "openDatabase" in window
        },
        WebSockets: function() {
            return "WebSocket" in window
        },
        Range: function() {
            return !! document.createRange
        },
        CreateContextualFragment: function() {
            var b = !!document.createRange ? document.createRange() : false;
            return b && !!b.createContextualFragment
        },
        History: function() {
            return ("history" in window && "pushState" in window.history)
        },
        CssTransforms: function() {
            return this.isStyleSupported("transform")
        },
        CssTransformNoPrefix: function() {
            return this.isStyleSupportedWithoutPrefix("transform")
        },
        Css3dTransforms: function() {
            return this.has("CssTransforms") && this.isStyleSupported("perspective") && !Ext.browser.is.AndroidStock2
        },
        CssAnimations: function() {
            return this.isStyleSupported("animationName")
        },
        CssTransitions: function() {
            return this.isStyleSupported("transitionProperty")
        },
        Audio: function() {
            return !! this.getTestElement("audio").canPlayType
        },
        Video: function() {
            return !! this.getTestElement("video").canPlayType
        },
        ClassList: function() {
            return "classList" in this.getTestElement()
        },
        LocalStorage: function() {
            var b = false;
            try {
                if ("localStorage" in window && window.localStorage !== null) {
                    localStorage.setItem("sencha-localstorage-test", "test success");
                    localStorage.removeItem("sencha-localstorage-test");
                    b = true
                }
            } catch(d) {}
            return b
        },
        XHR2: function() {
            return window.ProgressEvent && window.FormData && window.XMLHttpRequest && ("withCredentials" in new XMLHttpRequest)
        },
        XHRUploadProgress: function() {
            if (window.XMLHttpRequest && !Ext.browser.is.AndroidStock) {
                var b = new XMLHttpRequest();
                return b && ("upload" in b) && ("onprogress" in b.upload)
            }
            return false
        },
        NumericInputPlaceHolder: function() {
            return ! (Ext.browser.is.AndroidStock4 && Ext.os.version.getMinor() < 2)
        }
    })
});
Ext.define("Ext.dom.Query", {
    select: function(k, b) {
        var h = [],
        e,
        g,
        f,
        d,
        a;
        b = b || document;
        if (typeof b == "string") {
            b = document.getElementById(b)
        }
        k = k.split(",");
        for (g = 0, d = k.length; g < d; g++) {
            if (typeof k[g] == "string") {
                if (k[g][0] == "@") {
                    e = b.getAttributeNode(k[g].substring(1));
                    h.push(e)
                } else {
                    e = b.querySelectorAll(k[g]);
                    for (f = 0, a = e.length; f < a; f++) {
                        h.push(e[f])
                    }
                }
            }
        }
        return h
    },
    selectNode: function(b, a) {
        return this.select(b, a)[0]
    },
    is: function(d, g) {
        var a, f, b, e;
        if (typeof d == "string") {
            d = document.getElementById(d)
        }
        if (Ext.isArray(d)) {
            f = true;
            e = d.length;
            for (b = 0; b < e; b++) {
                if (!this.is(d[b], g)) {
                    f = false;
                    break
                }
            }
        } else {
            a = d.parentNode;
            if (!a) {
                a = document.createDocumentFragment();
                a.appendChild(d);
                f = this.select(g, a).indexOf(d) !== -1;
                a.removeChild(d);
                a = null
            } else {
                f = this.select(g, a).indexOf(d) !== -1
            }
        }
        return f
    },
    isXml: function(a) {
        var b = (a ? a.ownerDocument || a: 0).documentElement;
        return b ? b.nodeName !== "HTML": false
    }
},
function() {
    Ext.ns("Ext.core");
    Ext.core.DomQuery = Ext.DomQuery = new this();
    Ext.query = Ext.Function.alias(Ext.DomQuery, "select")
});
Ext.define("Ext.dom.Helper", {
    emptyTags: /^(?:br|frame|hr|img|input|link|meta|range|spacer|wbr|area|param|col)$/i,
    confRe: /tag|children|cn|html|tpl|tplData$/i,
    endRe: /end/i,
    attribXlat: {
        cls: "class",
        htmlFor: "for"
    },
    closeTags: {},
    decamelizeName: function() {
        var d = /([a-z])([A-Z])/g,
        b = {};
        function a(e, g, f) {
            return g + "-" + f.toLowerCase()
        }
        return function(e) {
            return b[e] || (b[e] = e.replace(d, a))
        }
    } (),
    generateMarkup: function(e, d) {
        var h = this,
        b, j, a, f, g;
        if (typeof e == "string") {
            d.push(e)
        } else {
            if (Ext.isArray(e)) {
                for (f = 0; f < e.length; f++) {
                    if (e[f]) {
                        h.generateMarkup(e[f], d)
                    }
                }
            } else {
                a = e.tag || "div";
                d.push("<", a);
                for (b in e) {
                    if (e.hasOwnProperty(b)) {
                        j = e[b];
                        if (!h.confRe.test(b)) {
                            if (typeof j == "object") {
                                d.push(" ", b, '="');
                                h.generateStyles(j, d).push('"')
                            } else {
                                d.push(" ", h.attribXlat[b] || b, '="', j, '"')
                            }
                        }
                    }
                }
                if (h.emptyTags.test(a)) {
                    d.push("/>")
                } else {
                    d.push(">");
                    if ((j = e.tpl)) {
                        j.applyOut(e.tplData, d)
                    }
                    if ((j = e.html)) {
                        d.push(j)
                    }
                    if ((j = e.cn || e.children)) {
                        h.generateMarkup(j, d)
                    }
                    g = h.closeTags;
                    d.push(g[a] || (g[a] = "</" + a + ">"))
                }
            }
        }
        return d
    },
    generateStyles: function(f, d) {
        var b = d || [],
        e;
        for (e in f) {
            if (f.hasOwnProperty(e)) {
                b.push(this.decamelizeName(e), ":", f[e], ";")
            }
        }
        return d || b.join("")
    },
    markup: function(a) {
        if (typeof a == "string") {
            return a
        }
        var b = this.generateMarkup(a, []);
        return b.join("")
    },
    applyStyles: function(a, b) {
        Ext.fly(a).applyStyles(b)
    },
    createContextualFragment: function(d) {
        var g = document.createElement("div"),
        a = document.createDocumentFragment(),
        b = 0,
        e,
        f;
        g.innerHTML = d;
        f = g.childNodes;
        e = f.length;
        for (; b < e; b++) {
            a.appendChild(f[b].cloneNode(true))
        }
        return a
    },
    insertHtml: function(f, a, g) {
        var k, h, m, d, b, i;
        f = f.toLowerCase();
        if (Ext.isTextNode(a)) {
            if (f == "afterbegin") {
                f = "beforebegin"
            } else {
                if (f == "beforeend") {
                    f = "afterend"
                }
            }
        }
        b = f == "beforebegin";
        i = f == "afterbegin";
        h = Ext.feature.has.CreateContextualFragment ? a.ownerDocument.createRange() : undefined;
        k = "setStart" + (this.endRe.test(f) ? "After": "Before");
        if (b || f == "afterend") {
            if (h) {
                h[k](a);
                m = h.createContextualFragment(g)
            } else {
                m = this.createContextualFragment(g)
            }
            a.parentNode.insertBefore(m, b ? a: a.nextSibling);
            return a[(b ? "previous": "next") + "Sibling"]
        } else {
            d = (i ? "first": "last") + "Child";
            if (a.firstChild) {
                if (h) {
                    try {
                        h[k](a[d]);
                        m = h.createContextualFragment(g)
                    } catch(j) {
                        m = this.createContextualFragment(g)
                    }
                } else {
                    m = this.createContextualFragment(g)
                }
                if (i) {
                    a.insertBefore(m, a.firstChild)
                } else {
                    a.appendChild(m)
                }
            } else {
                a.innerHTML = g
            }
            return a[d]
        }
    },
    insertBefore: function(a, d, b) {
        return this.doInsert(a, d, b, "beforebegin")
    },
    insertAfter: function(a, d, b) {
        return this.doInsert(a, d, b, "afterend")
    },
    insertFirst: function(a, d, b) {
        return this.doInsert(a, d, b, "afterbegin")
    },
    append: function(a, d, b) {
        return this.doInsert(a, d, b, "beforeend")
    },
    overwrite: function(a, d, b) {
        a = Ext.getDom(a);
        a.innerHTML = this.markup(d);
        return b ? Ext.get(a.firstChild) : a.firstChild
    },
    doInsert: function(b, e, d, f) {
        var a = this.insertHtml(f, Ext.getDom(b), this.markup(e));
        return d ? Ext.get(a, true) : a
    },
    createTemplate: function(b) {
        var a = this.markup(b);
        return new Ext.Template(a)
    }
},
function() {
    Ext.ns("Ext.core");
    Ext.core.DomHelper = Ext.DomHelper = new this
});
Ext.define("Ext.mixin.Identifiable", {
    statics: {
        uniqueIds: {}
    },
    isIdentifiable: true,
    mixinId: "identifiable",
    idCleanRegex: /\.|[^\w\-]/g,
    defaultIdPrefix: "ext-",
    defaultIdSeparator: "-",
    getOptimizedId: function() {
        return this.id
    },
    getUniqueId: function() {
        var g = this.id,
        b, e, f, a, d;
        if (!g) {
            b = this.self.prototype;
            e = this.defaultIdSeparator;
            a = Ext.mixin.Identifiable.uniqueIds;
            if (!b.hasOwnProperty("identifiablePrefix")) {
                f = this.xtype;
                if (f) {
                    d = this.defaultIdPrefix + f + e
                } else {
                    d = b.$className.replace(this.idCleanRegex, e).toLowerCase() + e
                }
                b.identifiablePrefix = d
            }
            d = this.identifiablePrefix;
            if (!a.hasOwnProperty(d)) {
                a[d] = 0
            }
            g = this.id = d + (++a[d])
        }
        this.getUniqueId = this.getOptimizedId;
        return g
    },
    setId: function(a) {
        this.id = a
    },
    getId: function() {
        var a = this.id;
        if (!a) {
            a = this.getUniqueId()
        }
        this.getId = this.getOptimizedId;
        return a
    }
});
Ext.define("Ext.dom.Element", {
    alternateClassName: "Ext.Element",
    mixins: [Ext.mixin.Identifiable],
    observableType: "element",
    xtype: "element",
    statics: {
        CREATE_ATTRIBUTES: {
            style: "style",
            className: "className",
            cls: "cls",
            classList: "classList",
            text: "text",
            hidden: "hidden",
            html: "html",
            children: "children"
        },
        create: function(d, b) {
            var g = this.CREATE_ATTRIBUTES,
            f, j, m, k, a, e, h;
            if (!d) {
                d = {}
            }
            if (d.isElement) {
                return d.dom
            } else {
                if ("nodeType" in d) {
                    return d
                }
            }
            if (typeof d == "string") {
                return document.createTextNode(d)
            }
            m = d.tag;
            if (!m) {
                m = "div"
            }
            if (d.namespace) {
                f = document.createElementNS(d.namespace, m)
            } else {
                f = document.createElement(m)
            }
            j = f.style;
            for (a in d) {
                if (a != "tag") {
                    k = d[a];
                    switch (a) {
                    case g.style:
                        if (typeof k == "string") {
                            f.setAttribute(a, k)
                        } else {
                            for (e in k) {
                                if (k.hasOwnProperty(e)) {
                                    j[e] = k[e]
                                }
                            }
                        }
                        break;
                    case g.className:
                    case g.cls:
                        f.className = k;
                        break;
                    case g.classList:
                        f.className = k.join(" ");
                        break;
                    case g.text:
                        f.textContent = k;
                        break;
                    case g.hidden:
                        if (k) {
                            f.style.display = "none"
                        }
                        break;
                    case g.html:
                        f.innerHTML = k;
                        break;
                    case g.children:
                        for (e = 0, h = k.length; e < h; e++) {
                            f.appendChild(this.create(k[e], true))
                        }
                        break;
                    default:
                        f.setAttribute(a, k)
                    }
                }
            }
            if (b) {
                return f
            } else {
                return this.get(f)
            }
        },
        documentElement: null,
        cache: {},
        get: function(d) {
            var b = this.cache,
            a, e, f;
            if (!d) {
                return null
            }
            if (typeof d == "string") {
                e = document.getElementById(d);
                if (b.hasOwnProperty(d)) {
                    a = b[d]
                }
                if (e) {
                    if (a) {
                        a.dom = e
                    } else {
                        a = b[d] = new this(e)
                    }
                } else {
                    if (!a) {
                        a = null
                    }
                }
                return a
            }
            if ("tagName" in d) {
                f = d.id;
                if (b.hasOwnProperty(f)) {
                    a = b[f];
                    a.dom = d;
                    return a
                } else {
                    a = new this(d);
                    b[a.getId()] = a
                }
                return a
            }
            if (d.isElement) {
                return d
            }
            if (d.isComposite) {
                return d
            }
            if (Ext.isArray(d)) {
                return this.select(d)
            }
            if (d === document) {
                if (!this.documentElement) {
                    this.documentElement = new this(document.documentElement);
                    this.documentElement.setId("ext-application")
                }
                return this.documentElement
            }
            return null
        },
        data: function(d, b, f) {
            var a = Ext.cache,
            g, e;
            d = this.get(d);
            if (!d) {
                return null
            }
            g = d.id;
            e = a[g].data;
            if (!e) {
                a[g].data = e = {}
            }
            if (arguments.length == 2) {
                return e[b]
            } else {
                return (e[b] = f)
            }
        },
        serializeForm: function(d) {
            var f = d.elements || (document.forms[d] || Ext.getDom(d)).elements,
            q = false,
            p = encodeURIComponent,
            i = "",
            h = f.length,
            j,
            a,
            n,
            s,
            r,
            k,
            g,
            m,
            b;
            for (k = 0; k < h; k++) {
                j = f[k];
                a = j.name;
                n = j.type;
                s = j.options;
                if (!j.disabled && a) {
                    if (/select-(one|multiple)/i.test(n)) {
                        m = s.length;
                        for (g = 0; g < m; g++) {
                            b = s[g];
                            if (b.selected) {
                                r = b.hasAttribute ? b.hasAttribute("value") : b.getAttributeNode("value").specified;
                                i += Ext.String.format("{0}={1}&", p(a), p(r ? b.value: b.text))
                            }
                        }
                    } else {
                        if (! (/file|undefined|reset|button/i.test(n))) {
                            if (! (/radio|checkbox/i.test(n) && !j.checked) && !(n == "submit" && q)) {
                                i += p(a) + "=" + p(j.value) + "&";
                                q = /submit/i.test(n)
                            }
                        }
                    }
                }
            }
            return i.substr(0, i.length - 1)
        },
        serializeNode: function(e) {
            var b = "",
            d, g, a, f;
            if (e.nodeType === document.TEXT_NODE) {
                return e.nodeValue
            }
            b += "<" + e.nodeName;
            if (e.attributes.length) {
                for (d = 0, g = e.attributes.length; d < g; d++) {
                    a = e.attributes[d];
                    b += " " + a.name + '="' + a.value + '"'
                }
            }
            b += ">";
            if (e.childNodes && e.childNodes.length) {
                for (d = 0, g = e.childNodes.length; d < g; d++) {
                    f = e.childNodes[d];
                    b += this.serializeNode(f)
                }
            }
            b += "</" + e.nodeName + ">";
            return b
        }
    },
    isElement: true,
    constructor: function(a) {
        if (typeof a == "string") {
            a = document.getElementById(a)
        }
        if (!a) {
            throw new Error("Invalid domNode reference or an id of an existing domNode: " + a)
        }
        this.dom = a;
        this.getUniqueId()
    },
    attach: function(a) {
        this.dom = a;
        this.id = a.id;
        return this
    },
    getUniqueId: function() {
        var b = this.id,
        a;
        if (!b) {
            a = this.dom;
            if (a.id.length > 0) {
                this.id = b = a.id
            } else {
                a.id = b = this.mixins.identifiable.getUniqueId.call(this)
            }
            Ext.Element.cache[b] = this
        }
        return b
    },
    setId: function(d) {
        var a = this.id,
        b = Ext.Element.cache;
        if (a) {
            delete b[a]
        }
        this.dom.id = d;
        this.id = d;
        b[d] = this;
        return this
    },
    setHtml: function(a) {
        this.dom.innerHTML = a
    },
    getHtml: function() {
        return this.dom.innerHTML
    },
    setText: function(a) {
        this.dom.textContent = a
    },
    redraw: function() {
        var b = this.dom,
        a = b.style;
        a.display = "none";
        b.offsetHeight;
        a.display = ""
    },
    isPainted: (function() {
        return ! Ext.browser.is.IE ?
        function() {
            var a = this.dom;
            return Boolean(a && a.offsetParent)
        }: function() {
            var a = this.dom;
            return Boolean(a && (a.offsetHeight !== 0 && a.offsetWidth !== 0))
        }
    })(),
    set: function(a, b) {
        var f = this.dom,
        d, e;
        for (d in a) {
            if (a.hasOwnProperty(d)) {
                e = a[d];
                if (d == "style") {
                    this.applyStyles(e)
                } else {
                    if (d == "cls") {
                        f.className = e
                    } else {
                        if (b !== false) {
                            if (e === undefined) {
                                f.removeAttribute(d)
                            } else {
                                f.setAttribute(d, e)
                            }
                        } else {
                            f[d] = e
                        }
                    }
                }
            }
        }
        return this
    },
    is: function(a) {
        return Ext.DomQuery.is(this.dom, a)
    },
    getValue: function(b) {
        var a = this.dom.value;
        return b ? parseInt(a, 10) : a
    },
    getAttribute: function(a, b) {
        var d = this.dom;
        return d.getAttributeNS(b, a) || d.getAttribute(b + ":" + a) || d.getAttribute(a) || d[a]
    },
    setSizeState: function(e) {
        var d = ["x-sized", "x-unsized", "x-stretched"],
        a = [true, false, null],
        b = a.indexOf(e),
        f;
        if (b !== -1) {
            f = d[b];
            d.splice(b, 1);
            this.addCls(f)
        }
        this.removeCls(d);
        return this
    },
    destroy: function() {
        this.isDestroyed = true;
        var a = Ext.Element.cache,
        b = this.dom;
        if (b && b.parentNode && b.tagName != "BODY") {
            b.parentNode.removeChild(b)
        }
        delete a[this.id];
        delete this.dom
    }
},
function(a) {
    Ext.elements = Ext.cache = a.cache;
    this.addStatics({
        Fly: new Ext.Class({
            extend: a,
            constructor: function(b) {
                this.dom = b
            }
        }),
        _flyweights: {},
        fly: function(f, d) {
            var g = null,
            e = a._flyweights,
            b;
            d = d || "_global";
            f = Ext.getDom(f);
            if (f) {
                g = e[d] || (e[d] = new a.Fly());
                g.dom = f;
                g.isSynchronized = false;
                b = Ext.cache[f.id];
                if (b && b.isElement) {
                    b.isSynchronized = false
                }
            }
            return g
        }
    });
    Ext.get = function(b) {
        return a.get(b)
    };
    Ext.fly = function() {
        return a.fly.apply(a, arguments)
    };
    Ext.ClassManager.onCreated(function() {
        a.mixin("observable", Ext.mixin.Observable)
    },
    null, "Ext.mixin.Observable")
});
Ext.dom.Element.addStatics({
    numberRe: /\d+$/,
    unitRe: /\d+(px|em|%|en|ex|pt|in|cm|mm|pc)$/i,
    camelRe: /(-[a-z])/gi,
    cssRe: /([a-z0-9-]+)\s*:\s*([^;\s]+(?:\s*[^;\s]+)*);?/gi,
    opacityRe: /alpha\(opacity=(.*)\)/i,
    propertyCache: {},
    defaultUnit: "px",
    borders: {
        l: "border-left-width",
        r: "border-right-width",
        t: "border-top-width",
        b: "border-bottom-width"
    },
    paddings: {
        l: "padding-left",
        r: "padding-right",
        t: "padding-top",
        b: "padding-bottom"
    },
    margins: {
        l: "margin-left",
        r: "margin-right",
        t: "margin-top",
        b: "margin-bottom"
    },
    addUnits: function(b, a) {
        if (b === "" || b == "auto" || b === undefined || b === null) {
            return b || ""
        }
        if (Ext.isNumber(b) || this.numberRe.test(b)) {
            return b + (a || this.defaultUnit || "px")
        } else {
            if (!this.unitRe.test(b)) {
                return b || ""
            }
        }
        return b
    },
    isAncestor: function(b, d) {
        var a = false;
        b = Ext.getDom(b);
        d = Ext.getDom(d);
        if (b && d) {
            if (b.contains) {
                return b.contains(d)
            } else {
                if (b.compareDocumentPosition) {
                    return !! (b.compareDocumentPosition(d) & 16)
                } else {
                    while ((d = d.parentNode)) {
                        a = d == b || a
                    }
                }
            }
        }
        return a
    },
    parseBox: function(b) {
        if (typeof b != "string") {
            b = b.toString()
        }
        var d = b.split(" "),
        a = d.length;
        if (a == 1) {
            d[1] = d[2] = d[3] = d[0]
        } else {
            if (a == 2) {
                d[2] = d[0];
                d[3] = d[1]
            } else {
                if (a == 3) {
                    d[3] = d[1]
                }
            }
        }
        return {
            top: d[0] || 0,
            right: d[1] || 0,
            bottom: d[2] || 0,
            left: d[3] || 0
        }
    },
    unitizeBox: function(d, a) {
        var b = this;
        d = b.parseBox(d);
        return b.addUnits(d.top, a) + " " + b.addUnits(d.right, a) + " " + b.addUnits(d.bottom, a) + " " + b.addUnits(d.left, a)
    },
    camelReplaceFn: function(b, d) {
        return d.charAt(1).toUpperCase()
    },
    normalize: function(a) {
        return this.propertyCache[a] || (this.propertyCache[a] = a.replace(this.camelRe, this.camelReplaceFn))
    },
    fromPoint: function(a, b) {
        return Ext.get(document.elementFromPoint(a, b))
    },
    parseStyles: function(d) {
        var a = {},
        b = this.cssRe,
        e;
        if (d) {
            b.lastIndex = 0;
            while ((e = b.exec(d))) {
                a[e[1]] = e[2]
            }
        }
        return a
    }
});
Ext.dom.Element.addMembers({
    appendChild: function(a) {
        this.dom.appendChild(Ext.getDom(a));
        return this
    },
    removeChild: function(a) {
        this.dom.removeChild(Ext.getDom(a));
        return this
    },
    append: function() {
        this.appendChild.apply(this, arguments)
    },
    appendTo: function(a) {
        Ext.getDom(a).appendChild(this.dom);
        return this
    },
    insertBefore: function(a) {
        a = Ext.getDom(a);
        a.parentNode.insertBefore(this.dom, a);
        return this
    },
    insertAfter: function(a) {
        a = Ext.getDom(a);
        a.parentNode.insertBefore(this.dom, a.nextSibling);
        return this
    },
    insertFirst: function(b) {
        var a = Ext.getDom(b),
        e = this.dom,
        d = e.firstChild;
        if (!d) {
            e.appendChild(a)
        } else {
            e.insertBefore(a, d)
        }
        return this
    },
    insertSibling: function(f, d, e) {
        var g = this,
        b, a = (d || "before").toLowerCase() == "after",
        h;
        if (Ext.isArray(f)) {
            h = g;
            Ext.each(f,
            function(i) {
                b = Ext.fly(h, "_internal").insertSibling(i, d, e);
                if (a) {
                    h = b
                }
            });
            return b
        }
        f = f || {};
        if (f.nodeType || f.dom) {
            b = g.dom.parentNode.insertBefore(Ext.getDom(f), a ? g.dom.nextSibling: g.dom);
            if (!e) {
                b = Ext.get(b)
            }
        } else {
            if (a && !g.dom.nextSibling) {
                b = Ext.core.DomHelper.append(g.dom.parentNode, f, !e)
            } else {
                b = Ext.core.DomHelper[a ? "insertAfter": "insertBefore"](g.dom, f, !e)
            }
        }
        return b
    },
    replace: function(a) {
        a = Ext.getDom(a);
        a.parentNode.replaceChild(this.dom, a);
        return this
    },
    replaceWith: function(a) {
        var b = this;
        if (a.nodeType || a.dom || typeof a == "string") {
            a = Ext.get(a);
            b.dom.parentNode.insertBefore(a.dom, b.dom)
        } else {
            a = Ext.core.DomHelper.insertBefore(b.dom, a)
        }
        delete Ext.cache[b.id];
        Ext.removeNode(b.dom);
        b.id = Ext.id(b.dom = a);
        return b
    },
    doReplaceWith: function(a) {
        var b = this.dom;
        b.parentNode.replaceChild(Ext.getDom(a), b)
    },
    createChild: function(b, a, d) {
        b = b || {
            tag: "div"
        };
        if (a) {
            return Ext.core.DomHelper.insertBefore(a, b, d !== true)
        } else {
            return Ext.core.DomHelper[!this.dom.firstChild ? "insertFirst": "append"](this.dom, b, d !== true)
        }
    },
    wrap: function(b, d) {
        var f = this.dom,
        g = this.self.create(b, d),
        e = (d) ? g: g.dom,
        a = f.parentNode;
        if (a) {
            a.insertBefore(e, f)
        }
        e.appendChild(f);
        return g
    },
    wrapAllChildren: function(a) {
        var e = this.dom,
        b = e.childNodes,
        f = this.self.create(a),
        d = f.dom;
        while (b.length > 0) {
            d.appendChild(e.firstChild)
        }
        e.appendChild(d);
        return f
    },
    unwrapAllChildren: function() {
        var d = this.dom,
        b = d.childNodes,
        a = d.parentNode;
        if (a) {
            while (b.length > 0) {
                a.insertBefore(d, d.firstChild)
            }
            this.destroy()
        }
    },
    unwrap: function() {
        var d = this.dom,
        a = d.parentNode,
        b;
        if (a) {
            b = a.parentNode;
            b.insertBefore(d, a);
            b.removeChild(a)
        } else {
            b = document.createDocumentFragment();
            b.appendChild(d)
        }
        return this
    },
    detach: function() {
        var a = this.dom;
        if (a && a.parentNode && a.tagName !== "BODY") {
            a.parentNode.removeChild(a)
        }
        return this
    },
    insertHtml: function(b, d, a) {
        var e = Ext.core.DomHelper.insertHtml(b, this.dom, d);
        return a ? Ext.get(e) : e
    }
});
Ext.dom.Element.override({
    getX: function() {
        return this.getXY()[0]
    },
    getY: function() {
        return this.getXY()[1]
    },
    getXY: function() {
        var b = this.dom.getBoundingClientRect(),
        a = Math.round;
        return [a(b.left + window.pageXOffset), a(b.top + window.pageYOffset)]
    },
    getOffsetsTo: function(a) {
        var d = this.getXY(),
        b = Ext.fly(a, "_internal").getXY();
        return [d[0] - b[0], d[1] - b[1]]
    },
    setX: function(a) {
        return this.setXY([a, this.getY()])
    },
    setY: function(a) {
        return this.setXY([this.getX(), a])
    },
    setXY: function(e) {
        var b = this;
        if (arguments.length > 1) {
            e = [e, arguments[1]]
        }
        var d = b.translatePoints(e),
        a = b.dom.style;
        for (e in d) {
            if (!d.hasOwnProperty(e)) {
                continue
            }
            if (!isNaN(d[e])) {
                a[e] = d[e] + "px"
            }
        }
        return b
    },
    getLeft: function() {
        return parseInt(this.getStyle("left"), 10) || 0
    },
    getRight: function() {
        return parseInt(this.getStyle("right"), 10) || 0
    },
    getTop: function() {
        return parseInt(this.getStyle("top"), 10) || 0
    },
    getBottom: function() {
        return parseInt(this.getStyle("bottom"), 10) || 0
    },
    translatePoints: function(a, h) {
        h = isNaN(a[1]) ? h: a[1];
        a = isNaN(a[0]) ? a: a[0];
        var e = this,
        f = e.isStyle("position", "relative"),
        g = e.getXY(),
        b = parseInt(e.getStyle("left"), 10),
        d = parseInt(e.getStyle("top"), 10);
        b = !isNaN(b) ? b: (f ? 0 : e.dom.offsetLeft);
        d = !isNaN(d) ? d: (f ? 0 : e.dom.offsetTop);
        return {
            left: (a - g[0] + b),
            top: (h - g[1] + d)
        }
    },
    setBox: function(e) {
        var d = this,
        b = e.width,
        a = e.height,
        g = e.top,
        f = e.left;
        if (f !== undefined) {
            d.setLeft(f)
        }
        if (g !== undefined) {
            d.setTop(g)
        }
        if (b !== undefined) {
            d.setWidth(b)
        }
        if (a !== undefined) {
            d.setHeight(a)
        }
        return this
    },
    getBox: function(h, k) {
        var i = this,
        f = i.dom,
        d = f.offsetWidth,
        m = f.offsetHeight,
        o, g, e, a, n, j;
        if (!k) {
            o = i.getXY()
        } else {
            if (h) {
                o = [0, 0]
            } else {
                o = [parseInt(i.getStyle("left"), 10) || 0, parseInt(i.getStyle("top"), 10) || 0]
            }
        }
        if (!h) {
            g = {
                x: o[0],
                y: o[1],
                0 : o[0],
                1 : o[1],
                width: d,
                height: m
            }
        } else {
            e = i.getBorderWidth.call(i, "l") + i.getPadding.call(i, "l");
            a = i.getBorderWidth.call(i, "r") + i.getPadding.call(i, "r");
            n = i.getBorderWidth.call(i, "t") + i.getPadding.call(i, "t");
            j = i.getBorderWidth.call(i, "b") + i.getPadding.call(i, "b");
            g = {
                x: o[0] + e,
                y: o[1] + n,
                0 : o[0] + e,
                1 : o[1] + n,
                width: d - (e + a),
                height: m - (n + j)
            }
        }
        g.left = g.x;
        g.top = g.y;
        g.right = g.x + g.width;
        g.bottom = g.y + g.height;
        return g
    },
    getPageBox: function(f) {
        var i = this,
        d = i.dom;
        if (!d) {
            return new Ext.util.Region()
        }
        var k = d.offsetWidth,
        g = d.offsetHeight,
        n = i.getXY(),
        m = n[1],
        a = n[0] + k,
        j = n[1] + g,
        e = n[0];
        if (f) {
            return new Ext.util.Region(m, a, j, e)
        } else {
            return {
                left: e,
                top: m,
                width: k,
                height: g,
                right: a,
                bottom: j
            }
        }
    }
});
Ext.dom.Element.addMembers({
    WIDTH: "width",
    HEIGHT: "height",
    MIN_WIDTH: "min-width",
    MIN_HEIGHT: "min-height",
    MAX_WIDTH: "max-width",
    MAX_HEIGHT: "max-height",
    TOP: "top",
    RIGHT: "right",
    BOTTOM: "bottom",
    LEFT: "left",
    VISIBILITY: 1,
    DISPLAY: 2,
    OFFSETS: 3,
    SEPARATOR: "-",
    trimRe: /^\s+|\s+$/g,
    wordsRe: /\w/g,
    spacesRe: /\s+/,
    styleSplitRe: /\s*(?::|;)\s*/,
    transparentRe: /^(?:transparent|(?:rgba[(](?:\s*\d+\s*[,]){3}\s*0\s*[)]))$/i,
    classNameSplitRegex: /[\s]+/,
    borders: {
        t: "border-top-width",
        r: "border-right-width",
        b: "border-bottom-width",
        l: "border-left-width"
    },
    paddings: {
        t: "padding-top",
        r: "padding-right",
        b: "padding-bottom",
        l: "padding-left"
    },
    margins: {
        t: "margin-top",
        r: "margin-right",
        b: "margin-bottom",
        l: "margin-left"
    },
    defaultUnit: "px",
    isSynchronized: false,
    synchronize: function() {
        var h = this.dom,
        a = {},
        e = h.className,
        g, d, f, b;
        if (e.length > 0) {
            g = h.className.split(this.classNameSplitRegex);
            for (d = 0, f = g.length; d < f; d++) {
                b = g[d];
                a[b] = true
            }
        } else {
            g = []
        }
        this.classList = g;
        this.hasClassMap = a;
        this.isSynchronized = true;
        return this
    },
    addCls: function(k, h, m) {
        if (!k) {
            return this
        }
        if (!this.isSynchronized) {
            this.synchronize()
        }
        var f = this.dom,
        d = this.hasClassMap,
        e = this.classList,
        a = this.SEPARATOR,
        g, j, b;
        h = h ? h + a: "";
        m = m ? a + m: "";
        if (typeof k == "string") {
            k = k.split(this.spacesRe)
        }
        for (g = 0, j = k.length; g < j; g++) {
            b = h + k[g] + m;
            if (!d[b]) {
                d[b] = true;
                e.push(b)
            }
        }
        f.className = e.join(" ");
        return this
    },
    removeCls: function(k, h, m) {
        if (!k) {
            return this
        }
        if (!this.isSynchronized) {
            this.synchronize()
        }
        if (!m) {
            m = ""
        }
        var f = this.dom,
        d = this.hasClassMap,
        e = this.classList,
        a = this.SEPARATOR,
        g, j, b;
        h = h ? h + a: "";
        m = m ? a + m: "";
        if (typeof k == "string") {
            k = k.split(this.spacesRe)
        }
        for (g = 0, j = k.length; g < j; g++) {
            b = h + k[g] + m;
            if (d[b]) {
                delete d[b];
                Ext.Array.remove(e, b)
            }
        }
        f.className = e.join(" ");
        return this
    },
    replaceCls: function(e, m, j, n) {
        if (!e && !m) {
            return this
        }
        e = e || [];
        m = m || [];
        if (!this.isSynchronized) {
            this.synchronize()
        }
        if (!n) {
            n = ""
        }
        var g = this.dom,
        d = this.hasClassMap,
        f = this.classList,
        a = this.SEPARATOR,
        h, k, b;
        j = j ? j + a: "";
        n = n ? a + n: "";
        if (typeof e == "string") {
            e = e.split(this.spacesRe)
        }
        if (typeof m == "string") {
            m = m.split(this.spacesRe)
        }
        for (h = 0, k = e.length; h < k; h++) {
            b = j + e[h] + n;
            if (d[b]) {
                delete d[b];
                Ext.Array.remove(f, b)
            }
        }
        for (h = 0, k = m.length; h < k; h++) {
            b = j + m[h] + n;
            if (!d[b]) {
                d[b] = true;
                f.push(b)
            }
        }
        g.className = f.join(" ");
        return this
    },
    hasCls: function(a) {
        if (!this.isSynchronized) {
            this.synchronize()
        }
        return this.hasClassMap.hasOwnProperty(a)
    },
    setCls: function(d) {
        var f = this.hasClassMap,
        b, e, a;
        if (typeof d == "string") {
            d = d.split(this.spacesRe)
        }
        for (b = 0, e = d.length; b < e; b++) {
            a = d[b];
            if (!f[a]) {
                f[a] = true
            }
        }
        this.classList = d.slice();
        this.dom.className = d.join(" ")
    },
    toggleCls: function(a, b) {
        if (typeof b !== "boolean") {
            b = !this.hasCls(a)
        }
        return (b) ? this.addCls(a) : this.removeCls(a)
    },
    swapCls: function(b, g, a, e) {
        if (a === undefined) {
            a = true
        }
        var f = a ? b: g,
        d = a ? g: b;
        if (d) {
            this.removeCls(e ? e + "-" + d: d)
        }
        if (f) {
            this.addCls(e ? e + "-" + f: f)
        }
        return this
    },
    setWidth: function(a) {
        return this.setLengthValue(this.WIDTH, a)
    },
    setHeight: function(a) {
        return this.setLengthValue(this.HEIGHT, a)
    },
    setSize: function(b, a) {
        if (Ext.isObject(b)) {
            a = b.height;
            b = b.width
        }
        this.setWidth(b);
        this.setHeight(a);
        return this
    },
    setMinWidth: function(a) {
        return this.setLengthValue(this.MIN_WIDTH, a)
    },
    setMinHeight: function(a) {
        return this.setLengthValue(this.MIN_HEIGHT, a)
    },
    setMaxWidth: function(a) {
        return this.setLengthValue(this.MAX_WIDTH, a)
    },
    setMaxHeight: function(a) {
        return this.setLengthValue(this.MAX_HEIGHT, a)
    },
    setTop: function(a) {
        return this.setLengthValue(this.TOP, a)
    },
    setRight: function(a) {
        return this.setLengthValue(this.RIGHT, a)
    },
    setBottom: function(a) {
        return this.setLengthValue(this.BOTTOM, a)
    },
    setLeft: function(a) {
        return this.setLengthValue(this.LEFT, a)
    },
    setMargin: function(b) {
        var a = this.dom.style;
        if (b || b === 0) {
            b = this.self.unitizeBox((b === true) ? 5 : b);
            a.setProperty("margin", b, "important")
        } else {
            a.removeProperty("margin-top");
            a.removeProperty("margin-right");
            a.removeProperty("margin-bottom");
            a.removeProperty("margin-left")
        }
    },
    setPadding: function(b) {
        var a = this.dom.style;
        if (b || b === 0) {
            b = this.self.unitizeBox((b === true) ? 5 : b);
            a.setProperty("padding", b, "important")
        } else {
            a.removeProperty("padding-top");
            a.removeProperty("padding-right");
            a.removeProperty("padding-bottom");
            a.removeProperty("padding-left")
        }
    },
    setBorder: function(a) {
        var b = this.dom.style;
        if (a || a === 0) {
            a = this.self.unitizeBox((a === true) ? 1 : a);
            b.setProperty("border-width", a, "important")
        } else {
            b.removeProperty("border-top-width");
            b.removeProperty("border-right-width");
            b.removeProperty("border-bottom-width");
            b.removeProperty("border-left-width")
        }
    },
    setLengthValue: function(a, d) {
        var b = this.dom.style;
        if (d === null) {
            b.removeProperty(a);
            return this
        }
        if (typeof d == "number") {
            d = d + "px"
        }
        b.setProperty(a, d, "important");
        return this
    },
    setVisible: function(b) {
        var a = this.getVisibilityMode(),
        d = b ? "removeCls": "addCls";
        switch (a) {
        case this.VISIBILITY:
            this.removeCls(["x-hidden-display", "x-hidden-offsets"]);
            this[d]("x-hidden-visibility");
            break;
        case this.DISPLAY:
            this.removeCls(["x-hidden-visibility", "x-hidden-offsets"]);
            this[d]("x-hidden-display");
            break;
        case this.OFFSETS:
            this.removeCls(["x-hidden-visibility", "x-hidden-display"]);
            this[d]("x-hidden-offsets");
            break
        }
        return this
    },
    getVisibilityMode: function() {
        var b = this.dom,
        a = Ext.dom.Element.data(b, "visibilityMode");
        if (a === undefined) {
            Ext.dom.Element.data(b, "visibilityMode", a = this.DISPLAY)
        }
        return a
    },
    setVisibilityMode: function(a) {
        this.self.data(this.dom, "visibilityMode", a);
        return this
    },
    show: function() {
        var a = this.dom;
        if (a) {
            a.style.removeProperty("display")
        }
    },
    hide: function() {
        this.dom.style.setProperty("display", "none", "important")
    },
    setVisibility: function(a) {
        var b = this.dom.style;
        if (a) {
            b.removeProperty("visibility")
        } else {
            b.setProperty("visibility", "hidden", "important")
        }
    },
    styleHooks: {},
    addStyles: function(j, h) {
        var b = 0,
        g = j.match(this.wordsRe),
        f = 0,
        a = g.length,
        e,
        d;
        for (; f < a; f++) {
            e = g[f];
            d = e && parseInt(this.getStyle(h[e]), 10);
            if (d) {
                b += Math.abs(d)
            }
        }
        return b
    },
    isStyle: function(a, b) {
        return this.getStyle(a) == b
    },
    getStyleValue: function(a) {
        return this.dom.style.getPropertyValue(a)
    },
    getStyle: function(g) {
        var d = this,
        f = d.dom,
        e = d.styleHooks[g],
        b,
        a;
        if (f == document) {
            return null
        }
        if (!e) {
            d.styleHooks[g] = e = {
                name: Ext.dom.Element.normalize(g)
            }
        }
        if (e.get) {
            return e.get(f, d)
        }
        b = window.getComputedStyle(f, "");
        a = (b && b[e.name]);
        return a
    },
    setStyle: function(a, i) {
        var g = this,
        e = g.dom,
        j = g.styleHooks,
        b = e.style,
        f = Ext.valueFrom,
        d, h;
        if (typeof a == "string") {
            h = j[a];
            if (!h) {
                j[a] = h = {
                    name: Ext.dom.Element.normalize(a)
                }
            }
            i = f(i, "");
            if (h.set) {
                h.set(e, i, g)
            } else {
                b[h.name] = i
            }
        } else {
            for (d in a) {
                if (a.hasOwnProperty(d)) {
                    h = j[d];
                    if (!h) {
                        j[d] = h = {
                            name: Ext.dom.Element.normalize(d)
                        }
                    }
                    i = f(a[d], "");
                    if (h.set) {
                        h.set(e, i, g)
                    } else {
                        b[h.name] = i
                    }
                }
            }
        }
        return g
    },
    getHeight: function(b) {
        var d = this.dom,
        a = b ? (d.clientHeight - this.getPadding("tb")) : d.offsetHeight;
        return a > 0 ? a: 0
    },
    getWidth: function(a) {
        var d = this.dom,
        b = a ? (d.clientWidth - this.getPadding("lr")) : d.offsetWidth;
        return b > 0 ? b: 0
    },
    getBorderWidth: function(a) {
        return this.addStyles(a, this.borders)
    },
    getPadding: function(a) {
        return this.addStyles(a, this.paddings)
    },
    applyStyles: function(e) {
        if (e) {
            var f = this.dom,
            d, b, a;
            if (typeof e == "function") {
                e = e.call()
            }
            d = typeof e;
            if (d == "string") {
                e = Ext.util.Format.trim(e).split(this.styleSplitRe);
                for (b = 0, a = e.length; b < a;) {
                    f.style[Ext.dom.Element.normalize(e[b++])] = e[b++]
                }
            } else {
                if (d == "object") {
                    this.setStyle(e)
                }
            }
        }
        return this
    },
    getSize: function(b) {
        var a = this.dom;
        return {
            width: Math.max(0, b ? (a.clientWidth - this.getPadding("lr")) : a.offsetWidth),
            height: Math.max(0, b ? (a.clientHeight - this.getPadding("tb")) : a.offsetHeight)
        }
    },
    repaint: function() {
        var a = this.dom;
        this.addCls(Ext.baseCSSPrefix + "repaint");
        setTimeout(function() {
            Ext.fly(a).removeCls(Ext.baseCSSPrefix + "repaint")
        },
        1);
        return this
    },
    getMargin: function(b) {
        var d = this,
        e = {
            t: "top",
            l: "left",
            r: "right",
            b: "bottom"
        },
        f = {},
        a;
        if (!b) {
            for (a in d.margins) {
                f[e[a]] = parseFloat(d.getStyle(d.margins[a])) || 0
            }
            return f
        } else {
            return d.addStyles.call(d, b, d.margins)
        }
    },
    translate: function() {
        var a = "webkitTransform" in document.createElement("div").style ? "webkitTransform": "transform";
        return function(b, e, d) {
            this.dom.style[a] = "translate3d(" + (b || 0) + "px, " + (e || 0) + "px, " + (d || 0) + "px)"
        }
    } ()
});
Ext.dom.Element.addMembers({
    getParent: function() {
        return Ext.get(this.dom.parentNode)
    },
    getFirstChild: function() {
        return Ext.get(this.dom.firstElementChild)
    },
    contains: function(a) {
        if (!a) {
            return false
        }
        var b = Ext.getDom(a);
        return (b === this.dom) || this.self.isAncestor(this.dom, b)
    },
    findParent: function(i, h, d) {
        var f = this.dom,
        a = document.body,
        g = 0,
        e;
        h = h || 50;
        if (isNaN(h)) {
            e = Ext.getDom(h);
            h = Number.MAX_VALUE
        }
        while (f && f.nodeType == 1 && g < h && f != a && f != e) {
            if (Ext.DomQuery.is(f, i)) {
                return d ? Ext.get(f) : f
            }
            g++;
            f = f.parentNode
        }
        return null
    },
    findParentNode: function(e, d, a) {
        var b = Ext.fly(this.dom.parentNode, "_internal");
        return b ? b.findParent(e, d, a) : null
    },
    up: function(b, a) {
        return this.findParentNode(b, a, true)
    },
    select: function(a, b) {
        return Ext.dom.Element.select(a, b, this.dom)
    },
    query: function(a) {
        return Ext.DomQuery.select(a, this.dom)
    },
    down: function(a, b) {
        var d = Ext.DomQuery.selectNode(a, this.dom);
        return b ? d: Ext.get(d)
    },
    child: function(a, b) {
        var e, d = this,
        f;
        f = Ext.get(d).id;
        f = f.replace(/[\.:]/g, "\\$0");
        e = Ext.DomQuery.selectNode("#" + f + " > " + a, d.dom);
        return b ? e: Ext.get(e)
    },
    parent: function(a, b) {
        return this.matchNode("parentNode", "parentNode", a, b)
    },
    next: function(a, b) {
        return this.matchNode("nextSibling", "nextSibling", a, b)
    },
    prev: function(a, b) {
        return this.matchNode("previousSibling", "previousSibling", a, b)
    },
    first: function(a, b) {
        return this.matchNode("nextSibling", "firstChild", a, b)
    },
    last: function(a, b) {
        return this.matchNode("previousSibling", "lastChild", a, b)
    },
    matchNode: function(b, f, a, d) {
        if (!this.dom) {
            return null
        }
        var e = this.dom[f];
        while (e) {
            if (e.nodeType == 1 && (!a || Ext.DomQuery.is(e, a))) {
                return ! d ? Ext.get(e) : e
            }
            e = e[b]
        }
        return null
    },
    isAncestor: function(a) {
        return this.self.isAncestor.call(this.self, this.dom, a)
    }
});
Ext.define("Ext.dom.CompositeElementLite", {
    alternateClassName: ["Ext.CompositeElementLite", "Ext.CompositeElement"],
    statics: {
        importElementMethods: function() {}
    },
    constructor: function(b, a) {
        this.elements = [];
        this.add(b, a);
        this.el = new Ext.dom.Element.Fly()
    },
    isComposite: true,
    getElement: function(a) {
        return this.el.attach(a).synchronize()
    },
    transformElement: function(a) {
        return Ext.getDom(a)
    },
    getCount: function() {
        return this.elements.length
    },
    add: function(d, a) {
        var f = this.elements,
        b, e;
        if (!d) {
            return this
        }
        if (typeof d == "string") {
            d = Ext.dom.Element.selectorFunction(d, a)
        } else {
            if (d.isComposite) {
                d = d.elements
            } else {
                if (!Ext.isIterable(d)) {
                    d = [d]
                }
            }
        }
        for (b = 0, e = d.length; b < e; ++b) {
            f.push(this.transformElement(d[b]))
        }
        return this
    },
    invoke: function(e, a) {
        var g = this.elements,
        f = g.length,
        d, b;
        for (b = 0; b < f; b++) {
            d = g[b];
            if (d) {
                Ext.dom.Element.prototype[e].apply(this.getElement(d), a)
            }
        }
        return this
    },
    item: function(b) {
        var d = this.elements[b],
        a = null;
        if (d) {
            a = this.getElement(d)
        }
        return a
    },
    addListener: function(b, j, h, g) {
        var f = this.elements,
        a = f.length,
        d, k;
        for (d = 0; d < a; d++) {
            k = f[d];
            if (k) {
                k.on(b, j, h || k, g)
            }
        }
        return this
    },
    each: function(g, f) {
        var h = this,
        d = h.elements,
        a = d.length,
        b, j;
        for (b = 0; b < a; b++) {
            j = d[b];
            if (j) {
                j = this.getElement(j);
                if (g.call(f || j, j, h, b) === false) {
                    break
                }
            }
        }
        return h
    },
    fill: function(a) {
        var b = this;
        b.elements = [];
        b.add(a);
        return b
    },
    filter: function(a) {
        var b = [],
        e = this,
        d = Ext.isFunction(a) ? a: function(f) {
            return f.is(a)
        };
        e.each(function(h, f, g) {
            if (d(h, g) !== false) {
                b[b.length] = e.transformElement(h)
            }
        });
        e.elements = b;
        return e
    },
    indexOf: function(a) {
        return Ext.Array.indexOf(this.elements, this.transformElement(a))
    },
    replaceElement: function(f, e, a) {
        var b = !isNaN(f) ? f: this.indexOf(f),
        g;
        if (b > -1) {
            e = Ext.getDom(e);
            if (a) {
                g = this.elements[b];
                g.parentNode.insertBefore(e, g);
                Ext.removeNode(g)
            }
            Ext.Array.splice(this.elements, b, 1, e)
        }
        return this
    },
    clear: function() {
        this.elements = []
    },
    addElements: function(d, a) {
        if (!d) {
            return this
        }
        if (typeof d == "string") {
            d = Ext.dom.Element.selectorFunction(d, a)
        }
        var b = this.elements;
        Ext.each(d,
        function(f) {
            b.push(Ext.get(f))
        });
        return this
    },
    first: function() {
        return this.item(0)
    },
    last: function() {
        return this.item(this.getCount() - 1)
    },
    contains: function(a) {
        return this.indexOf(a) != -1
    },
    removeElement: function(d, f) {
        var b = this,
        e = this.elements,
        a;
        Ext.each(d,
        function(g) {
            if ((a = (e[g] || e[g = b.indexOf(g)]))) {
                if (f) {
                    if (a.dom) {
                        a.remove()
                    } else {
                        Ext.removeNode(a)
                    }
                }
                Ext.Array.erase(e, g, 1)
            }
        });
        return this
    }
},
function() {
    var a = Ext.dom.Element,
    e = a.prototype,
    d = this.prototype,
    b;
    for (b in e) {
        if (typeof e[b] == "function") { (function(f) {
                if (f === "destroy") {
                    d[f] = function() {
                        return this.invoke(f, arguments)
                    }
                } else {
                    d[f] = d[f] ||
                    function() {
                        return this.invoke(f, arguments)
                    }
                }
            }).call(d, b)
        }
    }
    d.on = d.addListener;
    a.selectorFunction = Ext.DomQuery.select;
    Ext.dom.Element.select = function(f, i, g) {
        var h;
        if (typeof f == "string") {
            h = Ext.dom.Element.selectorFunction(f, g)
        } else {
            if (f.length !== undefined) {
                h = f
            } else {}
        }
        return (i === true) ? new Ext.dom.CompositeElement(h) : new Ext.dom.CompositeElementLite(h)
    };
    Ext.select = function() {
        return a.select.apply(a, arguments)
    }
});
Ext.define("Ext.event.ListenerStack", {
    currentOrder: "current",
    length: 0,
    constructor: function() {
        this.listeners = {
            before: [],
            current: [],
            after: []
        };
        this.lateBindingMap = {};
        return this
    },
    add: function(j, k, m, f) {
        var a = this.lateBindingMap,
        h = this.getAll(f),
        g = h.length,
        b,
        e,
        d;
        if (typeof j == "string" && k.isIdentifiable) {
            d = k.getId();
            b = a[d];
            if (b) {
                if (b[j]) {
                    return false
                } else {
                    b[j] = true
                }
            } else {
                a[d] = b = {};
                b[j] = true
            }
        } else {
            if (g > 0) {
                while (g--) {
                    e = h[g];
                    if (e.fn === j && e.scope === k) {
                        e.options = m;
                        return false
                    }
                }
            }
        }
        e = this.create(j, k, m, f);
        if (m && m.prepend) {
            delete m.prepend;
            h.unshift(e)
        } else {
            h.push(e)
        }
        this.length++;
        return true
    },
    getAt: function(b, a) {
        return this.getAll(a)[b]
    },
    getAll: function(a) {
        if (!a) {
            a = this.currentOrder
        }
        return this.listeners[a]
    },
    count: function(a) {
        return this.getAll(a).length
    },
    create: function(e, d, b, a) {
        return {
            stack: this,
            fn: e,
            firingFn: false,
            boundFn: false,
            isLateBinding: typeof e == "string",
            scope: d,
            options: b || {},
            order: a
        }
    },
    remove: function(j, k, f) {
        var h = this.getAll(f),
        g = h.length,
        b = false,
        a = this.lateBindingMap,
        e,
        d;
        if (g > 0) {
            while (g--) {
                e = h[g];
                if (e.fn === j && e.scope === k) {
                    h.splice(g, 1);
                    b = true;
                    this.length--;
                    if (typeof j == "string" && k.isIdentifiable) {
                        d = k.getId();
                        if (a[d] && a[d][j]) {
                            delete a[d][j]
                        }
                    }
                    break
                }
            }
        }
        return b
    }
});
Ext.define("Ext.event.Controller", {
    isFiring: false,
    listenerStack: null,
    constructor: function(a) {
        this.firingListeners = [];
        this.firingArguments = [];
        this.setInfo(a);
        return this
    },
    setInfo: function(a) {
        this.info = a
    },
    getInfo: function() {
        return this.info
    },
    setListenerStacks: function(a) {
        this.listenerStacks = a
    },
    fire: function(j, f) {
        var p = this.listenerStacks,
        o = this.firingListeners,
        e = this.firingArguments,
        m = o.push,
        h = p.length,
        k, n, d, q, a = false,
        b = false,
        g;
        o.length = 0;
        if (f) {
            if (f.order !== "after") {
                a = true
            } else {
                b = true
            }
        }
        if (h === 1) {
            k = p[0].listeners;
            n = k.before;
            d = k.current;
            q = k.after;
            if (n.length > 0) {
                m.apply(o, n)
            }
            if (a) {
                m.call(o, f)
            }
            if (d.length > 0) {
                m.apply(o, d)
            }
            if (b) {
                m.call(o, f)
            }
            if (q.length > 0) {
                m.apply(o, q)
            }
        } else {
            for (g = 0; g < h; g++) {
                n = p[g].listeners.before;
                if (n.length > 0) {
                    m.apply(o, n)
                }
            }
            if (a) {
                m.call(o, f)
            }
            for (g = 0; g < h; g++) {
                d = p[g].listeners.current;
                if (d.length > 0) {
                    m.apply(o, d)
                }
            }
            if (b) {
                m.call(o, f)
            }
            for (g = 0; g < h; g++) {
                q = p[g].listeners.after;
                if (q.length > 0) {
                    m.apply(o, q)
                }
            }
        }
        if (o.length === 0) {
            return this
        }
        if (!j) {
            j = []
        }
        e.length = 0;
        e.push.apply(e, j);
        e.push(null, this);
        this.doFire();
        return this
    },
    doFire: function() {
        var m = this.firingListeners,
        d = this.firingArguments,
        h = d.length - 2,
        e, g, b, q, j, p, a, k, n, f, o;
        this.isPausing = false;
        this.isPaused = false;
        this.isStopped = false;
        this.isFiring = true;
        for (e = 0, g = m.length; e < g; e++) {
            b = m[e];
            q = b.options;
            j = b.fn;
            p = b.firingFn;
            a = b.boundFn;
            k = b.isLateBinding;
            n = b.scope;
            if (k && a && a !== n[j]) {
                a = false;
                p = false
            }
            if (!a) {
                if (k) {
                    a = n[j];
                    if (!a) {
                        continue
                    }
                } else {
                    a = j
                }
                b.boundFn = a
            }
            if (!p) {
                p = a;
                if (q.buffer) {
                    p = Ext.Function.createBuffered(p, q.buffer, n)
                }
                if (q.delay) {
                    p = Ext.Function.createDelayed(p, q.delay, n)
                }
                b.firingFn = p
            }
            d[h] = q;
            f = d;
            if (q.args) {
                f = q.args.concat(f)
            }
            if (q.single === true) {
                b.stack.remove(j, n, b.order)
            }
            o = p.apply(n, f);
            if (o === false) {
                this.stop()
            }
            if (this.isStopped) {
                break
            }
            if (this.isPausing) {
                this.isPaused = true;
                m.splice(0, e + 1);
                return
            }
        }
        this.isFiring = false;
        this.listenerStacks = null;
        m.length = 0;
        d.length = 0;
        this.connectingController = null
    },
    connect: function(a) {
        this.connectingController = a
    },
    resume: function() {
        var a = this.connectingController;
        this.isPausing = false;
        if (this.isPaused && this.firingListeners.length > 0) {
            this.isPaused = false;
            this.doFire()
        }
        if (a) {
            a.resume()
        }
        return this
    },
    isInterrupted: function() {
        return this.isStopped || this.isPaused
    },
    stop: function() {
        var a = this.connectingController;
        this.isStopped = true;
        if (a) {
            this.connectingController = null;
            a.stop()
        }
        this.isFiring = false;
        this.listenerStacks = null;
        return this
    },
    pause: function() {
        var a = this.connectingController;
        this.isPausing = true;
        if (a) {
            a.pause()
        }
        return this
    }
});
Ext.define("Ext.event.Dispatcher", {
    statics: {
        getInstance: function() {
            if (!this.instance) {
                this.instance = new this()
            }
            return this.instance
        },
        setInstance: function(a) {
            this.instance = a;
            return this
        }
    },
    config: {
        publishers: {}
    },
    wildcard: "*",
    constructor: function(a) {
        this.listenerStacks = {};
        this.activePublishers = {};
        this.publishersCache = {};
        this.noActivePublishers = [];
        this.controller = null;
        this.initConfig(a);
        return this
    },
    getListenerStack: function(f, h, d, b) {
        var e = this.listenerStacks,
        g = e[f],
        a;
        b = Boolean(b);
        if (!g) {
            if (b) {
                e[f] = g = {}
            } else {
                return null
            }
        }
        g = g[h];
        if (!g) {
            if (b) {
                e[f][h] = g = {}
            } else {
                return null
            }
        }
        a = g[d];
        if (!a) {
            if (b) {
                g[d] = a = new Ext.event.ListenerStack()
            } else {
                return null
            }
        }
        return a
    },
    getController: function(e, g, d, b) {
        var a = this.controller,
        f = {
            targetType: e,
            target: g,
            eventName: d
        };
        if (!a) {
            this.controller = a = new Ext.event.Controller()
        }
        if (a.isFiring) {
            a = new Ext.event.Controller()
        }
        a.setInfo(f);
        if (b && a !== b) {
            a.connect(b)
        }
        return a
    },
    applyPublishers: function(d) {
        var a, b;
        this.publishersCache = {};
        for (a in d) {
            if (d.hasOwnProperty(a)) {
                b = d[a];
                this.registerPublisher(b)
            }
        }
        return d
    },
    registerPublisher: function(b) {
        var a = this.activePublishers,
        d = b.getTargetType(),
        e = a[d];
        if (!e) {
            a[d] = e = []
        }
        e.push(b);
        b.setDispatcher(this);
        return this
    },
    getCachedActivePublishers: function(d, b) {
        var a = this.publishersCache,
        e;
        if ((e = a[d]) && (e = e[b])) {
            return e
        }
        return null
    },
    cacheActivePublishers: function(d, b, e) {
        var a = this.publishersCache;
        if (!a[d]) {
            a[d] = {}
        }
        a[d][b] = e;
        return e
    },
    getActivePublishers: function(g, b) {
        var h, a, d, f, e;
        if ((h = this.getCachedActivePublishers(g, b))) {
            return h
        }
        a = this.activePublishers[g];
        if (a) {
            h = [];
            for (d = 0, f = a.length; d < f; d++) {
                e = a[d];
                if (e.handles(b)) {
                    h.push(e)
                }
            }
        } else {
            h = this.noActivePublishers
        }
        return this.cacheActivePublishers(g, b, h)
    },
    hasListener: function(d, e, b) {
        var a = this.getListenerStack(d, e, b);
        if (a) {
            return a.count() > 0
        }
        return false
    },
    addListener: function(f, g, b) {
        var h = this.getActivePublishers(f, b),
        e = h.length,
        d,
        a;
        a = this.doAddListener.apply(this, arguments);
        if (a && e > 0) {
            for (d = 0; d < e; d++) {
                h[d].subscribe(g, b)
            }
        }
        return a
    },
    doAddListener: function(h, i, d, g, f, e, a) {
        var b = this.getListenerStack(h, i, d, true);
        return b.add(g, f, e, a)
    },
    removeListener: function(f, g, b) {
        var h = this.getActivePublishers(f, b),
        e = h.length,
        d,
        a;
        a = this.doRemoveListener.apply(this, arguments);
        if (a && e > 0) {
            for (d = 0; d < e; d++) {
                h[d].unsubscribe(g, b)
            }
        }
        return a
    },
    doRemoveListener: function(g, h, d, f, e, a) {
        var b = this.getListenerStack(g, h, d);
        if (b === null) {
            return false
        }
        return b.remove(f, e, a)
    },
    clearListeners: function(a, f, e) {
        var k = this.listenerStacks,
        g = arguments.length,
        b, j, d, h;
        if (g === 3) {
            if (k[a] && k[a][f]) {
                this.removeListener(a, f, e);
                delete k[a][f][e]
            }
        } else {
            if (g === 2) {
                if (k[a]) {
                    b = k[a][f];
                    if (b) {
                        for (e in b) {
                            if (b.hasOwnProperty(e)) {
                                j = this.getActivePublishers(a, e);
                                for (d = 0, g = j.length; d < g; d++) {
                                    j[d].unsubscribe(f, e, true)
                                }
                            }
                        }
                        delete k[a][f]
                    }
                }
            } else {
                if (g === 1) {
                    j = this.activePublishers[a];
                    for (d = 0, g = j.length; d < g; d++) {
                        j[d].unsubscribeAll()
                    }
                    delete k[a]
                } else {
                    j = this.activePublishers;
                    for (a in j) {
                        if (j.hasOwnProperty(a)) {
                            h = j[a];
                            for (d = 0, g = h.length; d < g; d++) {
                                h[d].unsubscribeAll()
                            }
                        }
                    }
                    delete this.listenerStacks;
                    this.listenerStacks = {}
                }
            }
        }
        return this
    },
    dispatchEvent: function(e, f, a) {
        var g = this.getActivePublishers(e, a),
        d = g.length,
        b;
        if (d > 0) {
            for (b = 0; b < d; b++) {
                g[b].notify(f, a)
            }
        }
        return this.doDispatchEvent.apply(this, arguments)
    },
    doDispatchEvent: function(a, h, g, j, d, b) {
        var i = this.getListenerStack(a, h, g),
        e = this.getWildcardListenerStacks(a, h, g),
        f;
        if ((i === null || i.length == 0)) {
            if (e.length == 0 && !d) {
                return
            }
        } else {
            e.push(i)
        }
        f = this.getController(a, h, g, b);
        f.setListenerStacks(e);
        f.fire(j, d);
        return ! f.isInterrupted()
    },
    getWildcardListenerStacks: function(h, i, e) {
        var g = [],
        b = this.wildcard,
        d = e !== b,
        f = i !== b,
        a;
        if (d && (a = this.getListenerStack(h, i, b))) {
            g.push(a)
        }
        if (f && (a = this.getListenerStack(h, b, e))) {
            g.push(a)
        }
        return g
    },
    getPublisher: function(a) {
        return this.getPublishers()[a]
    }
});
Ext.define("Ext.mixin.Mixin", {
    onClassExtended: function(b, f) {
        var a = f.mixinConfig,
        e, g, d;
        if (a) {
            e = b.superclass.mixinConfig;
            if (e) {
                a = f.mixinConfig = Ext.merge({},
                e, a)
            }
            f.mixinId = a.id;
            g = a.beforeHooks;
            d = a.hooks || a.afterHooks;
            if (g || d) {
                Ext.Function.interceptBefore(f, "onClassMixedIn",
                function(i) {
                    var h = this.prototype;
                    if (g) {
                        Ext.Object.each(g,
                        function(k, j) {
                            i.override(j,
                            function() {
                                if (h[k].apply(this, arguments) !== false) {
                                    return this.callOverridden(arguments)
                                }
                            })
                        })
                    }
                    if (d) {
                        Ext.Object.each(d,
                        function(k, j) {
                            i.override(j,
                            function() {
                                var m = this.callOverridden(arguments);
                                h[k].apply(this, arguments);
                                return m
                            })
                        })
                    }
                })
            }
        }
    }
});
Ext.define("Ext.mixin.Observable", {
    extend: Ext.mixin.Mixin,
    mixins: [Ext.mixin.Identifiable],
    mixinConfig: {
        id: "observable",
        hooks: {
            destroy: "destroy"
        }
    },
    alternateClassName: "Ext.util.Observable",
    isObservable: true,
    observableType: "observable",
    validIdRegex: /^([\w\-]+)$/,
    observableIdPrefix: "#",
    listenerOptionsRegex: /^(?:delegate|single|delay|buffer|args|prepend)$/,
    eventFiringSuspended: false,
    config: {
        listeners: null,
        bubbleEvents: null
    },
    constructor: function(a) {
        this.initConfig(a)
    },
    applyListeners: function(a) {
        if (a) {
            this.addListener(a)
        }
    },
    applyBubbleEvents: function(a) {
        if (a) {
            this.enableBubble(a)
        }
    },
    getOptimizedObservableId: function() {
        return this.observableId
    },
    getObservableId: function() {
        if (!this.observableId) {
            var a = this.getUniqueId();
            this.observableId = this.observableIdPrefix + a;
            this.getObservableId = this.getOptimizedObservableId
        }
        return this.observableId
    },
    getOptimizedEventDispatcher: function() {
        return this.eventDispatcher
    },
    getEventDispatcher: function() {
        if (!this.eventDispatcher) {
            this.eventDispatcher = Ext.event.Dispatcher.getInstance();
            this.getEventDispatcher = this.getOptimizedEventDispatcher;
            this.getListeners();
            this.getBubbleEvents()
        }
        return this.eventDispatcher
    },
    getManagedListeners: function(d, b) {
        var e = d.getUniqueId(),
        a = this.managedListeners;
        if (!a) {
            this.managedListeners = a = {}
        }
        if (!a[e]) {
            a[e] = {};
            d.doAddListener("destroy", "clearManagedListeners", this, {
                single: true,
                args: [d]
            })
        }
        if (!a[e][b]) {
            a[e][b] = []
        }
        return a[e][b]
    },
    getUsedSelectors: function() {
        var a = this.usedSelectors;
        if (!a) {
            a = this.usedSelectors = [];
            a.$map = {}
        }
        return a
    },
    fireEvent: function(a) {
        var b = Array.prototype.slice.call(arguments, 1);
        return this.doFireEvent(a, b)
    },
    fireAction: function(d, f, h, g, e, a) {
        var b = typeof h,
        i;
        if (f === undefined) {
            f = []
        }
        if (b != "undefined") {
            i = {
                fn: h,
                isLateBinding: b == "string",
                scope: g || this,
                options: e || {},
                order: a
            }
        }
        return this.doFireEvent(d, f, i)
    },
    doFireEvent: function(d, f, h, a) {
        var g = this,
        e = true,
        b;
        if (g.eventFiringSuspended) {
            b = g.eventQueue;
            if (!b) {
                g.eventQueue = b = []
            }
            b.push([d, f, h, a])
        } else {
            e = g.getEventDispatcher().dispatchEvent(g.observableType, g.getObservableId(), d, f, h, a)
        }
        return e
    },
    doAddListener: function(a, j, m, n, d) {
        var f = (m && m !== this && m.isIdentifiable),
        b = this.getUsedSelectors(),
        g = b.$map,
        e = this.getObservableId(),
        h,
        k,
        i;
        if (!n) {
            n = {}
        }
        if (!m) {
            m = this
        }
        if (n.delegate) {
            i = n.delegate;
            e += " " + i
        }
        if (! (e in g)) {
            g[e] = true;
            b.push(e)
        }
        h = this.addDispatcherListener(e, a, j, m, n, d);
        if (h && f) {
            k = this.getManagedListeners(m, a);
            k.push({
                delegate: i,
                scope: m,
                fn: j,
                order: d
            })
        }
        return h
    },
    addDispatcherListener: function(b, e, g, f, d, a) {
        return this.getEventDispatcher().addListener(this.observableType, b, e, g, f, d, a)
    },
    doRemoveListener: function(b, m, o, p, e) {
        var h = (o && o !== this && o.isIdentifiable),
        f = this.getObservableId(),
        a,
        n,
        g,
        j,
        d,
        k;
        if (p && p.delegate) {
            k = p.delegate;
            f += " " + k
        }
        if (!o) {
            o = this
        }
        a = this.removeDispatcherListener(f, b, m, o, e);
        if (a && h) {
            n = this.getManagedListeners(o, b);
            for (g = 0, j = n.length; g < j; g++) {
                d = n[g];
                if (d.fn === m && d.scope === o && d.delegate === k && d.order === e) {
                    n.splice(g, 1);
                    break
                }
            }
        }
        return a
    },
    removeDispatcherListener: function(b, d, f, e, a) {
        return this.getEventDispatcher().removeListener(this.observableType, b, d, f, e, a)
    },
    clearManagedListeners: function(e) {
        var k = this.managedListeners,
        a, d, j, g, f, h, b, m;
        if (!k) {
            return this
        }
        if (e) {
            if (typeof e != "string") {
                a = e.getUniqueId()
            } else {
                a = e
            }
            d = k[a];
            for (g in d) {
                if (d.hasOwnProperty(g)) {
                    j = d[g];
                    for (f = 0, h = j.length; f < h; f++) {
                        b = j[f];
                        m = {};
                        if (b.delegate) {
                            m.delegate = b.delegate
                        }
                        if (this.doRemoveListener(g, b.fn, b.scope, m, b.order)) {
                            f--;
                            h--
                        }
                    }
                }
            }
            delete k[a];
            return this
        }
        for (a in k) {
            if (k.hasOwnProperty(a)) {
                this.clearManagedListeners(a)
            }
        }
    },
    changeListener: function(n, j, p, r, s, e) {
        var b, o, h, k, a, q, g, m, d, f;
        if (typeof p != "undefined") {
            if (typeof j != "string") {
                for (g = 0, m = j.length; g < m; g++) {
                    a = j[g];
                    n.call(this, a, p, r, s, e)
                }
                return this
            }
            n.call(this, j, p, r, s, e)
        } else {
            if (Ext.isArray(j)) {
                o = j;
                for (g = 0, m = o.length; g < m; g++) {
                    d = o[g];
                    n.call(this, d.event, d.fn, d.scope, d, d.order)
                }
            } else {
                h = this.listenerOptionsRegex;
                s = j;
                b = [];
                o = [];
                k = {};
                for (a in s) {
                    q = s[a];
                    if (a === "scope") {
                        r = q;
                        continue
                    } else {
                        if (a === "order") {
                            e = q;
                            continue
                        }
                    }
                    if (!h.test(a)) {
                        f = typeof q;
                        if (f != "string" && f != "function") {
                            n.call(this, a, q.fn, q.scope || r, q, q.order || e);
                            continue
                        }
                        b.push(a);
                        o.push(q)
                    } else {
                        k[a] = q
                    }
                }
                for (g = 0, m = b.length; g < m; g++) {
                    n.call(this, b[g], o[g], r, k, e)
                }
            }
        }
        return this
    },
    addListener: function(b, f, e, d, a) {
        return this.changeListener(this.doAddListener, b, f, e, d, a)
    },
    toggleListener: function(b, d, g, f, e, a) {
        return this.changeListener(b ? this.doAddListener: this.doRemoveListener, d, g, f, e, a)
    },
    addBeforeListener: function(a, e, d, b) {
        return this.addListener(a, e, d, b, "before")
    },
    addAfterListener: function(a, e, d, b) {
        return this.addListener(a, e, d, b, "after")
    },
    removeListener: function(b, f, e, d, a) {
        return this.changeListener(this.doRemoveListener, b, f, e, d, a)
    },
    removeBeforeListener: function(a, e, d, b) {
        return this.removeListener(a, e, d, b, "before")
    },
    removeAfterListener: function(a, e, d, b) {
        return this.removeListener(a, e, d, b, "after")
    },
    clearListeners: function() {
        var f = this.getUsedSelectors(),
        d = this.getEventDispatcher(),
        b,
        e,
        a;
        for (b = 0, e = f.length; b < e; b++) {
            a = f[b];
            d.clearListeners(this.observableType, a)
        }
    },
    hasListener: function(a) {
        return this.getEventDispatcher().hasListener(this.observableType, this.getObservableId(), a)
    },
    suspendEvents: function() {
        this.eventFiringSuspended = true
    },
    resumeEvents: function(f) {
        var e = this,
        a = e.eventQueue || [],
        b,
        d;
        e.eventFiringSuspended = false;
        if (!f) {
            for (b = 0, d = a.length; b < d; b++) {
                e.doFireEvent.apply(e, a[b])
            }
        }
        e.eventQueue = []
    },
    relayEvents: function(b, e, h) {
        var d, g, f, a;
        if (typeof h == "undefined") {
            h = ""
        }
        if (typeof e == "string") {
            e = [e]
        }
        if (Ext.isArray(e)) {
            for (d = 0, g = e.length; d < g; d++) {
                f = e[d];
                a = h + f;
                b.addListener(f, this.createEventRelayer(a), this)
            }
        } else {
            for (f in e) {
                if (e.hasOwnProperty(f)) {
                    a = h + e[f];
                    b.addListener(f, this.createEventRelayer(a), this)
                }
            }
        }
        return this
    },
    relayEvent: function(f, g, i, j, a) {
        var h = typeof g,
        d = f[f.length - 1],
        e = d.getInfo().eventName,
        b;
        f = Array.prototype.slice.call(f, 0, -2);
        f[0] = this;
        if (h != "undefined") {
            b = {
                fn: g,
                scope: i || this,
                options: j || {},
                order: a,
                isLateBinding: h == "string"
            }
        }
        return this.doFireEvent(e, f, b, d)
    },
    createEventRelayer: function(a) {
        return function() {
            return this.doFireEvent(a, Array.prototype.slice.call(arguments, 0, -2))
        }
    },
    enableBubble: function(e) {
        var a = this.isBubblingEnabled,
        d, f, b;
        if (!a) {
            a = this.isBubblingEnabled = {}
        }
        if (typeof e == "string") {
            e = Ext.Array.clone(arguments)
        }
        for (d = 0, f = e.length; d < f; d++) {
            b = e[d];
            if (!a[b]) {
                a[b] = true;
                this.addListener(b, this.createEventBubbler(b), this)
            }
        }
    },
    createEventBubbler: function(a) {
        return function b() {
            var d = ("getBubbleTarget" in this) ? this.getBubbleTarget() : null;
            if (d && d !== this && d.isObservable) {
                d.fireAction(a, Array.prototype.slice.call(arguments, 0, -2), b, d, null, "after")
            }
        }
    },
    getBubbleTarget: function() {
        return false
    },
    destroy: function() {
        if (this.observableId) {
            this.fireEvent("destroy", this);
            this.clearListeners();
            this.clearManagedListeners()
        }
    },
    addEvents: Ext.emptyFn
},
function() {
    this.createAlias({
        on: "addListener",
        un: "removeListener",
        onBefore: "addBeforeListener",
        onAfter: "addAfterListener",
        unBefore: "removeBeforeListener",
        unAfter: "removeAfterListener"
    })
});
Ext.define("Ext.Evented", {
    alternateClassName: "Ext.EventedBase",
    mixins: [Ext.mixin.Observable],
    statics: {
        generateSetter: function(f) {
            var d = f.internal,
            b = f.apply,
            a = f.changeEvent,
            e = f.doSet;
            return function(i) {
                var j = this.initialized,
                h = this[d],
                g = this[b];
                if (g) {
                    i = g.call(this, i, h);
                    if (typeof i == "undefined") {
                        return this
                    }
                }
                h = this[d];
                if (i !== h) {
                    if (j) {
                        this.fireAction(a, [this, i, h], this.doSet, this, {
                            nameMap: f
                        })
                    } else {
                        this[d] = i;
                        if (this[e]) {
                            this[e].call(this, i, h)
                        }
                    }
                }
                return this
            }
        }
    },
    initialized: false,
    constructor: function(a) {
        this.initialConfig = a;
        this.initialize()
    },
    initialize: function() {
        this.initConfig(this.initialConfig);
        this.initialized = true
    },
    doSet: function(d, e, b, a) {
        var f = a.nameMap;
        d[f.internal] = e;
        if (d[f.doSet]) {
            d[f.doSet].call(this, e, b)
        }
    },
    onClassExtended: function(a, f) {
        if (!f.hasOwnProperty("eventedConfig")) {
            return
        }
        var e = Ext.Class,
        d = f.config,
        h = f.eventedConfig,
        b, g;
        f.config = (d) ? Ext.applyIf(d, h) : h;
        for (b in h) {
            if (h.hasOwnProperty(b)) {
                g = e.getConfigNameMap(b);
                f[g.set] = this.generateSetter(g)
            }
        }
    }
});
Ext.define("Ext.AbstractComponent", {
    extend: Ext.Evented,
    onClassExtended: function(b, g) {
        if (!g.hasOwnProperty("cachedConfig")) {
            return
        }
        var h = b.prototype,
        d = g.config,
        f = g.cachedConfig,
        e = h.cachedConfigList,
        j = h.hasCachedConfig,
        a, i;
        delete g.cachedConfig;
        h.cachedConfigList = e = (e) ? e.slice() : [];
        h.hasCachedConfig = j = (j) ? Ext.Object.chain(j) : {};
        if (!d) {
            g.config = d = {}
        }
        for (a in f) {
            if (f.hasOwnProperty(a)) {
                i = f[a];
                if (!j[a]) {
                    j[a] = true;
                    e.push(a)
                }
                d[a] = i
            }
        }
    },
    getElementConfig: Ext.emptyFn,
    referenceAttributeName: "reference",
    referenceSelector: "[reference]",
    addReferenceNode: function(a, b) {
        Ext.Object.defineProperty(this, a, {
            get: function() {
                var d;
                delete this[a];
                this[a] = d = new Ext.Element(b);
                return d
            },
            configurable: true
        })
    },
    initElement: function() {
        var m = this.self.prototype,
        p = this.getId(),
        u = [],
        h = true,
        B = this.referenceAttributeName,
        r = false,
        f,
        z,
        b,
        q,
        v,
        e,
        n,
        d,
        g,
        k,
        A,
        o,
        a,
        s,
        j,
        C,
        y,
        t;
        if (m.hasOwnProperty("renderTemplate")) {
            f = this.renderTemplate.cloneNode(true);
            z = f.firstChild
        } else {
            h = false;
            r = true;
            f = document.createDocumentFragment();
            z = Ext.Element.create(this.getElementConfig(), true);
            f.appendChild(z)
        }
        q = f.querySelectorAll(this.referenceSelector);
        for (v = 0, e = q.length; v < e; v++) {
            n = q[v];
            d = n.getAttribute(B);
            if (h) {
                n.removeAttribute(B)
            }
            if (d == "element") {
                n.id = p;
                this.element = b = new Ext.Element(n)
            } else {
                this.addReferenceNode(d, n)
            }
            u.push(d)
        }
        this.referenceList = u;
        if (!this.innerElement) {
            this.innerElement = b
        }
        if (!this.bodyElement) {
            this.bodyElement = this.innerElement
        }
        if (z === b.dom) {
            this.renderElement = b
        } else {
            this.addReferenceNode("renderElement", z)
        }
        if (r) {
            g = Ext.Class.configNameCache;
            k = this.config;
            A = this.cachedConfigList;
            o = this.initConfigList;
            a = this.initConfigMap;
            s = [];
            for (v = 0, e = A.length; v < e; v++) {
                C = A[v];
                y = g[C];
                if (a[C]) {
                    a[C] = false;
                    Ext.Array.remove(o, C)
                }
                if (k[C] !== null) {
                    s.push(C);
                    this[y.get] = this[y.initGet]
                }
            }
            for (v = 0, e = s.length; v < e; v++) {
                C = s[v];
                y = g[C];
                t = y.internal;
                this[t] = null;
                this[y.set].call(this, k[C]);
                delete this[y.get];
                m[t] = this[t]
            }
            z = this.renderElement.dom;
            m.renderTemplate = f = document.createDocumentFragment();
            f.appendChild(z.cloneNode(true));
            j = f.querySelectorAll("[id]");
            for (v = 0, e = j.length; v < e; v++) {
                b = j[v];
                b.removeAttribute("id")
            }
            for (v = 0, e = u.length; v < e; v++) {
                d = u[v];
                this[d].dom.removeAttribute("reference")
            }
        }
        return this
    }
});
Ext.define("Ext.util.HashMap", {
    mixins: {
        observable: Ext.mixin.Observable
    },
    constructor: function(a) {
        this.callParent();
        this.mixins.observable.constructor.call(this);
        this.clear(true)
    },
    getCount: function() {
        return this.length
    },
    getData: function(a, b) {
        if (b === undefined) {
            b = a;
            a = this.getKey(b)
        }
        return [a, b]
    },
    getKey: function(a) {
        return a.id
    },
    add: function(a, e) {
        var b = this,
        d;
        if (b.containsKey(a)) {
            throw new Error("This key already exists in the HashMap")
        }
        d = this.getData(a, e);
        a = d[0];
        e = d[1];
        b.map[a] = e; ++b.length;
        b.fireEvent("add", b, a, e);
        return e
    },
    replace: function(b, e) {
        var d = this,
        f = d.map,
        a;
        if (!d.containsKey(b)) {
            d.add(b, e)
        }
        a = f[b];
        f[b] = e;
        d.fireEvent("replace", d, b, e, a);
        return e
    },
    remove: function(b) {
        var a = this.findKey(b);
        if (a !== undefined) {
            return this.removeByKey(a)
        }
        return false
    },
    removeByKey: function(a) {
        var b = this,
        d;
        if (b.containsKey(a)) {
            d = b.map[a];
            delete b.map[a]; --b.length;
            b.fireEvent("remove", b, a, d);
            return true
        }
        return false
    },
    get: function(a) {
        return this.map[a]
    },
    clear: function(a) {
        var b = this;
        b.map = {};
        b.length = 0;
        if (a !== true) {
            b.fireEvent("clear", b)
        }
        return b
    },
    containsKey: function(a) {
        return this.map[a] !== undefined
    },
    contains: function(a) {
        return this.containsKey(this.findKey(a))
    },
    getKeys: function() {
        return this.getArray(true)
    },
    getValues: function() {
        return this.getArray(false)
    },
    getArray: function(e) {
        var a = [],
        b,
        d = this.map;
        for (b in d) {
            if (d.hasOwnProperty(b)) {
                a.push(e ? b: d[b])
            }
        }
        return a
    },
    each: function(e, d) {
        var a = Ext.apply({},
        this.map),
        b,
        f = this.length;
        d = d || this;
        for (b in a) {
            if (a.hasOwnProperty(b)) {
                if (e.call(d, b, a[b], f) === false) {
                    break
                }
            }
        }
        return this
    },
    clone: function() {
        var d = new Ext.util.HashMap(),
        b = this.map,
        a;
        d.suspendEvents();
        for (a in b) {
            if (b.hasOwnProperty(a)) {
                d.add(a, b[a])
            }
        }
        d.resumeEvents();
        return d
    },
    findKey: function(b) {
        var a, d = this.map;
        for (a in d) {
            if (d.hasOwnProperty(a) && d[a] === b) {
                return a
            }
        }
        return undefined
    }
});
Ext.define("Ext.AbstractManager", {
    typeName: "type",
    constructor: function(a) {
        Ext.apply(this, a || {});
        this.all = Ext.create("Ext.util.HashMap");
        this.types = {}
    },
    get: function(a) {
        return this.all.get(a)
    },
    register: function(a) {
        this.all.add(a)
    },
    unregister: function(a) {
        this.all.remove(a)
    },
    registerType: function(b, a) {
        this.types[b] = a;
        a[this.typeName] = b
    },
    isRegistered: function(a) {
        return this.types[a] !== undefined
    },
    create: function(a, e) {
        var b = a[this.typeName] || a.type || e,
        d = this.types[b];
        return new d(a)
    },
    onAvailable: function(f, d, b) {
        var a = this.all,
        e;
        if (a.containsKey(f)) {
            e = a.get(f);
            d.call(b || e, e)
        } else {
            a.on("add",
            function(i, g, h) {
                if (g == f) {
                    d.call(b || h, h);
                    a.un("add", d, b)
                }
            })
        }
    },
    each: function(b, a) {
        this.all.each(b, a || this)
    },
    getCount: function() {
        return this.all.getCount()
    }
});
Ext.define("Ext.mixin.Traversable", {
    extend: Ext.mixin.Mixin,
    mixinConfig: {
        id: "traversable"
    },
    setParent: function(a) {
        this.parent = a;
        return this
    },
    hasParent: function() {
        return Boolean(this.parent)
    },
    getParent: function() {
        return this.parent
    },
    getAncestors: function() {
        var b = [],
        a = this.getParent();
        while (a) {
            b.push(a);
            a = a.getParent()
        }
        return b
    },
    getAncestorIds: function() {
        var b = [],
        a = this.getParent();
        while (a) {
            b.push(a.getId());
            a = a.getParent()
        }
        return b
    }
});
Ext.define("Ext.ComponentManager", {
    alternateClassName: "Ext.ComponentMgr",
    singleton: true,
    constructor: function() {
        var a = {};
        this.all = {
            map: a,
            getArray: function() {
                var b = [],
                d;
                for (d in a) {
                    if (a.hasOwnProperty(d)) {
                        b.push(a[d])
                    }
                }
                return b
            }
        };
        this.map = a
    },
    register: function(a) {
        var b = a.getId();
        this.map[a.getId()] = a
    },
    unregister: function(a) {
        delete this.map[a.getId()]
    },
    isRegistered: function(a) {
        return this.map[a] !== undefined
    },
    get: function(a) {
        return this.map[a]
    },
    create: function(a, d) {
        if (a.isComponent) {
            return a
        } else {
            if (Ext.isString(a)) {
                return Ext.createByAlias("widget." + a)
            } else {
                var b = a.xtype || d;
                return Ext.createByAlias("widget." + b, a)
            }
        }
    },
    registerType: Ext.emptyFn
}); (function() {
    function b(e) {
        var d = Array.prototype.slice.call(arguments, 1);
        return e.replace(/\{(\d+)\}/g,
        function(f, g) {
            return d[g]
        })
    }
    Ext.DateExtras = {
        now: Date.now ||
        function() {
            return + new Date()
        },
        getElapsed: function(e, d) {
            return Math.abs(e - (d || new Date()))
        },
        useStrict: false,
        formatCodeToRegex: function(e, d) {
            var f = a.parseCodes[e];
            if (f) {
                f = typeof f == "function" ? f() : f;
                a.parseCodes[e] = f
            }
            return f ? Ext.applyIf({
                c: f.c ? b(f.c, d || "{0}") : f.c
            },
            f) : {
                g: 0,
                c: null,
                s: Ext.String.escapeRegex(e)
            }
        },
        parseFunctions: {
            MS: function(e, d) {
                var f = new RegExp("\\\\?/Date\\(([-+])?(\\d+)(?:[+-]\\d{4})?\\)\\\\?/");
                var g = (e || "").match(f);
                return g ? new Date(((g[1] || "") + g[2]) * 1) : null
            }
        },
        parseRegexes: [],
        formatFunctions: {
            MS: function() {
                return "\\/Date(" + this.getTime() + ")\\/"
            }
        },
        y2kYear: 50,
        MILLI: "ms",
        SECOND: "s",
        MINUTE: "mi",
        HOUR: "h",
        DAY: "d",
        MONTH: "mo",
        YEAR: "y",
        defaults: {},
        dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        monthNumbers: {
            Jan: 0,
            Feb: 1,
            Mar: 2,
            Apr: 3,
            May: 4,
            Jun: 5,
            Jul: 6,
            Aug: 7,
            Sep: 8,
            Oct: 9,
            Nov: 10,
            Dec: 11
        },
        defaultFormat: "m/d/Y",
        getShortMonthName: function(d) {
            return a.monthNames[d].substring(0, 3)
        },
        getShortDayName: function(d) {
            return a.dayNames[d].substring(0, 3)
        },
        getMonthNumber: function(d) {
            return a.monthNumbers[d.substring(0, 1).toUpperCase() + d.substring(1, 3).toLowerCase()]
        },
        formatCodes: {
            d: "Ext.String.leftPad(this.getDate(), 2, '0')",
            D: "Ext.Date.getShortDayName(this.getDay())",
            j: "this.getDate()",
            l: "Ext.Date.dayNames[this.getDay()]",
            N: "(this.getDay() ? this.getDay() : 7)",
            S: "Ext.Date.getSuffix(this)",
            w: "this.getDay()",
            z: "Ext.Date.getDayOfYear(this)",
            W: "Ext.String.leftPad(Ext.Date.getWeekOfYear(this), 2, '0')",
            F: "Ext.Date.monthNames[this.getMonth()]",
            m: "Ext.String.leftPad(this.getMonth() + 1, 2, '0')",
            M: "Ext.Date.getShortMonthName(this.getMonth())",
            n: "(this.getMonth() + 1)",
            t: "Ext.Date.getDaysInMonth(this)",
            L: "(Ext.Date.isLeapYear(this) ? 1 : 0)",
            o: "(this.getFullYear() + (Ext.Date.getWeekOfYear(this) == 1 && this.getMonth() > 0 ? +1 : (Ext.Date.getWeekOfYear(this) >= 52 && this.getMonth() < 11 ? -1 : 0)))",
            Y: "Ext.String.leftPad(this.getFullYear(), 4, '0')",
            y: "('' + this.getFullYear()).substring(2, 4)",
            a: "(this.getHours() < 12 ? 'am' : 'pm')",
            A: "(this.getHours() < 12 ? 'AM' : 'PM')",
            g: "((this.getHours() % 12) ? this.getHours() % 12 : 12)",
            G: "this.getHours()",
            h: "Ext.String.leftPad((this.getHours() % 12) ? this.getHours() % 12 : 12, 2, '0')",
            H: "Ext.String.leftPad(this.getHours(), 2, '0')",
            i: "Ext.String.leftPad(this.getMinutes(), 2, '0')",
            s: "Ext.String.leftPad(this.getSeconds(), 2, '0')",
            u: "Ext.String.leftPad(this.getMilliseconds(), 3, '0')",
            O: "Ext.Date.getGMTOffset(this)",
            P: "Ext.Date.getGMTOffset(this, true)",
            T: "Ext.Date.getTimezone(this)",
            Z: "(this.getTimezoneOffset() * -60)",
            c: function() {
                for (var j = "Y-m-dTH:i:sP",
                g = [], f = 0, d = j.length; f < d; ++f) {
                    var h = j.charAt(f);
                    g.push(h == "T" ? "'T'": a.getFormatCode(h))
                }
                return g.join(" + ")
            },
            U: "Math.round(this.getTime() / 1000)"
        },
        isValid: function(p, e, o, k, g, j, f) {
            k = k || 0;
            g = g || 0;
            j = j || 0;
            f = f || 0;
            var n = a.add(new Date(p < 100 ? 100 : p, e - 1, o, k, g, j, f), a.YEAR, p < 100 ? p - 100 : 0);
            return p == n.getFullYear() && e == n.getMonth() + 1 && o == n.getDate() && k == n.getHours() && g == n.getMinutes() && j == n.getSeconds() && f == n.getMilliseconds()
        },
        parse: function(e, g, d) {
            var f = a.parseFunctions;
            if (f[g] == null) {
                a.createParser(g)
            }
            return f[g](e, Ext.isDefined(d) ? d: a.useStrict)
        },
        parseDate: function(e, f, d) {
            return a.parse(e, f, d)
        },
        getFormatCode: function(e) {
            var d = a.formatCodes[e];
            if (d) {
                d = typeof d == "function" ? d() : d;
                a.formatCodes[e] = d
            }
            return d || ("'" + Ext.String.escape(e) + "'")
        },
        createFormat: function(h) {
            var g = [],
            d = false,
            f = "";
            for (var e = 0; e < h.length; ++e) {
                f = h.charAt(e);
                if (!d && f == "\\") {
                    d = true
                } else {
                    if (d) {
                        d = false;
                        g.push("'" + Ext.String.escape(f) + "'")
                    } else {
                        if (f == "\n") {
                            g.push(Ext.JSON.encode(f))
                        } else {
                            g.push(a.getFormatCode(f))
                        }
                    }
                }
            }
            a.formatFunctions[h] = Ext.functionFactory("return " + g.join("+"))
        },
        createParser: (function() {
            var d = ["var dt, y, m, d, h, i, s, ms, o, z, zz, u, v,", "def = Ext.Date.defaults,", "results = String(input).match(Ext.Date.parseRegexes[{0}]);", "if(results){", "{1}", "if(u != null){", "v = new Date(u * 1000);", "}else{", "dt = Ext.Date.clearTime(new Date);", "y = Ext.Number.from(y, Ext.Number.from(def.y, dt.getFullYear()));", "m = Ext.Number.from(m, Ext.Number.from(def.m - 1, dt.getMonth()));", "d = Ext.Number.from(d, Ext.Number.from(def.d, dt.getDate()));", "h  = Ext.Number.from(h, Ext.Number.from(def.h, dt.getHours()));", "i  = Ext.Number.from(i, Ext.Number.from(def.i, dt.getMinutes()));", "s  = Ext.Number.from(s, Ext.Number.from(def.s, dt.getSeconds()));", "ms = Ext.Number.from(ms, Ext.Number.from(def.ms, dt.getMilliseconds()));", "if(z >= 0 && y >= 0){", "v = Ext.Date.add(new Date(y < 100 ? 100 : y, 0, 1, h, i, s, ms), Ext.Date.YEAR, y < 100 ? y - 100 : 0);", "v = !strict? v : (strict === true && (z <= 364 || (Ext.Date.isLeapYear(v) && z <= 365))? Ext.Date.add(v, Ext.Date.DAY, z) : null);", "}else if(strict === true && !Ext.Date.isValid(y, m + 1, d, h, i, s, ms)){", "v = null;", "}else{", "v = Ext.Date.add(new Date(y < 100 ? 100 : y, m, d, h, i, s, ms), Ext.Date.YEAR, y < 100 ? y - 100 : 0);", "}", "}", "}", "if(v){", "if(zz != null){", "v = Ext.Date.add(v, Ext.Date.SECOND, -v.getTimezoneOffset() * 60 - zz);", "}else if(o){", "v = Ext.Date.add(v, Ext.Date.MINUTE, -v.getTimezoneOffset() + (sn == '+'? -1 : 1) * (hr * 60 + mn));", "}", "}", "return v;"].join("\n");
            return function(n) {
                var f = a.parseRegexes.length,
                o = 1,
                g = [],
                m = [],
                k = false,
                e = "";
                for (var j = 0; j < n.length; ++j) {
                    e = n.charAt(j);
                    if (!k && e == "\\") {
                        k = true
                    } else {
                        if (k) {
                            k = false;
                            m.push(Ext.String.escape(e))
                        } else {
                            var h = a.formatCodeToRegex(e, o);
                            o += h.g;
                            m.push(h.s);
                            if (h.g && h.c) {
                                g.push(h.c)
                            }
                        }
                    }
                }
                a.parseRegexes[f] = new RegExp("^" + m.join("") + "$", "i");
                a.parseFunctions[n] = Ext.functionFactory("input", "strict", b(d, f, g.join("")))
            }
        })(),
        parseCodes: {
            d: {
                g: 1,
                c: "d = parseInt(results[{0}], 10);\n",
                s: "(\\d{2})"
            },
            j: {
                g: 1,
                c: "d = parseInt(results[{0}], 10);\n",
                s: "(\\d{1,2})"
            },
            D: function() {
                for (var d = [], e = 0; e < 7; d.push(a.getShortDayName(e)), ++e) {}
                return {
                    g: 0,
                    c: null,
                    s: "(?:" + d.join("|") + ")"
                }
            },
            l: function() {
                return {
                    g: 0,
                    c: null,
                    s: "(?:" + a.dayNames.join("|") + ")"
                }
            },
            N: {
                g: 0,
                c: null,
                s: "[1-7]"
            },
            S: {
                g: 0,
                c: null,
                s: "(?:st|nd|rd|th)"
            },
            w: {
                g: 0,
                c: null,
                s: "[0-6]"
            },
            z: {
                g: 1,
                c: "z = parseInt(results[{0}], 10);\n",
                s: "(\\d{1,3})"
            },
            W: {
                g: 0,
                c: null,
                s: "(?:\\d{2})"
            },
            F: function() {
                return {
                    g: 1,
                    c: "m = parseInt(Ext.Date.getMonthNumber(results[{0}]), 10);\n",
                    s: "(" + a.monthNames.join("|") + ")"
                }
            },
            M: function() {
                for (var d = [], e = 0; e < 12; d.push(a.getShortMonthName(e)), ++e) {}
                return Ext.applyIf({
                    s: "(" + d.join("|") + ")"
                },
                a.formatCodeToRegex("F"))
            },
            m: {
                g: 1,
                c: "m = parseInt(results[{0}], 10) - 1;\n",
                s: "(\\d{2})"
            },
            n: {
                g: 1,
                c: "m = parseInt(results[{0}], 10) - 1;\n",
                s: "(\\d{1,2})"
            },
            t: {
                g: 0,
                c: null,
                s: "(?:\\d{2})"
            },
            L: {
                g: 0,
                c: null,
                s: "(?:1|0)"
            },
            o: function() {
                return a.formatCodeToRegex("Y")
            },
            Y: {
                g: 1,
                c: "y = parseInt(results[{0}], 10);\n",
                s: "(\\d{4})"
            },
            y: {
                g: 1,
                c: "var ty = parseInt(results[{0}], 10);\ny = ty > Ext.Date.y2kYear ? 1900 + ty : 2000 + ty;\n",
                s: "(\\d{1,2})"
            },
            a: {
                g: 1,
                c: "if (/(am)/i.test(results[{0}])) {\nif (!h || h == 12) { h = 0; }\n} else { if (!h || h < 12) { h = (h || 0) + 12; }}",
                s: "(am|pm|AM|PM)"
            },
            A: {
                g: 1,
                c: "if (/(am)/i.test(results[{0}])) {\nif (!h || h == 12) { h = 0; }\n} else { if (!h || h < 12) { h = (h || 0) + 12; }}",
                s: "(AM|PM|am|pm)"
            },
            g: function() {
                return a.formatCodeToRegex("G")
            },
            G: {
                g: 1,
                c: "h = parseInt(results[{0}], 10);\n",
                s: "(\\d{1,2})"
            },
            h: function() {
                return a.formatCodeToRegex("H")
            },
            H: {
                g: 1,
                c: "h = parseInt(results[{0}], 10);\n",
                s: "(\\d{2})"
            },
            i: {
                g: 1,
                c: "i = parseInt(results[{0}], 10);\n",
                s: "(\\d{2})"
            },
            s: {
                g: 1,
                c: "s = parseInt(results[{0}], 10);\n",
                s: "(\\d{2})"
            },
            u: {
                g: 1,
                c: "ms = results[{0}]; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n",
                s: "(\\d+)"
            },
            O: {
                g: 1,
                c: ["o = results[{0}];", "var sn = o.substring(0,1),", "hr = o.substring(1,3)*1 + Math.floor(o.substring(3,5) / 60),", "mn = o.substring(3,5) % 60;", "o = ((-12 <= (hr*60 + mn)/60) && ((hr*60 + mn)/60 <= 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n"].join("\n"),
                s: "([+-]\\d{4})"
            },
            P: {
                g: 1,
                c: ["o = results[{0}];", "var sn = o.substring(0,1),", "hr = o.substring(1,3)*1 + Math.floor(o.substring(4,6) / 60),", "mn = o.substring(4,6) % 60;", "o = ((-12 <= (hr*60 + mn)/60) && ((hr*60 + mn)/60 <= 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n"].join("\n"),
                s: "([+-]\\d{2}:\\d{2})"
            },
            T: {
                g: 0,
                c: null,
                s: "[A-Z]{1,4}"
            },
            Z: {
                g: 1,
                c: "zz = results[{0}] * 1;\nzz = (-43200 <= zz && zz <= 50400)? zz : null;\n",
                s: "([+-]?\\d{1,5})"
            },
            c: function() {
                var f = [],
                d = [a.formatCodeToRegex("Y", 1), a.formatCodeToRegex("m", 2), a.formatCodeToRegex("d", 3), a.formatCodeToRegex("h", 4), a.formatCodeToRegex("i", 5), a.formatCodeToRegex("s", 6), {
                    c: "ms = results[7] || '0'; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n"
                },
                {
                    c: ["if(results[8]) {", "if(results[8] == 'Z'){", "zz = 0;", "}else if (results[8].indexOf(':') > -1){", a.formatCodeToRegex("P", 8).c, "}else{", a.formatCodeToRegex("O", 8).c, "}", "}"].join("\n")
                }];
                for (var g = 0,
                e = d.length; g < e; ++g) {
                    f.push(d[g].c)
                }
                return {
                    g: 1,
                    c: f.join(""),
                    s: [d[0].s, "(?:", "-", d[1].s, "(?:", "-", d[2].s, "(?:", "(?:T| )?", d[3].s, ":", d[4].s, "(?::", d[5].s, ")?", "(?:(?:\\.|,)(\\d+))?", "(Z|(?:[-+]\\d{2}(?::)?\\d{2}))?", ")?", ")?", ")?"].join("")
                }
            },
            U: {
                g: 1,
                c: "u = parseInt(results[{0}], 10);\n",
                s: "(-?\\d+)"
            }
        },
        dateFormat: function(d, e) {
            return a.format(d, e)
        },
        format: function(e, f) {
            if (a.formatFunctions[f] == null) {
                a.createFormat(f)
            }
            var d = a.formatFunctions[f].call(e);
            return d + ""
        },
        getTimezone: function(d) {
            return d.toString().replace(/^.* (?:\((.*)\)|([A-Z]{1,4})(?:[\-+][0-9]{4})?(?: -?\d+)?)$/, "$1$2").replace(/[^A-Z]/g, "")
        },
        getGMTOffset: function(d, e) {
            var f = d.getTimezoneOffset();
            return (f > 0 ? "-": "+") + Ext.String.leftPad(Math.floor(Math.abs(f) / 60), 2, "0") + (e ? ":": "") + Ext.String.leftPad(Math.abs(f % 60), 2, "0")
        },
        getDayOfYear: function(g) {
            var f = 0,
            j = Ext.Date.clone(g),
            e = g.getMonth(),
            h;
            for (h = 0, j.setDate(1), j.setMonth(0); h < e; j.setMonth(++h)) {
                f += a.getDaysInMonth(j)
            }
            return f + g.getDate() - 1
        },
        getWeekOfYear: (function() {
            var d = 86400000,
            e = 7 * d;
            return function(g) {
                var h = Date.UTC(g.getFullYear(), g.getMonth(), g.getDate() + 3) / d,
                f = Math.floor(h / 7),
                i = new Date(f * e).getUTCFullYear();
                return f - Math.floor(Date.UTC(i, 0, 7) / e) + 1
            }
        })(),
        isLeapYear: function(d) {
            var e = d.getFullYear();
            return !! ((e & 3) == 0 && (e % 100 || (e % 400 == 0 && e)))
        },
        getFirstDayOfMonth: function(e) {
            var d = (e.getDay() - (e.getDate() - 1)) % 7;
            return (d < 0) ? (d + 7) : d
        },
        getLastDayOfMonth: function(d) {
            return a.getLastDateOfMonth(d).getDay()
        },
        getFirstDateOfMonth: function(d) {
            return new Date(d.getFullYear(), d.getMonth(), 1)
        },
        getLastDateOfMonth: function(d) {
            return new Date(d.getFullYear(), d.getMonth(), a.getDaysInMonth(d))
        },
        getDaysInMonth: (function() {
            var d = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            return function(f) {
                var e = f.getMonth();
                return e == 1 && a.isLeapYear(f) ? 29 : d[e]
            }
        })(),
        getSuffix: function(d) {
            switch (d.getDate()) {
            case 1:
            case 21:
            case 31:
                return "st";
            case 2:
            case 22:
                return "nd";
            case 3:
            case 23:
                return "rd";
            default:
                return "th"
            }
        },
        clone: function(d) {
            return new Date(d.getTime())
        },
        isDST: function(d) {
            return new Date(d.getFullYear(), 0, 1).getTimezoneOffset() != d.getTimezoneOffset()
        },
        clearTime: function(e, i) {
            if (i) {
                return Ext.Date.clearTime(Ext.Date.clone(e))
            }
            var g = e.getDate();
            e.setHours(0);
            e.setMinutes(0);
            e.setSeconds(0);
            e.setMilliseconds(0);
            if (e.getDate() != g) {
                for (var f = 1,
                h = a.add(e, Ext.Date.HOUR, f); h.getDate() != g; f++, h = a.add(e, Ext.Date.HOUR, f)) {}
                e.setDate(g);
                e.setHours(h.getHours())
            }
            return e
        },
        add: function(g, f, h) {
            var i = Ext.Date.clone(g);
            if (!f || h === 0) {
                return i
            }
            switch (f.toLowerCase()) {
            case Ext.Date.MILLI:
                i = new Date(i.valueOf() + h);
                break;
            case Ext.Date.SECOND:
                i = new Date(i.valueOf() + h * 1000);
                break;
            case Ext.Date.MINUTE:
                i = new Date(i.valueOf() + h * 60000);
                break;
            case Ext.Date.HOUR:
                i = new Date(i.valueOf() + h * 3600000);
                break;
            case Ext.Date.DAY:
                i = new Date(i.valueOf() + h * 86400000);
                break;
            case Ext.Date.MONTH:
                var e = g.getDate();
                if (e > 28) {
                    e = Math.min(e, Ext.Date.getLastDateOfMonth(Ext.Date.add(Ext.Date.getFirstDateOfMonth(g), "mo", h)).getDate())
                }
                i.setDate(e);
                i.setMonth(g.getMonth() + h);
                break;
            case Ext.Date.YEAR:
                i.setFullYear(g.getFullYear() + h);
                break
            }
            return i
        },
        between: function(e, g, d) {
            var f = e.getTime();
            return g.getTime() <= f && f <= d.getTime()
        },
        diff: function(f, d, h) {
            var e = Ext.Date,
            g, i = +d - f;
            switch (h) {
            case e.MILLI:
                return i;
            case e.SECOND:
                return Math.floor(i / 1000);
            case e.MINUTE:
                return Math.floor(i / 60000);
            case e.HOUR:
                return Math.floor(i / 3600000);
            case e.DAY:
                return Math.floor(i / 86400000);
            case "w":
                return Math.floor(i / 604800000);
            case e.MONTH:
                g = (d.getFullYear() * 12 + d.getMonth()) - (f.getFullYear() * 12 + f.getMonth());
                if (Ext.Date.add(f, h, g) > d) {
                    return g - 1
                } else {
                    return g
                }
            case e.YEAR:
                g = d.getFullYear() - f.getFullYear();
                if (Ext.Date.add(f, h, g) > d) {
                    return g - 1
                } else {
                    return g
                }
            }
        },
        align: function(e, g, f) {
            var d = new Date( + e);
            switch (g.toLowerCase()) {
            case Ext.Date.MILLI:
                return d;
                break;
            case Ext.Date.SECOND:
                d.setUTCSeconds(d.getUTCSeconds() - d.getUTCSeconds() % f);
                d.setUTCMilliseconds(0);
                return d;
                break;
            case Ext.Date.MINUTE:
                d.setUTCMinutes(d.getUTCMinutes() - d.getUTCMinutes() % f);
                d.setUTCSeconds(0);
                d.setUTCMilliseconds(0);
                return d;
                break;
            case Ext.Date.HOUR:
                d.setUTCHours(d.getUTCHours() - d.getUTCHours() % f);
                d.setUTCMinutes(0);
                d.setUTCSeconds(0);
                d.setUTCMilliseconds(0);
                return d;
                break;
            case Ext.Date.DAY:
                if (f == 7 || f == 14) {
                    d.setUTCDate(d.getUTCDate() - d.getUTCDay() + 1)
                }
                d.setUTCHours(0);
                d.setUTCMinutes(0);
                d.setUTCSeconds(0);
                d.setUTCMilliseconds(0);
                return d;
                break;
            case Ext.Date.MONTH:
                d.setUTCMonth(d.getUTCMonth() - (d.getUTCMonth() - 1) % f, 1);
                d.setUTCHours(0);
                d.setUTCMinutes(0);
                d.setUTCSeconds(0);
                d.setUTCMilliseconds(0);
                return d;
                break;
            case Ext.Date.YEAR:
                d.setUTCFullYear(d.getUTCFullYear() - d.getUTCFullYear() % f, 1, 1);
                d.setUTCHours(0);
                d.setUTCMinutes(0);
                d.setUTCSeconds(0);
                d.setUTCMilliseconds(0);
                return e;
                break
            }
        }
    };
    var a = Ext.DateExtras;
    Ext.apply(Ext.Date, a)
})();
Ext.define("Ext.util.Format", {
    singleton: true,
    defaultDateFormat: "m/d/Y",
    escapeRe: /('|\\)/g,
    trimRe: /^[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+|[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+$/g,
    formatRe: /\{(\d+)\}/g,
    escapeRegexRe: /([-.*+?^${}()|[\]\/\\])/g,
    dashesRe: /-/g,
    iso8601TestRe: /\d\dT\d\d/,
    iso8601SplitRe: /[- :T\.Z\+]/,
    ellipsis: function(d, a, e) {
        if (d && d.length > a) {
            if (e) {
                var f = d.substr(0, a - 2),
                b = Math.max(f.lastIndexOf(" "), f.lastIndexOf("."), f.lastIndexOf("!"), f.lastIndexOf("?"));
                if (b != -1 && b >= (a - 15)) {
                    return f.substr(0, b) + "..."
                }
            }
            return d.substr(0, a - 3) + "..."
        }
        return d
    },
    escapeRegex: function(a) {
        return a.replace(Ext.util.Format.escapeRegexRe, "\\$1")
    },
    escape: function(a) {
        return a.replace(Ext.util.Format.escapeRe, "\\$1")
    },
    toggle: function(b, d, a) {
        return b == d ? a: d
    },
    trim: function(a) {
        return a.replace(Ext.util.Format.trimRe, "")
    },
    leftPad: function(e, b, d) {
        var a = String(e);
        d = d || " ";
        while (a.length < b) {
            a = d + a
        }
        return a
    },
    format: function(b) {
        var a = Ext.toArray(arguments, 1);
        return b.replace(Ext.util.Format.formatRe,
        function(d, e) {
            return a[e]
        })
    },
    htmlEncode: function(a) {
        return ! a ? a: String(a).replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;").replace(/"/g, "&quot;")
    },
    htmlDecode: function(a) {
        return ! a ? a: String(a).replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&quot;/g, '"').replace(/&amp;/g, "&")
    },
    date: function(g, h) {
        var b = g;
        if (!g) {
            return ""
        }
        if (!Ext.isDate(g)) {
            b = new Date(Date.parse(g));
            if (isNaN(b)) {
                if (this.iso8601TestRe.test(g)) {
                    if (Ext.os.is.Android && Ext.os.version.isLessThan("3.0")) {
                        var j = [1, 4, 5, 6, 7, 10, 11];
                        var f, e = 0;
                        if ((f = /^(\d{4}|[+\-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/.exec(g))) {
                            for (var d = 0,
                            a; (a = j[d]); ++d) {
                                f[a] = +f[a] || 0
                            }
                            f[2] = ( + f[2] || 1) - 1;
                            f[3] = +f[3] || 1;
                            if (f[8] !== "Z" && f[9] !== undefined) {
                                e = f[10] * 60 + f[11];
                                if (f[9] === "+") {
                                    e = 0 - e
                                }
                            }
                            b = new Date(Date.UTC(f[1], f[2], f[3], f[4], f[5] + e, f[6], f[7]))
                        }
                    } else {
                        b = g.split(this.iso8601SplitRe);
                        b = new Date(b[0], b[1] - 1, b[2], b[3], b[4], b[5])
                    }
                }
            }
            if (isNaN(b)) {
                b = new Date(Date.parse(g.replace(this.dashesRe, "/")))
            }
            g = b
        }
        return Ext.Date.format(g, h || Ext.util.Format.defaultDateFormat)
    }
});
Ext.define("Ext.Template", {
    inheritableStatics: {
        from: function(b, a) {
            b = Ext.getDom(b);
            return new this(b.value || b.innerHTML, a || "")
        }
    },
    constructor: function(e) {
        var g = this,
        b = arguments,
        a = [],
        d = 0,
        f = b.length,
        h;
        g.initialConfig = {};
        if (f === 1 && Ext.isArray(e)) {
            b = e;
            f = b.length
        }
        if (f > 1) {
            for (; d < f; d++) {
                h = b[d];
                if (typeof h == "object") {
                    Ext.apply(g.initialConfig, h);
                    Ext.apply(g, h)
                } else {
                    a.push(h)
                }
            }
        } else {
            a.push(e)
        }
        g.html = a.join("");
        if (g.compiled) {
            g.compile()
        }
    },
    isTemplate: true,
    disableFormats: false,
    re: /\{([\w\-]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?\}/g,
    apply: function(a) {
        var h = this,
        e = h.disableFormats !== true,
        g = Ext.util.Format,
        d = h,
        b;
        if (h.compiled) {
            return h.compiled(a).join("")
        }
        function f(i, k, n, j) {
            if (n && e) {
                if (j) {
                    j = [a[k]].concat(Ext.functionFactory("return [" + j + "];")())
                } else {
                    j = [a[k]]
                }
                if (n.substr(0, 5) == "this.") {
                    return d[n.substr(5)].apply(d, j)
                } else {
                    return g[n].apply(g, j)
                }
            } else {
                return a[k] !== undefined ? a[k] : ""
            }
        }
        b = h.html.replace(h.re, f);
        return b
    },
    applyOut: function(a, b) {
        var d = this;
        if (d.compiled) {
            b.push.apply(b, d.compiled(a))
        } else {
            b.push(d.apply(a))
        }
        return b
    },
    applyTemplate: function() {
        return this.apply.apply(this, arguments)
    },
    set: function(a, d) {
        var b = this;
        b.html = a;
        b.compiled = null;
        return d ? b.compile() : b
    },
    compileARe: /\\/g,
    compileBRe: /(\r\n|\n)/g,
    compileCRe: /'/g,
    compile: function() {
        var me = this,
        fm = Ext.util.Format,
        useFormat = me.disableFormats !== true,
        body, bodyReturn;
        function fn(m, name, format, args) {
            if (format && useFormat) {
                args = args ? "," + args: "";
                if (format.substr(0, 5) != "this.") {
                    format = "fm." + format + "("
                } else {
                    format = "this." + format.substr(5) + "("
                }
            } else {
                args = "";
                format = "(values['" + name + "'] == undefined ? '' : "
            }
            return "'," + format + "values['" + name + "']" + args + ") ,'"
        }
        bodyReturn = me.html.replace(me.compileARe, "\\\\").replace(me.compileBRe, "\\n").replace(me.compileCRe, "\\'").replace(me.re, fn);
        body = "this.compiled = function(values){ return ['" + bodyReturn + "'];};";
        eval(body);
        return me
    },
    insertFirst: function(b, a, d) {
        return this.doInsert("afterBegin", b, a, d)
    },
    insertBefore: function(b, a, d) {
        return this.doInsert("beforeBegin", b, a, d)
    },
    insertAfter: function(b, a, d) {
        return this.doInsert("afterEnd", b, a, d)
    },
    append: function(b, a, d) {
        return this.doInsert("beforeEnd", b, a, d)
    },
    doInsert: function(b, e, a, f) {
        var d = Ext.DomHelper.insertHtml(b, Ext.getDom(e), this.apply(a));
        return f ? Ext.get(d) : d
    },
    overwrite: function(d, a, e) {
        var b = Ext.DomHelper.overwrite(Ext.getDom(d), this.apply(a));
        return e ? Ext.get(b) : b
    }
});
Ext.define("Ext.XTemplateParser", {
    constructor: function(a) {
        Ext.apply(this, a)
    },
    doTpl: Ext.emptyFn,
    parse: function(n) {
        var y = this,
        q = n.length,
        p = {
            elseif: "elif"
        },
        r = y.topRe,
        d = y.actionsRe,
        f,
        e,
        j,
        o,
        h,
        k,
        i,
        v,
        u,
        b,
        g,
        a;
        y.level = 0;
        y.stack = e = [];
        for (f = 0; f < q; f = b) {
            r.lastIndex = f;
            o = r.exec(n);
            if (!o) {
                y.doText(n.substring(f, q));
                break
            }
            u = o.index;
            b = r.lastIndex;
            if (f < u) {
                y.doText(n.substring(f, u))
            }
            if (o[1]) {
                b = n.indexOf("%}", u + 2);
                y.doEval(n.substring(u + 2, b));
                b += 2
            } else {
                if (o[2]) {
                    b = n.indexOf("]}", u + 2);
                    y.doExpr(n.substring(u + 2, b));
                    b += 2
                } else {
                    if (o[3]) {
                        y.doTag(o[3])
                    } else {
                        if (o[4]) {
                            g = null;
                            while ((v = d.exec(o[4])) !== null) {
                                j = v[2] || v[3];
                                if (j) {
                                    j = Ext.String.htmlDecode(j);
                                    h = v[1];
                                    h = p[h] || h;
                                    g = g || {};
                                    k = g[h];
                                    if (typeof k == "string") {
                                        g[h] = [k, j]
                                    } else {
                                        if (k) {
                                            g[h].push(j)
                                        } else {
                                            g[h] = j
                                        }
                                    }
                                }
                            }
                            if (!g) {
                                if (y.elseRe.test(o[4])) {
                                    y.doElse()
                                } else {
                                    if (y.defaultRe.test(o[4])) {
                                        y.doDefault()
                                    } else {
                                        y.doTpl();
                                        e.push({
                                            type: "tpl"
                                        })
                                    }
                                }
                            } else {
                                if (g["if"]) {
                                    y.doIf(g["if"], g);
                                    e.push({
                                        type: "if"
                                    })
                                } else {
                                    if (g["switch"]) {
                                        y.doSwitch(g["switch"], g);
                                        e.push({
                                            type: "switch"
                                        })
                                    } else {
                                        if (g["case"]) {
                                            y.doCase(g["case"], g)
                                        } else {
                                            if (g.elif) {
                                                y.doElseIf(g.elif, g)
                                            } else {
                                                if (g["for"]) {++y.level;
                                                    if (a = y.propRe.exec(o[4])) {
                                                        g.propName = a[1] || a[2]
                                                    }
                                                    y.doFor(g["for"], g);
                                                    e.push({
                                                        type: "for",
                                                        actions: g
                                                    })
                                                } else {
                                                    if (g.exec) {
                                                        y.doExec(g.exec, g);
                                                        e.push({
                                                            type: "exec",
                                                            actions: g
                                                        })
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if (o[0].length === 5) {
                                e.push({
                                    type: "tpl"
                                })
                            } else {
                                i = e.pop();
                                y.doEnd(i.type, i.actions);
                                if (i.type == "for") {--y.level
                                }
                            }
                        }
                    }
                }
            }
        }
    },
    topRe: /(?:(\{\%)|(\{\[)|\{([^{}]*)\})|(?:<tpl([^>]*)\>)|(?:<\/tpl>)/g,
    actionsRe: /\s*(elif|elseif|if|for|exec|switch|case|eval)\s*\=\s*(?:(?:"([^"]*)")|(?:'([^']*)'))\s*/g,
    propRe: /prop=(?:(?:"([^"]*)")|(?:'([^']*)'))/,
    defaultRe: /^\s*default\s*$/,
    elseRe: /^\s*else\s*$/
});
Ext.define("Ext.XTemplateCompiler", {
    extend: Ext.XTemplateParser,
    useEval: Ext.isGecko,
    useIndex: Ext.isIE6 || Ext.isIE7,
    useFormat: true,
    propNameRe: /^[\w\d\$]*$/,
    compile: function(a) {
        var d = this,
        b = d.generate(a);
        return d.useEval ? d.evalTpl(b) : (new Function("Ext", b))(Ext)
    },
    generate: function(a) {
        var e = this,
        b = "var fm=Ext.util.Format,ts=Object.prototype.toString;",
        d;
        e.maxLevel = 0;
        e.body = ["var c0=values, a0=" + e.createArrayTest(0) + ", p0=parent, n0=xcount, i0=xindex, v;\n"];
        if (e.definitions) {
            if (typeof e.definitions === "string") {
                e.definitions = [e.definitions, b]
            } else {
                e.definitions.push(b)
            }
        } else {
            e.definitions = [b]
        }
        e.switches = [];
        e.parse(a);
        e.definitions.push((e.useEval ? "$=": "return") + " function (" + e.fnArgs + ") {", e.body.join(""), "}");
        d = e.definitions.join("\n");
        e.definitions.length = e.body.length = e.switches.length = 0;
        delete e.definitions;
        delete e.body;
        delete e.switches;
        return d
    },
    doText: function(d) {
        var b = this,
        a = b.body;
        d = d.replace(b.aposRe, "\\'").replace(b.newLineRe, "\\n");
        if (b.useIndex) {
            a.push("out[out.length]='", d, "'\n")
        } else {
            a.push("out.push('", d, "')\n")
        }
    },
    doExpr: function(b) {
        var a = this.body;
        a.push("v=" + b + "; if (v !== undefined && v !== null) out");
        if (this.useIndex) {
            a.push("[out.length]=v+''\n")
        } else {
            a.push(".push(v+'')\n")
        }
    },
    doTag: function(a) {
        this.doExpr(this.parseTag(a))
    },
    doElse: function() {
        this.body.push("} else {\n")
    },
    doEval: function(a) {
        this.body.push(a, "\n")
    },
    doIf: function(b, d) {
        var a = this;
        if (b === ".") {
            a.body.push("if (values) {\n")
        } else {
            if (a.propNameRe.test(b)) {
                a.body.push("if (", a.parseTag(b), ") {\n")
            } else {
                a.body.push("if (", a.addFn(b), a.callFn, ") {\n")
            }
        }
        if (d.exec) {
            a.doExec(d.exec)
        }
    },
    doElseIf: function(b, d) {
        var a = this;
        if (b === ".") {
            a.body.push("else if (values) {\n")
        } else {
            if (a.propNameRe.test(b)) {
                a.body.push("} else if (", a.parseTag(b), ") {\n")
            } else {
                a.body.push("} else if (", a.addFn(b), a.callFn, ") {\n")
            }
        }
        if (d.exec) {
            a.doExec(d.exec)
        }
    },
    doSwitch: function(b) {
        var a = this;
        if (b === ".") {
            a.body.push("switch (values) {\n")
        } else {
            if (a.propNameRe.test(b)) {
                a.body.push("switch (", a.parseTag(b), ") {\n")
            } else {
                a.body.push("switch (", a.addFn(b), a.callFn, ") {\n")
            }
        }
        a.switches.push(0)
    },
    doCase: function(f) {
        var e = this,
        d = Ext.isArray(f) ? f: [f],
        g = e.switches.length - 1,
        a,
        b;
        if (e.switches[g]) {
            e.body.push("break;\n")
        } else {
            e.switches[g]++
        }
        for (b = 0, g = d.length; b < g; ++b) {
            a = e.intRe.exec(d[b]);
            d[b] = a ? a[1] : ("'" + d[b].replace(e.aposRe, "\\'") + "'")
        }
        e.body.push("case ", d.join(": case "), ":\n")
    },
    doDefault: function() {
        var a = this,
        b = a.switches.length - 1;
        if (a.switches[b]) {
            a.body.push("break;\n")
        } else {
            a.switches[b]++
        }
        a.body.push("default:\n")
    },
    doEnd: function(b, e) {
        var d = this,
        a = d.level - 1;
        if (b == "for") {
            if (e.exec) {
                d.doExec(e.exec)
            }
            d.body.push("}\n");
            d.body.push("parent=p", a, ";values=r", a + 1, ";xcount=n", a, ";xindex=i", a, "\n")
        } else {
            if (b == "if" || b == "switch") {
                d.body.push("}\n")
            }
        }
    },
    doFor: function(g, i) {
        var f = this,
        e, b = f.level,
        a = b - 1,
        d = "p" + b,
        h;
        if (g === ".") {
            e = "values"
        } else {
            if (f.propNameRe.test(g)) {
                e = f.parseTag(g)
            } else {
                e = f.addFn(g) + f.callFn
            }
        }
        if (f.maxLevel < b) {
            f.maxLevel = b;
            f.body.push("var ")
        }
        if (g == ".") {
            h = "c" + b
        } else {
            h = "a" + a + "?c" + a + "[i" + a + "]:p" + b
        }
        f.body.push("i", b, "=0,n", b, "=0,c", b, "=", e, ",a", b, "=", f.createArrayTest(b), ",p", b, "=c", a, ",r", b, "=values;\n", "parent=", h, "\n", "if (c", b, "){if(a", b, "){n", b, "=c", b, ".length;}else if (c", b, ".isMixedCollection){c", b, "=c", b, ".items;n", b, "=c", b, ".length;}else if(c", b, ".isStore){c", b, "=c", b, ".data.items;n", b, "=c", b, ".length;}else{c", b, "=[c", b, "];n", b, "=1;}}\n", "for (xcount=n", b, ";i", b, "<n" + b + ";++i", b, "){\n", "values=c", b, "[i", b, "]");
        if (i.propName) {
            f.body.push(".", i.propName)
        }
        f.body.push("\n", "xindex=i", b, "+1\n")
    },
    createArrayTest: ("isArray" in Array) ?
    function(a) {
        return "Array.isArray(c" + a + ")"
    }: function(a) {
        return "ts.call(c" + a + ')==="[object Array]"'
    },
    doExec: function(d, e) {
        var b = this,
        a = "f" + b.definitions.length;
        b.definitions.push("function " + a + "(" + b.fnArgs + ") {", " try { with(values) {", "  " + d, " }} catch(e) {", "}", "}");
        b.body.push(a + b.callFn + "\n")
    },
    addFn: function(a) {
        var d = this,
        b = "f" + d.definitions.length;
        if (a === ".") {
            d.definitions.push("function " + b + "(" + d.fnArgs + ") {", " return values", "}")
        } else {
            if (a === "..") {
                d.definitions.push("function " + b + "(" + d.fnArgs + ") {", " return parent", "}")
            } else {
                d.definitions.push("function " + b + "(" + d.fnArgs + ") {", " try { with(values) {", "  return(" + a + ")", " }} catch(e) {", "}", "}")
            }
        }
        return b
    },
    parseTag: function(b) {
        var h = this,
        a = h.tagRe.exec(b),
        f = a[1],
        i = a[2],
        e = a[3],
        g = a[4],
        d;
        if (f == ".") {
            if (!h.validTypes) {
                h.definitions.push("var validTypes={string:1,number:1,boolean:1};");
                h.validTypes = true
            }
            d = 'validTypes[typeof values] || ts.call(values) === "[object Date]" ? values : ""'
        } else {
            if (f == "#") {
                d = "xindex"
            } else {
                if (f.substr(0, 7) == "parent.") {
                    d = f
                } else {
                    if (isNaN(f) && f.indexOf("-") == -1 && f.indexOf(".") != -1) {
                        d = "values." + f
                    } else {
                        d = "values['" + f + "']"
                    }
                }
            }
        }
        if (g) {
            d = "(" + d + g + ")"
        }
        if (i && h.useFormat) {
            e = e ? "," + e: "";
            if (i.substr(0, 5) != "this.") {
                i = "fm." + i + "("
            } else {
                i += "("
            }
        } else {
            return d
        }
        return i + d + e + ")"
    },
    evalTpl: function($) {
        eval($);
        return $
    },
    newLineRe: /\r\n|\r|\n/g,
    aposRe: /[']/g,
    intRe: /^\s*(\d+)\s*$/,
    tagRe: /([\w-\.\#\$]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?(\s?[\+\-\*\/]\s?[\d\.\+\-\*\/\(\)]+)?/
},
function() {
    var a = this.prototype;
    a.fnArgs = "out,values,parent,xindex,xcount";
    a.callFn = ".call(this," + a.fnArgs + ")"
});
Ext.define("Ext.XTemplate", {
    extend: Ext.Template,
    emptyObj: {},
    apply: function(a) {
        return this.applyOut(a, []).join("")
    },
    applyOut: function(a, b, f) {
        var h = this,
        g = a.xindex,
        j = a.xcount,
        d;
        if (!h.fn) {
            d = new Ext.XTemplateCompiler({
                useFormat: h.disableFormats !== true,
                definitions: h.definitions
            });
            h.fn = d.compile(h.html)
        }
        try {
            g = typeof g === "number" ? g: 1;
            j = typeof j === "number" ? j: 1;
            h.fn.call(h, b, a, f || h.emptyObj, g, j)
        } catch(i) {}
        return b
    },
    compile: function() {
        return this
    },
    statics: {
        getTpl: function(a, d) {
            var b = a[d],
            e;
            if (b && !b.isTemplate) {
                b = Ext.ClassManager.dynInstantiate("Ext.XTemplate", b);
                if (a.hasOwnProperty(d)) {
                    a[d] = b
                } else {
                    for (e = a.self.prototype; e; e = e.superclass) {
                        if (e.hasOwnProperty(d)) {
                            e[d] = b;
                            break
                        }
                    }
                }
            }
            return b || null
        }
    }
});
Ext.define("Ext.behavior.Behavior", {
    constructor: function(a) {
        this.component = a;
        a.on("destroy", "onComponentDestroy", this)
    },
    onComponentDestroy: Ext.emptyFn
});
Ext.define("Ext.fx.easing.Abstract", {
    config: {
        startTime: 0,
        startValue: 0
    },
    isEasing: true,
    isEnded: false,
    constructor: function(a) {
        this.initConfig(a);
        return this
    },
    applyStartTime: function(a) {
        if (!a) {
            a = Ext.Date.now()
        }
        return a
    },
    updateStartTime: function(a) {
        this.reset()
    },
    reset: function() {
        this.isEnded = false
    },
    getValue: Ext.emptyFn
});
Ext.define("Ext.fx.easing.Linear", {
    extend: Ext.fx.easing.Abstract,
    alias: "easing.linear",
    config: {
        duration: 0,
        endValue: 0
    },
    updateStartValue: function(a) {
        this.distance = this.getEndValue() - a
    },
    updateEndValue: function(a) {
        this.distance = a - this.getStartValue()
    },
    getValue: function() {
        var a = Ext.Date.now() - this.getStartTime(),
        b = this.getDuration();
        if (a > b) {
            this.isEnded = true;
            return this.getEndValue()
        } else {
            return this.getStartValue() + ((a / b) * this.distance)
        }
    }
});
Ext.define("Ext.util.translatable.Abstract", {
    extend: Ext.Evented,
    config: {
        useWrapper: null,
        easing: null,
        easingX: null,
        easingY: null
    },
    x: 0,
    y: 0,
    activeEasingX: null,
    activeEasingY: null,
    isAnimating: false,
    isTranslatable: true,
    constructor: function(a) {
        this.initConfig(a)
    },
    factoryEasing: function(a) {
        return Ext.factory(a, Ext.fx.easing.Linear, null, "easing")
    },
    applyEasing: function(a) {
        if (!this.getEasingX()) {
            this.setEasingX(this.factoryEasing(a))
        }
        if (!this.getEasingY()) {
            this.setEasingY(this.factoryEasing(a))
        }
    },
    applyEasingX: function(a) {
        return this.factoryEasing(a)
    },
    applyEasingY: function(a) {
        return this.factoryEasing(a)
    },
    doTranslate: Ext.emptyFn,
    translate: function(a, d, b) {
        if (b) {
            return this.translateAnimated(a, d, b)
        }
        if (this.isAnimating) {
            this.stopAnimation()
        }
        if (!isNaN(a) && typeof a == "number") {
            this.x = a
        }
        if (!isNaN(d) && typeof d == "number") {
            this.y = d
        }
        this.doTranslate(a, d)
    },
    translateAxis: function(b, e, d) {
        var a, f;
        if (b == "x") {
            a = e
        } else {
            f = e
        }
        return this.translate(a, f, d)
    },
    animate: function(b, a) {
        this.activeEasingX = b;
        this.activeEasingY = a;
        this.isAnimating = true;
        this.lastX = null;
        this.lastY = null;
        Ext.AnimationQueue.start(this.doAnimationFrame, this);
        this.fireEvent("animationstart", this, this.x, this.y);
        return this
    },
    translateAnimated: function(b, h, f) {
        if (!Ext.isObject(f)) {
            f = {}
        }
        if (this.isAnimating) {
            this.stopAnimation()
        }
        var e = Ext.Date.now(),
        g = f.easing,
        d = (typeof b == "number") ? (f.easingX || g || this.getEasingX() || true) : null,
        a = (typeof h == "number") ? (f.easingY || g || this.getEasingY() || true) : null;
        if (d) {
            d = this.factoryEasing(d);
            d.setStartTime(e);
            d.setStartValue(this.x);
            d.setEndValue(b);
            if ("duration" in f) {
                d.setDuration(f.duration)
            }
        }
        if (a) {
            a = this.factoryEasing(a);
            a.setStartTime(e);
            a.setStartValue(this.y);
            a.setEndValue(h);
            if ("duration" in f) {
                a.setDuration(f.duration)
            }
        }
        return this.animate(d, a)
    },
    doAnimationFrame: function() {
        var f = this,
        d = f.activeEasingX,
        b = f.activeEasingY,
        e = Date.now(),
        a,
        g;
        if (!f.isAnimating) {
            return
        }
        f.lastRun = e;
        if (d === null && b === null) {
            f.stopAnimation();
            return
        }
        if (d !== null) {
            f.x = a = Math.round(d.getValue());
            if (d.isEnded) {
                f.activeEasingX = null;
                f.fireEvent("axisanimationend", f, "x", a)
            }
        } else {
            a = f.x
        }
        if (b !== null) {
            f.y = g = Math.round(b.getValue());
            if (b.isEnded) {
                f.activeEasingY = null;
                f.fireEvent("axisanimationend", f, "y", g)
            }
        } else {
            g = f.y
        }
        if (f.lastX !== a || f.lastY !== g) {
            f.doTranslate(a, g);
            f.lastX = a;
            f.lastY = g
        }
        f.fireEvent("animationframe", f, a, g)
    },
    stopAnimation: function() {
        if (!this.isAnimating) {
            return
        }
        this.activeEasingX = null;
        this.activeEasingY = null;
        this.isAnimating = false;
        Ext.AnimationQueue.stop(this.doAnimationFrame, this);
        this.fireEvent("animationend", this, this.x, this.y)
    },
    refresh: function() {
        this.translate(this.x, this.y)
    },
    destroy: function() {
        if (this.isAnimating) {
            this.stopAnimation()
        }
        this.callParent(arguments)
    }
});
Ext.define("Ext.util.translatable.Dom", {
    extend: Ext.util.translatable.Abstract,
    config: {
        element: null
    },
    applyElement: function(a) {
        if (!a) {
            return
        }
        return Ext.get(a)
    },
    updateElement: function() {
        this.refresh()
    }
});
Ext.define("Ext.util.translatable.CssTransform", {
    extend: Ext.util.translatable.Dom,
    doTranslate: function(a, d) {
        var b = this.getElement();
        if (!this.isDestroyed && !b.isDestroyed) {
            b.translate(a, d)
        }
    },
    destroy: function() {
        var a = this.getElement();
        if (a && !a.isDestroyed) {
            a.dom.style.webkitTransform = null
        }
        this.callSuper()
    }
});
Ext.define("Ext.util.translatable.ScrollPosition", {
    extend: Ext.util.translatable.Dom,
    type: "scrollposition",
    config: {
        useWrapper: true
    },
    getWrapper: function() {
        var d = this.wrapper,
        b = this.getElement(),
        a;
        if (!d) {
            a = b.getParent();
            if (!a) {
                return null
            }
            if (a.hasCls(Ext.baseCSSPrefix + "translatable-hboxfix")) {
                a = a.getParent()
            }
            if (this.getUseWrapper()) {
                d = b.wrap()
            } else {
                d = a
            }
            b.addCls("x-translatable");
            d.addCls("x-translatable-container");
            this.wrapper = d;
            d.on("painted",
            function() {
                if (!this.isAnimating) {
                    this.refresh()
                }
            },
            this);
            this.refresh()
        }
        return d
    },
    doTranslate: function(a, e) {
        var d = this.getWrapper(),
        b;
        if (d) {
            b = d.dom;
            if (typeof a == "number") {
                b.scrollLeft = 500000 - a
            }
            if (typeof e == "number") {
                b.scrollTop = 500000 - e
            }
        }
    },
    destroy: function() {
        var a = this.getElement(),
        b = this.wrapper;
        if (b) {
            if (!a.isDestroyed) {
                if (this.getUseWrapper()) {
                    b.doReplaceWith(a)
                }
                a.removeCls("x-translatable")
            }
            if (!b.isDestroyed) {
                b.removeCls("x-translatable-container");
                b.un("painted", "refresh", this)
            }
            delete this.wrapper;
            delete this._element
        }
        this.callSuper()
    }
});
Ext.define("Ext.util.translatable.CssPosition", {
    extend: Ext.util.translatable.Dom,
    doTranslate: function(a, d) {
        var b = this.getElement().dom.style;
        if (typeof a == "number") {
            b.left = a + "px"
        }
        if (typeof d == "number") {
            b.top = d + "px"
        }
    },
    destroy: function() {
        var a = this.getElement().dom.style;
        a.left = null;
        a.top = null;
        this.callParent(arguments)
    }
});
Ext.define("Ext.util.Translatable", {
    constructor: function(a) {
        var b = Ext.util.translatable;
        switch (Ext.browser.getPreferredTranslationMethod(a)) {
        case "scrollposition":
            return new b.ScrollPosition(a);
        case "csstransform":
            return new b.CssTransform(a);
        case "cssposition":
            return new b.CssPosition(a)
        }
    }
});
Ext.define("Ext.behavior.Translatable", {
    extend: Ext.behavior.Behavior,
    setConfig: function(d) {
        var a = this.translatable,
        b = this.component;
        if (d) {
            if (!a) {
                this.translatable = a = new Ext.util.Translatable(d);
                a.setElement(b.renderElement);
                a.on("destroy", "onTranslatableDestroy", this)
            } else {
                if (Ext.isObject(d)) {
                    a.setConfig(d)
                }
            }
        } else {
            if (a) {
                a.destroy()
            }
        }
        return this
    },
    getTranslatable: function() {
        return this.translatable
    },
    onTranslatableDestroy: function() {
        delete this.translatable
    },
    onComponentDestroy: function() {
        var a = this.translatable;
        if (a) {
            a.destroy()
        }
    }
});
Ext.define("Ext.util.Draggable", {
    isDraggable: true,
    mixins: [Ext.mixin.Observable],
    config: {
        cls: Ext.baseCSSPrefix + "draggable",
        draggingCls: Ext.baseCSSPrefix + "dragging",
        element: null,
        constraint: "container",
        disabled: null,
        direction: "both",
        initialOffset: {
            x: 0,
            y: 0
        },
        translatable: {}
    },
    DIRECTION_BOTH: "both",
    DIRECTION_VERTICAL: "vertical",
    DIRECTION_HORIZONTAL: "horizontal",
    defaultConstraint: {
        min: {
            x: -Infinity,
            y: -Infinity
        },
        max: {
            x: Infinity,
            y: Infinity
        }
    },
    containerWidth: 0,
    containerHeight: 0,
    width: 0,
    height: 0,
    constructor: function(a) {
        var b;
        this.extraConstraint = {};
        this.initialConfig = a;
        this.offset = {
            x: 0,
            y: 0
        };
        this.listeners = {
            dragstart: "onDragStart",
            drag: "onDrag",
            dragend: "onDragEnd",
            resize: "onElementResize",
            scope: this
        };
        if (a && a.element) {
            b = a.element;
            delete a.element;
            this.setElement(b)
        }
        return this
    },
    applyElement: function(a) {
        if (!a) {
            return
        }
        return Ext.get(a)
    },
    updateElement: function(a) {
        a.on(this.listeners);
        this.initConfig(this.initialConfig)
    },
    updateInitialOffset: function(b) {
        if (typeof b == "number") {
            b = {
                x: b,
                y: b
            }
        }
        var d = this.offset,
        a, e;
        d.x = a = b.x;
        d.y = e = b.y;
        this.getTranslatable().translate(a, e)
    },
    updateCls: function(a) {
        this.getElement().addCls(a)
    },
    applyTranslatable: function(a, b) {
        a = Ext.factory(a, Ext.util.Translatable, b);
        if (a) {
            a.setElement(this.getElement())
        }
        return a
    },
    setExtraConstraint: function(a) {
        this.extraConstraint = a || {};
        this.refreshConstraint();
        return this
    },
    addExtraConstraint: function(a) {
        Ext.merge(this.extraConstraint, a);
        this.refreshConstraint();
        return this
    },
    applyConstraint: function(a) {
        this.currentConstraint = a;
        if (!a) {
            a = this.defaultConstraint
        }
        if (a === "container") {
            return Ext.merge(this.getContainerConstraint(), this.extraConstraint)
        }
        return Ext.merge({},
        this.extraConstraint, a)
    },
    updateConstraint: function() {
        this.refreshOffset()
    },
    getContainerConstraint: function() {
        var a = this.getContainer(),
        b = this.getElement();
        if (!a || !b.dom) {
            return this.defaultConstraint
        }
        return {
            min: {
                x: 0,
                y: 0
            },
            max: {
                x: this.containerWidth - this.width,
                y: this.containerHeight - this.height
            }
        }
    },
    getContainer: function() {
        var a = this.container;
        if (!a) {
            a = this.getElement().getParent();
            if (a) {
                this.container = a;
                a.on({
                    resize: "onContainerResize",
                    destroy: "onContainerDestroy",
                    scope: this
                })
            }
        }
        return a
    },
    onElementResize: function(a, b) {
        this.width = b.width;
        this.height = b.height;
        this.refresh()
    },
    onContainerResize: function(a, b) {
        this.containerWidth = b.width;
        this.containerHeight = b.height;
        this.refresh()
    },
    onContainerDestroy: function() {
        delete this.container;
        delete this.containerSizeMonitor
    },
    detachListeners: function() {
        this.getElement().un(this.listeners)
    },
    isAxisEnabled: function(a) {
        var b = this.getDirection();
        if (a === "x") {
            return (b === this.DIRECTION_BOTH || b === this.DIRECTION_HORIZONTAL)
        }
        return (b === this.DIRECTION_BOTH || b === this.DIRECTION_VERTICAL)
    },
    onDragStart: function(a) {
        if (this.getDisabled()) {
            return false
        }
        var b = this.offset;
        this.fireAction("dragstart", [this, a, b.x, b.y], this.initDragStart)
    },
    initDragStart: function(b, d, a, f) {
        this.dragStartOffset = {
            x: a,
            y: f
        };
        this.isDragging = true;
        this.getElement().addCls(this.getDraggingCls())
    },
    onDrag: function(b) {
        if (!this.isDragging) {
            return
        }
        var a = this.dragStartOffset;
        this.fireAction("drag", [this, b, a.x + b.deltaX, a.y + b.deltaY], this.doDrag)
    },
    doDrag: function(b, d, a, f) {
        b.setOffset(a, f)
    },
    onDragEnd: function(a) {
        if (!this.isDragging) {
            return
        }
        this.onDrag(a);
        this.isDragging = false;
        this.getElement().removeCls(this.getDraggingCls());
        this.fireEvent("dragend", this, a, this.offset.x, this.offset.y)
    },
    setOffset: function(j, i, b) {
        var g = this.offset,
        a = this.getConstraint(),
        f = a.min,
        d = a.max,
        e = Math.min,
        h = Math.max;
        if (this.isAxisEnabled("x") && typeof j == "number") {
            j = e(h(j, f.x), d.x)
        } else {
            j = g.x
        }
        if (this.isAxisEnabled("y") && typeof i == "number") {
            i = e(h(i, f.y), d.y)
        } else {
            i = g.y
        }
        g.x = j;
        g.y = i;
        this.getTranslatable().translate(j, i, b)
    },
    getOffset: function() {
        return this.offset
    },
    refreshConstraint: function() {
        this.setConstraint(this.currentConstraint)
    },
    refreshOffset: function() {
        var a = this.offset;
        this.setOffset(a.x, a.y)
    },
    refresh: function() {
        this.refreshConstraint();
        this.getTranslatable().refresh();
        this.refreshOffset()
    },
    enable: function() {
        return this.setDisabled(false)
    },
    disable: function() {
        return this.setDisabled(true)
    },
    destroy: function() {
        var a = this.getTranslatable();
        var b = this.getElement();
        if (b && !b.isDestroyed) {
            b.removeCls(this.getCls())
        }
        this.detachListeners();
        if (a) {
            a.destroy()
        }
    }
},
function() {});
Ext.define("Ext.behavior.Draggable", {
    extend: Ext.behavior.Behavior,
    setConfig: function(d) {
        var a = this.draggable,
        b = this.component;
        if (d) {
            if (!a) {
                b.setTranslatable(d.translatable);
                this.draggable = a = new Ext.util.Draggable(d);
                a.setTranslatable(b.getTranslatable());
                a.setElement(b.renderElement);
                a.on("destroy", "onDraggableDestroy", this);
                b.on(this.listeners)
            } else {
                if (Ext.isObject(d)) {
                    a.setConfig(d)
                }
            }
        } else {
            if (a) {
                a.destroy()
            }
        }
        return this
    },
    getDraggable: function() {
        return this.draggable
    },
    onDraggableDestroy: function() {
        delete this.draggable
    },
    onComponentDestroy: function() {
        var a = this.draggable;
        if (a) {
            a.destroy()
        }
    }
}); (function(a) {
    Ext.define("Ext.Component", {
        extend: Ext.AbstractComponent,
        alternateClassName: "Ext.lib.Component",
        mixins: [Ext.mixin.Traversable],
        xtype: "component",
        observableType: "component",
        cachedConfig: {
            baseCls: null,
            cls: null,
            floatingCls: a + "floating",
            hiddenCls: a + "item-hidden",
            ui: null,
            margin: null,
            padding: null,
            border: null,
            styleHtmlCls: a + "html",
            styleHtmlContent: null
        },
        eventedConfig: {
            flex: null,
            left: null,
            top: null,
            right: null,
            bottom: null,
            width: null,
            height: null,
            minWidth: null,
            minHeight: null,
            maxWidth: null,
            maxHeight: null,
            docked: null,
            centered: null,
            hidden: null,
            disabled: null
        },
        config: {
            style: null,
            html: null,
            draggable: null,
            translatable: null,
            renderTo: null,
            zIndex: null,
            tpl: null,
            enterAnimation: null,
            exitAnimation: null,
            showAnimation: null,
            hideAnimation: null,
            tplWriteMode: "overwrite",
            data: null,
            disabledCls: a + "item-disabled",
            contentEl: null,
            itemId: undefined,
            record: null,
            plugins: null
        },
        listenerOptionsRegex: /^(?:delegate|single|delay|buffer|args|prepend|element)$/,
        alignmentRegex: /^([a-z]+)-([a-z]+)(\?)?$/,
        isComponent: true,
        floating: false,
        rendered: false,
        isInner: true,
        activeAnimation: null,
        dockPositions: {
            top: true,
            right: true,
            bottom: true,
            left: true
        },
        innerElement: null,
        element: null,
        template: [],
        widthLayoutSized: false,
        heightLayoutSized: false,
        layoutStretched: false,
        sizeState: false,
        sizeFlags: 0,
        LAYOUT_WIDTH: 1,
        LAYOUT_HEIGHT: 2,
        LAYOUT_BOTH: 3,
        LAYOUT_STRETCHED: 4,
        constructor: function(d) {
            var e = this,
            b = e.config,
            f;
            e.onInitializedListeners = [];
            e.initialConfig = d;
            if (d !== undefined && "id" in d) {
                f = d.id
            } else {
                if ("id" in b) {
                    f = b.id
                } else {
                    f = e.getId()
                }
            }
            e.id = f;
            e.setId(f);
            Ext.ComponentManager.register(e);
            e.initElement();
            e.initConfig(e.initialConfig);
            e.refreshSizeState = e.doRefreshSizeState;
            e.refreshFloating = e.doRefreshFloating;
            if (e.refreshSizeStateOnInitialized) {
                e.refreshSizeState()
            }
            if (e.refreshFloatingOnInitialized) {
                e.refreshFloating()
            }
            e.initialize();
            e.triggerInitialized();
            if (e.config.fullscreen) {
                e.fireEvent("fullscreen", e)
            }
            e.fireEvent("initialize", e)
        },
        beforeInitConfig: function(b) {
            this.beforeInitialize.apply(this, arguments)
        },
        beforeInitialize: Ext.emptyFn,
        initialize: Ext.emptyFn,
        getTemplate: function() {
            return this.template
        },
        getElementConfig: function() {
            return {
                reference: "element",
                classList: ["x-unsized"],
                children: this.getTemplate()
            }
        },
        triggerInitialized: function() {
            var g = this.onInitializedListeners,
            h = g.length,
            j, f, e, b, d;
            if (!this.initialized) {
                this.initialized = true;
                if (h > 0) {
                    for (d = 0; d < h; d++) {
                        j = g[d];
                        f = j.fn;
                        e = j.scope;
                        b = j.args;
                        if (typeof f == "string") {
                            e[f].apply(e, b)
                        } else {
                            f.apply(e, b)
                        }
                    }
                    g.length = 0
                }
            }
        },
        onInitialized: function(f, e, b) {
            var d = this.onInitializedListeners;
            if (!e) {
                e = this
            }
            if (this.initialized) {
                if (typeof f == "string") {
                    e[f].apply(e, b)
                } else {
                    f.apply(e, b)
                }
            } else {
                d.push({
                    fn: f,
                    scope: e,
                    args: b
                })
            }
        },
        renderTo: function(b, e) {
            var g = this.renderElement.dom,
            f = Ext.getDom(b),
            d = Ext.getDom(e);
            if (f) {
                if (d) {
                    f.insertBefore(g, d)
                } else {
                    f.appendChild(g)
                }
                this.setRendered(Boolean(g.offsetParent))
            }
        },
        setParent: function(d) {
            var b = this.parent;
            if (d && b && b !== d) {
                b.remove(this, false)
            }
            this.parent = d;
            return this
        },
        applyPlugins: function(b) {
            var e, d, f;
            if (!b) {
                return b
            }
            b = [].concat(b);
            for (d = 0, e = b.length; d < e; d++) {
                f = b[d];
                b[d] = Ext.factory(f, "Ext.plugin.Plugin", null, "plugin")
            }
            return b
        },
        updatePlugins: function(f, b) {
            var e, d;
            if (f) {
                for (d = 0, e = f.length; d < e; d++) {
                    f[d].init(this)
                }
            }
            if (b) {
                for (d = 0, e = b.length; d < e; d++) {
                    Ext.destroy(b[d])
                }
            }
        },
        updateRenderTo: function(b) {
            this.renderTo(b)
        },
        updateStyle: function(b) {
            this.element.applyStyles(b)
        },
        updateBorder: function(b) {
            this.element.setBorder(b)
        },
        updatePadding: function(b) {
            this.innerElement.setPadding(b)
        },
        updateMargin: function(b) {
            this.element.setMargin(b)
        },
        updateUi: function(b, f) {
            var e = this.getBaseCls(),
            d = this.element,
            g = this.currentUi;
            if (e) {
                if (f) {
                    if (g) {
                        d.removeCls(g)
                    } else {
                        d.removeCls(e + "-" + f)
                    }
                }
                if (b) {
                    d.addCls(b, e);
                    this.currentUi = e + "-" + b;
                    if (!this.self.prototype.currentUi) {
                        this.self.prototype.currentUi = this.currentUi
                    }
                }
            }
        },
        applyBaseCls: function(b) {
            return b || a + this.xtype
        },
        updateBaseCls: function(b, d) {
            var e = this,
            f = e.getUi();
            if (d) {
                this.element.removeCls(d);
                if (f) {
                    this.element.removeCls(this.currentUi)
                }
            }
            if (b) {
                this.element.addCls(b);
                if (f) {
                    this.element.addCls(b, null, f);
                    this.currentUi = b + "-" + f
                }
            }
        },
        addCls: function(b, j, k) {
            var f = this.getCls(),
            h = (f) ? f.slice() : [],
            g,
            e,
            d;
            j = j || "";
            k = k || "";
            if (typeof b == "string") {
                b = [b]
            }
            g = b.length;
            if (!h.length && j === "" && k === "") {
                h = b
            } else {
                for (e = 0; e < g; e++) {
                    d = j + b[e] + k;
                    if (h.indexOf(d) == -1) {
                        h.push(d)
                    }
                }
            }
            this.setCls(h)
        },
        removeCls: function(b, h, j) {
            var e = this.getCls(),
            g = (e) ? e.slice() : [],
            f,
            d;
            h = h || "";
            j = j || "";
            if (typeof b == "string") {
                g = Ext.Array.remove(g, h + b + j)
            } else {
                f = b.length;
                for (d = 0; d < f; d++) {
                    g = Ext.Array.remove(g, h + b[d] + j)
                }
            }
            this.setCls(g)
        },
        replaceCls: function(f, k, e, j) {
            var m = this.getCls(),
            g = (m) ? m.slice() : [],
            h,
            d,
            b;
            e = e || "";
            j = j || "";
            if (typeof f == "string") {
                g = Ext.Array.remove(g, e + f + j)
            } else {
                if (f) {
                    h = f.length;
                    for (d = 0; d < h; d++) {
                        g = Ext.Array.remove(g, e + f[d] + j)
                    }
                }
            }
            if (typeof k == "string") {
                g.push(e + k + j)
            } else {
                if (k) {
                    h = k.length;
                    if (!g.length && e === "" && j === "") {
                        g = k
                    } else {
                        for (d = 0; d < h; d++) {
                            b = e + k[d] + j;
                            if (g.indexOf(b) == -1) {
                                g.push(b)
                            }
                        }
                    }
                }
            }
            this.setCls(g)
        },
        toggleCls: function(b, d) {
            this.element.toggleCls(b, d);
            return this
        },
        applyCls: function(b) {
            if (typeof b == "string") {
                b = [b]
            }
            if (!b || !b.length) {
                b = null
            }
            return b
        },
        updateCls: function(d, b) {
            if (this.element && ((d && !b) || (!d && b) || d.length != b.length || Ext.Array.difference(d, b).length > 0)) {
                this.element.replaceCls(b, d)
            }
        },
        updateStyleHtmlCls: function(e, b) {
            var f = this.innerHtmlElement,
            d = this.innerElement;
            if (this.getStyleHtmlContent() && b) {
                if (f) {
                    f.replaceCls(b, e)
                } else {
                    d.replaceCls(b, e)
                }
            }
        },
        applyStyleHtmlContent: function(b) {
            return Boolean(b)
        },
        updateStyleHtmlContent: function(e) {
            var b = this.getStyleHtmlCls(),
            d = this.innerElement,
            f = this.innerHtmlElement;
            if (e) {
                if (f) {
                    f.addCls(b)
                } else {
                    d.addCls(b)
                }
            } else {
                if (f) {
                    f.removeCls(b)
                } else {
                    d.addCls(b)
                }
            }
        },
        applyContentEl: function(b) {
            if (b) {
                return Ext.get(b)
            }
        },
        updateContentEl: function(b, d) {
            if (d) {
                d.hide();
                Ext.getBody().append(d)
            }
            if (b) {
                this.setHtml(b.dom);
                b.show()
            }
        },
        getSize: function() {
            return {
                width: this.getWidth(),
                height: this.getHeight()
            }
        },
        isCentered: function() {
            return Boolean(this.getCentered())
        },
        isFloating: function() {
            return this.floating
        },
        isDocked: function() {
            return Boolean(this.getDocked())
        },
        isInnerItem: function() {
            return this.isInner
        },
        setIsInner: function(b) {
            if (b !== this.isInner) {
                this.isInner = b;
                if (this.initialized) {
                    this.fireEvent("innerstatechange", this, b)
                }
            }
        },
        filterLengthValue: function(b) {
            if (b === "auto" || (!b && b !== 0)) {
                return null
            }
            return b
        },
        applyTop: function(b) {
            return this.filterLengthValue(b)
        },
        applyRight: function(b) {
            return this.filterLengthValue(b)
        },
        applyBottom: function(b) {
            return this.filterLengthValue(b)
        },
        applyLeft: function(b) {
            return this.filterLengthValue(b)
        },
        applyWidth: function(b) {
            return this.filterLengthValue(b)
        },
        applyHeight: function(b) {
            return this.filterLengthValue(b)
        },
        applyMinWidth: function(b) {
            return this.filterLengthValue(b)
        },
        applyMinHeight: function(b) {
            return this.filterLengthValue(b)
        },
        applyMaxWidth: function(b) {
            return this.filterLengthValue(b)
        },
        applyMaxHeight: function(b) {
            return this.filterLengthValue(b)
        },
        doSetTop: function(b) {
            this.element.setTop(b);
            this.refreshFloating()
        },
        doSetRight: function(b) {
            this.element.setRight(b);
            this.refreshFloating()
        },
        doSetBottom: function(b) {
            this.element.setBottom(b);
            this.refreshFloating()
        },
        doSetLeft: function(b) {
            this.element.setLeft(b);
            this.refreshFloating()
        },
        doSetWidth: function(b) {
            this.element.setWidth(b);
            this.refreshSizeState()
        },
        doSetHeight: function(b) {
            this.element.setHeight(b);
            this.refreshSizeState()
        },
        applyFlex: function(b) {
            if (b) {
                b = Number(b);
                if (isNaN(b)) {
                    b = null
                }
            } else {
                b = null
            }
            return b
        },
        doSetFlex: Ext.emptyFn,
        refreshSizeState: function() {
            this.refreshSizeStateOnInitialized = true
        },
        doRefreshSizeState: function() {
            var d = this.getWidth() !== null || this.widthLayoutSized || (this.getLeft() !== null && this.getRight() !== null),
            e = this.getHeight() !== null || this.heightLayoutSized || (this.getTop() !== null && this.getBottom() !== null),
            g = this.layoutStretched || this.hasCSSMinHeight || (!e && this.getMinHeight() !== null),
            f = d && e,
            b = (d && this.LAYOUT_WIDTH) | (e && this.LAYOUT_HEIGHT) | (g && this.LAYOUT_STRETCHED);
            if (!f && g) {
                f = null
            }
            this.setSizeState(f);
            this.setSizeFlags(b)
        },
        setLayoutSizeFlags: function(b) {
            this.layoutStretched = !!(b & this.LAYOUT_STRETCHED);
            this.widthLayoutSized = !!(b & this.LAYOUT_WIDTH);
            this.heightLayoutSized = !!(b & this.LAYOUT_HEIGHT);
            this.refreshSizeState()
        },
        setSizeFlags: function(b) {
            if (b !== this.sizeFlags) {
                this.sizeFlags = b;
                var d = !!(b & this.LAYOUT_WIDTH),
                e = !!(b & this.LAYOUT_HEIGHT),
                f = !!(b & this.LAYOUT_STRETCHED);
                if (d && !f && !e) {
                    this.element.addCls("x-has-width")
                } else {
                    this.element.removeCls("x-has-width")
                }
                if (e && !f && !d) {
                    this.element.addCls("x-has-height")
                } else {
                    this.element.removeCls("x-has-height")
                }
                if (this.initialized) {
                    this.fireEvent("sizeflagschange", this, b)
                }
            }
        },
        getSizeFlags: function() {
            if (!this.initialized) {
                this.doRefreshSizeState()
            }
            return this.sizeFlags
        },
        setSizeState: function(b) {
            if (b !== this.sizeState) {
                this.sizeState = b;
                this.element.setSizeState(b);
                if (this.initialized) {
                    this.fireEvent("sizestatechange", this, b)
                }
            }
        },
        getSizeState: function() {
            if (!this.initialized) {
                this.doRefreshSizeState()
            }
            return this.sizeState
        },
        doSetMinWidth: function(b) {
            this.element.setMinWidth(b)
        },
        doSetMinHeight: function(b) {
            this.element.setMinHeight(b);
            this.refreshSizeState()
        },
        doSetMaxWidth: function(b) {
            this.element.setMaxWidth(b)
        },
        doSetMaxHeight: function(b) {
            this.element.setMaxHeight(b)
        },
        applyCentered: function(b) {
            b = Boolean(b);
            if (b) {
                this.refreshInnerState = Ext.emptyFn;
                if (this.isFloating()) {
                    this.resetFloating()
                }
                if (this.isDocked()) {
                    this.setDocked(false)
                }
                this.setIsInner(false);
                delete this.refreshInnerState
            }
            return b
        },
        doSetCentered: function(b) {
            this.toggleCls(this.getFloatingCls(), b);
            if (!b) {
                this.refreshInnerState()
            }
        },
        applyDocked: function(b) {
            if (!b) {
                return null
            }
            this.refreshInnerState = Ext.emptyFn;
            if (this.isFloating()) {
                this.resetFloating()
            }
            if (this.isCentered()) {
                this.setCentered(false)
            }
            this.setIsInner(false);
            delete this.refreshInnerState;
            return b
        },
        doSetDocked: function(d, b) {
            this.fireEvent("afterdockedchange", this, d, b);
            if (!d) {
                this.refreshInnerState()
            }
        },
        resetFloating: function() {
            this.setTop(null);
            this.setRight(null);
            this.setBottom(null);
            this.setLeft(null)
        },
        refreshInnerState: function() {
            this.setIsInner(!this.isCentered() && !this.isFloating() && !this.isDocked())
        },
        refreshFloating: function() {
            this.refreshFloatingOnInitialized = true
        },
        doRefreshFloating: function() {
            var d = true,
            b = this.getFloatingCls();
            if (this.getTop() === null && this.getBottom() === null && this.getRight() === null && this.getLeft() === null) {
                d = false
            } else {
                this.refreshSizeState()
            }
            if (d !== this.floating) {
                this.floating = d;
                if (d) {
                    this.refreshInnerState = Ext.emptyFn;
                    if (this.isCentered()) {
                        this.setCentered(false)
                    }
                    if (this.isDocked()) {
                        this.setDocked(false)
                    }
                    this.setIsInner(false);
                    delete this.refreshInnerState
                }
                this.element.toggleCls(b, d);
                if (this.initialized) {
                    this.fireEvent("floatingchange", this, d)
                }
                if (!d) {
                    this.refreshInnerState()
                }
            }
        },
        updateFloatingCls: function(b, d) {
            if (this.isFloating()) {
                this.replaceCls(d, b)
            }
        },
        applyDisabled: function(b) {
            return Boolean(b)
        },
        doSetDisabled: function(b) {
            this.element[b ? "addCls": "removeCls"](this.getDisabledCls())
        },
        updateDisabledCls: function(b, d) {
            if (this.isDisabled()) {
                this.element.replaceCls(d, b)
            }
        },
        disable: function() {
            this.setDisabled(true)
        },
        enable: function() {
            this.setDisabled(false)
        },
        isDisabled: function() {
            return this.getDisabled()
        },
        applyZIndex: function(b) {
            if (!b && b !== 0) {
                b = null
            }
            if (b !== null) {
                b = Number(b);
                if (isNaN(b)) {
                    b = null
                }
            }
            return b
        },
        updateZIndex: function(e) {
            var d = this.element,
            b;
            if (d && !d.isDestroyed) {
                b = d.dom.style;
                if (e !== null) {
                    b.setProperty("z-index", e, "important")
                } else {
                    b.removeProperty("z-index")
                }
            }
        },
        getInnerHtmlElement: function() {
            var b = this.innerHtmlElement,
            d;
            if (!b || !b.dom || !b.dom.parentNode) {
                this.innerHtmlElement = b = Ext.Element.create({
                    cls: "x-innerhtml"
                });
                if (this.getStyleHtmlContent()) {
                    d = this.getStyleHtmlCls();
                    this.innerHtmlElement.addCls(d);
                    this.innerElement.removeCls(d)
                }
                this.innerElement.appendChild(b)
            }
            return b
        },
        updateHtml: function(b) {
            if (!this.isDestroyed) {
                var d = this.getInnerHtmlElement();
                if (Ext.isElement(b)) {
                    d.setHtml("");
                    d.append(b)
                } else {
                    d.setHtml(b)
                }
            }
        },
        applyHidden: function(b) {
            return Boolean(b)
        },
        doSetHidden: function(d) {
            var b = this.renderElement;
            if (b.isDestroyed) {
                return
            }
            if (d) {
                b.hide()
            } else {
                b.show()
            }
            if (this.element) {
                this.element[d ? "addCls": "removeCls"](this.getHiddenCls())
            }
            this.fireEvent(d ? "hide": "show", this)
        },
        updateHiddenCls: function(b, d) {
            if (this.isHidden()) {
                this.element.replaceCls(d, b)
            }
        },
        isHidden: function() {
            return this.getHidden()
        },
        hide: function(b) {
            this.setCurrentAlignmentInfo(null);
            if (this.activeAnimation) {
                this.activeAnimation.on({
                    animationend: function() {
                        this.hide(b)
                    },
                    scope: this,
                    single: true
                });
                return this
            }
            if (!this.getHidden()) {
                if (b === undefined || (b && b.isComponent)) {
                    b = this.getHideAnimation()
                }
                if (b) {
                    if (b === true) {
                        b = "fadeOut"
                    }
                    this.onBefore({
                        hiddenchange: "animateFn",
                        scope: this,
                        single: true,
                        args: [b]
                    })
                }
                this.setHidden(true)
            }
            return this
        },
        show: function(d) {
            if (this.activeAnimation) {
                this.activeAnimation.on({
                    animationend: function() {
                        this.show(d)
                    },
                    scope: this,
                    single: true
                });
                return this
            }
            var b = this.getHidden();
            if (b || b === null) {
                if (d === true) {
                    d = "fadeIn"
                } else {
                    if (d === undefined || (d && d.isComponent)) {
                        d = this.getShowAnimation()
                    }
                }
                if (d) {
                    this.beforeShowAnimation();
                    this.onBefore({
                        hiddenchange: "animateFn",
                        scope: this,
                        single: true,
                        args: [d]
                    })
                }
                this.setHidden(false)
            }
            return this
        },
        beforeShowAnimation: function() {
            if (this.element) {
                this.renderElement.show();
                this.element.removeCls(this.getHiddenCls())
            }
        },
        animateFn: function(h, f, i, e, d, b) {
            var g = this;
            if (h && (!i || (i && this.isPainted()))) {
                this.activeAnimation = new Ext.fx.Animation(h);
                this.activeAnimation.setElement(f.element);
                if (!Ext.isEmpty(i)) {
                    this.activeAnimation.setOnEnd(function() {
                        g.activeAnimation = null;
                        b.resume()
                    });
                    b.pause()
                }
                Ext.Animator.run(g.activeAnimation)
            }
        },
        setVisibility: function(b) {
            this.renderElement.setVisibility(b)
        },
        isRendered: function() {
            return this.rendered
        },
        isPainted: function() {
            return this.renderElement.isPainted()
        },
        applyTpl: function(b) {
            return (Ext.isObject(b) && b.isTemplate) ? b: new Ext.XTemplate(b)
        },
        applyData: function(b) {
            if (Ext.isObject(b)) {
                return Ext.apply({},
                b)
            } else {
                if (!b) {
                    b = {}
                }
            }
            return b
        },
        updateData: function(e) {
            var f = this;
            if (e) {
                var d = f.getTpl(),
                b = f.getTplWriteMode();
                if (d) {
                    d[b](f.getInnerHtmlElement(), e)
                }
                this.fireEvent("updatedata", f, e)
            }
        },
        applyRecord: function(b) {
            if (b && Ext.isObject(b) && b.isModel) {
                return b
            }
            return null
        },
        updateRecord: function(d, b) {
            var e = this;
            if (b) {
                b.unjoin(e)
            }
            if (!d) {
                e.updateData("")
            } else {
                d.join(e);
                e.updateData(d.getData(true))
            }
        },
        afterEdit: function() {
            this.updateRecord(this.getRecord())
        },
        afterErase: function() {
            this.setRecord(null)
        },
        applyItemId: function(b) {
            return b || this.getId()
        },
        isXType: function(d, b) {
            if (b) {
                return this.xtypes.indexOf(d) != -1
            }
            return Boolean(this.xtypesMap[d])
        },
        getXTypes: function() {
            return this.xtypesChain.join("/")
        },
        getDraggableBehavior: function() {
            var b = this.draggableBehavior;
            if (!b) {
                b = this.draggableBehavior = new Ext.behavior.Draggable(this)
            }
            return b
        },
        applyDraggable: function(b) {
            this.getDraggableBehavior().setConfig(b)
        },
        getDraggable: function() {
            return this.getDraggableBehavior().getDraggable()
        },
        getTranslatableBehavior: function() {
            var b = this.translatableBehavior;
            if (!b) {
                b = this.translatableBehavior = new Ext.behavior.Translatable(this)
            }
            return b
        },
        applyTranslatable: function(b) {
            this.getTranslatableBehavior().setConfig(b)
        },
        getTranslatable: function() {
            return this.getTranslatableBehavior().getTranslatable()
        },
        translateAxis: function(d, f, e) {
            var b, g;
            if (d === "x") {
                b = f
            } else {
                g = f
            }
            return this.translate(b, g, e)
        },
        translate: function() {
            var b = this.getTranslatable();
            if (!b) {
                this.setTranslatable(true);
                b = this.getTranslatable()
            }
            b.translate.apply(b, arguments)
        },
        setRendered: function(d) {
            var b = this.rendered;
            if (d !== b) {
                this.rendered = d;
                return true
            }
            return false
        },
        setSize: function(d, b) {
            if (d != undefined) {
                this.setWidth(d)
            }
            if (b != undefined) {
                this.setHeight(b)
            }
        },
        doAddListener: function(e, g, f, d, b) {
            if (d && "element" in d) {
                return this[d.element].doAddListener(e, g, f || this, d, b)
            }
            if (e == "painted" || e == "resize") {
                return this.element.doAddListener(e, g, f || this, d, b)
            }
            return this.callParent(arguments)
        },
        doRemoveListener: function(e, g, f, d, b) {
            if (d && "element" in d) {
                this[d.element].doRemoveListener(e, g, f || this, d, b)
            }
            return this.callParent(arguments)
        },
        showBy: function(d, g) {
            var f = this,
            b = Ext.Viewport,
            e = f.getParent();
            f.setVisibility(false);
            if (e !== b) {
                b.add(f)
            }
            f.show();
            f.on({
                hide: "onShowByErased",
                destroy: "onShowByErased",
                single: true,
                scope: f
            });
            b.on("resize", "alignTo", f, {
                args: [d, g]
            });
            f.alignTo(d, g);
            f.setVisibility(true)
        },
        onShowByErased: function() {
            Ext.Viewport.un("resize", "alignTo", this)
        },
        getAlignmentInfo: function(k, j) {
            var d = k.isComponent ? k.renderElement: k,
            h = d.getPageBox(),
            e = this.renderElement,
            f = e.getPageBox(),
            g = {
                alignToBox: h,
                alignment: j,
                top: h.top,
                left: h.left,
                alignToWidth: h.width,
                alignToHeight: h.height,
                width: f.width,
                height: f.height
            },
            b = this.getCurrentAlignmentInfo(),
            i = true;
            if (!Ext.isEmpty(b)) {
                Ext.Object.each(g,
                function(m, n) {
                    if (!Ext.isObject(n) && b[m] != n) {
                        i = false;
                        return false
                    }
                    return true
                })
            } else {
                i = false
            }
            return {
                isAligned: i,
                stats: g
            }
        },
        getCurrentAlignmentInfo: function() {
            return this.$currentAlignmentInfo
        },
        setCurrentAlignmentInfo: function(b) {
            this.$currentAlignmentInfo = Ext.isEmpty(b) ? null: Ext.merge({},
            b.stats ? b.stats: b)
        },
        alignTo: function(n, i) {
            var q = this.getAlignmentInfo(n, i);
            if (q.isAligned) {
                return
            }
            var p = q.stats.alignToBox,
            D = this.getParent().element.getPageBox(),
            A = q.stats.alignToHeight,
            o = q.stats.alignToWidth,
            t = q.stats.height,
            v = q.stats.width;
            D.bottom -= 5;
            D.height -= 10;
            D.left += 5;
            D.right -= 5;
            D.top += 5;
            D.width -= 10;
            if (!i || i === "auto") {
                if (D.bottom - p.bottom < t) {
                    if (p.top - D.top < t) {
                        if (p.left - D.left < v) {
                            i = "cl-cr?"
                        } else {
                            i = "cr-cl?"
                        }
                    } else {
                        i = "bc-tc?"
                    }
                } else {
                    i = "tc-bc?"
                }
            }
            var b = i.match(this.alignmentRegex);
            var y = b[1].split(""),
            d = b[2].split(""),
            B = (b[3] === "?"),
            h = y[0],
            u = y[1] || h,
            k = d[0],
            m = d[1] || k,
            r = p.top,
            e = p.left,
            j = A / 2,
            f = o / 2,
            g = v / 2,
            s = t / 2,
            z,
            C;
            switch (h) {
            case "t":
                switch (k) {
                case "c":
                    r += j;
                    break;
                case "b":
                    r += A
                }
                break;
            case "b":
                switch (k) {
                case "c":
                    r -= (t - j);
                    break;
                case "t":
                    r -= t;
                    break;
                case "b":
                    r -= t - A
                }
                break;
            case "c":
                switch (k) {
                case "t":
                    r -= s;
                    break;
                case "c":
                    r -= (s - j);
                    break;
                case "b":
                    r -= (s - A)
                }
                break
            }
            switch (u) {
            case "l":
                switch (m) {
                case "c":
                    e += j;
                    break;
                case "r":
                    e += o
                }
                break;
            case "r":
                switch (m) {
                case "r":
                    e -= (v - o);
                    break;
                case "c":
                    e -= (v - g);
                    break;
                case "l":
                    e -= v
                }
                break;
            case "c":
                switch (m) {
                case "l":
                    e -= g;
                    break;
                case "c":
                    e -= (g - f);
                    break;
                case "r":
                    e -= (g - o)
                }
                break
            }
            if (B) {
                z = (D.left + D.width) - v;
                C = (D.top + D.height) - t;
                e = Math.max(D.left, Math.min(z, e));
                r = Math.max(D.top, Math.min(C, r))
            }
            this.setLeft(e);
            this.setTop(r);
            this.setCurrentAlignmentInfo(q)
        },
        up: function(d) {
            var b = this.parent;
            if (d) {
                for (; b; b = b.parent) {
                    if (Ext.ComponentQuery.is(b, d)) {
                        return b
                    }
                }
            }
            return b
        },
        getBubbleTarget: function() {
            return this.getParent()
        },
        destroy: function() {
            this.destroy = Ext.emptyFn;
            var f = this.getParent(),
            d = this.referenceList,
            e,
            g,
            b;
            this.isDestroying = true;
            Ext.destroy(this.getTranslatable(), this.getPlugins());
            if (f) {
                f.remove(this, false)
            }
            for (e = 0, g = d.length; e < g; e++) {
                b = d[e];
                this[b].destroy();
                delete this[b]
            }
            Ext.destroy(this.innerHtmlElement);
            this.setRecord(null);
            this.callSuper();
            Ext.ComponentManager.unregister(this)
        }
    },
    function() {})
})(Ext.baseCSSPrefix);
Ext.define("Ext.mixin.Bindable", {
    extend: Ext.mixin.Mixin,
    mixinConfig: {
        id: "bindable"
    },
    bind: function(a, e, i, d, b) {
        if (!i) {
            i = e
        }
        var g = a[e],
        f,
        h;
        if (g && g.hasOwnProperty("$binding")) {
            h = g.$binding;
            if (h.bindingMethod === i && h.bindingScope === this) {
                return this
            }
        }
        a[e] = f = function() {
            var m = f.$binding,
            k = m.bindingScope,
            j = Array.prototype.slice.call(arguments);
            j.push(arguments);
            if (b) {
                j.push.apply(j, b)
            }
            if (!m.preventDefault && k[m.bindingMethod].apply(k, j) !== false) {
                return m.boundFn.apply(this, arguments)
            }
        };
        f.$binding = {
            preventDefault: !!d,
            boundFn: g,
            bindingMethod: i,
            bindingScope: this
        };
        return this
    },
    unbind: function(a, b, h) {
        if (!h) {
            h = b
        }
        var e = a[b],
        f = e.$binding,
        d,
        g;
        while (f) {
            d = f.boundFn;
            if (f.bindingMethod === h && f.bindingScope === this) {
                if (g) {
                    g.boundFn = d
                } else {
                    a[b] = d
                }
                return this
            }
            g = f;
            f = d.$binding
        }
        return this
    }
});
Ext.define("Ext.util.Wrapper", {
    mixins: [Ext.mixin.Bindable],
    constructor: function(d, b) {
        var a = this.link("element", Ext.Element.create(d));
        if (b) {
            a.insertBefore(b);
            this.wrap(b)
        }
    },
    bindSize: function(b) {
        var d = this.wrappedElement,
        a;
        this.boundSizeName = b;
        this.boundMethodName = a = b === "width" ? "setWidth": "setHeight";
        this.bind(d, a, "onBoundSizeChange");
        d[a].call(d, d.getStyleValue(b))
    },
    onBoundSizeChange: function(d, a) {
        var b = this.element;
        if (typeof d === "string" && d.substr( - 1) === "%") {
            a[0] = "100%"
        } else {
            d = ""
        }
        b[this.boundMethodName].call(b, d)
    },
    wrap: function(d) {
        var b = this.element,
        a;
        this.wrappedElement = d;
        a = b.dom;
        while (a.firstElementChild !== null) {
            a = a.firstElementChild
        }
        a.appendChild(d.dom)
    },
    destroy: function() {
        var e = this.element,
        g = e.dom,
        f = this.wrappedElement,
        b = this.boundMethodName,
        a = g.parentNode,
        d;
        if (b) {
            this.unbind(f, b, "onBoundSizeChange");
            d = e.getStyle(this.boundSizeName);
            if (d) {
                f[b].call(f, d)
            }
        }
        if (a) {
            if (!f.isDestroyed) {
                a.replaceChild(g.firstElementChild, g)
            }
            delete this.wrappedElement
        }
        this.callSuper()
    }
});
Ext.define("Ext.layout.wrapper.Dock", {
    config: {
        direction: "horizontal",
        element: {
            className: "x-dock"
        },
        bodyElement: {
            className: "x-dock-body"
        },
        innerWrapper: null,
        sizeState: false,
        container: null
    },
    positionMap: {
        top: "start",
        left: "start",
        bottom: "end",
        right: "end"
    },
    constructor: function(a) {
        this.items = {
            start: [],
            end: []
        };
        this.itemsCount = 0;
        this.initConfig(a)
    },
    addItems: function(a) {
        var b, e, d;
        for (b = 0, e = a.length; b < e; b++) {
            d = a[b];
            this.addItem(d)
        }
    },
    addItem: function(q) {
        var r = q.getDocked(),
        j = this.positionMap[r],
        b = q.$dockWrapper,
        d = this.getContainer(),
        k = d.indexOf(q),
        o = this.items,
        n = o[j],
        a,
        h,
        g,
        m,
        p,
        f,
        e;
        if (b) {
            b.removeItem(q)
        }
        q.$dockWrapper = this;
        a = q.link("$dockItemWrapper", new Ext.util.Wrapper({
            className: "x-dock-item"
        }));
        q.addCls("x-docked-" + r);
        h = a.element;
        for (g = 0, m = n.length; g < m; g++) {
            p = n[g];
            e = d.indexOf(p);
            if (e > k) {
                f = p.element;
                n.splice(g, 0, q);
                break
            }
        }
        if (!f) {
            n.push(q);
            f = this.getBodyElement()
        }
        this.itemsCount++;
        if (j === "start") {
            h.insertBefore(f)
        } else {
            h.insertAfter(f)
        }
        a.wrap(q.element);
        a.bindSize(this.getDirection() === "horizontal" ? "width": "height")
    },
    removeItem: function(d) {
        var a = d.getDocked(),
        b = this.items[this.positionMap[a]];
        d.removeCls("x-docked-" + a);
        Ext.Array.remove(b, d);
        d.unlink("$dockItemWrapper");
        d.element.detach();
        delete d.$dockWrapper;
        if (--this.itemsCount === 0) {
            this.destroy()
        }
    },
    getItemsSlice: function(d) {
        var a = this.getContainer(),
        b = this.items,
        j = [],
        h,
        e,
        g,
        f;
        for (h = b.start, e = 0, g = h.length; e < g; e++) {
            f = h[e];
            if (a.indexOf(f) > d) {
                j.push(f)
            }
        }
        for (h = b.end, e = 0, g = h.length; e < g; e++) {
            f = h[e];
            if (a.indexOf(f) > d) {
                j.push(f)
            }
        }
        return j
    },
    applyElement: function(a) {
        return Ext.Element.create(a)
    },
    updateElement: function(a) {
        a.addCls("x-dock-" + this.getDirection())
    },
    applyBodyElement: function(a) {
        return Ext.Element.create(a)
    },
    updateBodyElement: function(a) {
        this.getElement().append(a)
    },
    updateInnerWrapper: function(a, d) {
        var b = this.getBodyElement();
        if (d && d.$outerWrapper === this) {
            b.remove(d.getElement());
            delete d.$outerWrapper
        }
        if (a) {
            a.setSizeState(this.getSizeState());
            a.$outerWrapper = this;
            b.append(a.getElement())
        }
    },
    updateSizeState: function(b) {
        var a = this.getInnerWrapper();
        this.getElement().setSizeState(b);
        if (a) {
            a.setSizeState(b)
        }
    },
    destroy: function() {
        var b = this.getInnerWrapper(),
        a = this.$outerWrapper;
        if (b) {
            if (a) {
                a.setInnerWrapper(b)
            } else {
                b.getElement().replace(this.getElement());
                delete b.$outerWrapper
            }
        }
        delete this.$outerWrapper;
        this.setInnerWrapper(null);
        this.unlink("_bodyElement", "_element");
        this.callSuper()
    }
});
Ext.define("Ext.layout.Abstract", {
    mixins: [Ext.mixin.Observable],
    isLayout: true,
    constructor: function(a) {
        this.initialConfig = a
    },
    setContainer: function(a) {
        this.container = a;
        this.initConfig(this.initialConfig);
        return this
    },
    onItemAdd: function() {},
    onItemRemove: function() {},
    onItemMove: function() {},
    onItemCenteredChange: function() {},
    onItemFloatingChange: function() {},
    onItemDockedChange: function() {},
    onItemInnerStateChange: function() {}
});
Ext.define("Ext.layout.wrapper.BoxDock", {
    config: {
        direction: "horizontal",
        element: {
            className: "x-dock"
        },
        bodyElement: {
            className: "x-dock-body"
        },
        innerWrapper: null,
        sizeState: false,
        container: null
    },
    positionMap: {
        top: "start",
        left: "start",
        bottom: "end",
        right: "end"
    },
    constructor: function(a) {
        this.items = {
            start: [],
            end: []
        };
        this.itemsCount = 0;
        this.initConfig(a)
    },
    addItems: function(a) {
        var b, e, d;
        for (b = 0, e = a.length; b < e; b++) {
            d = a[b];
            this.addItem(d)
        }
    },
    addItem: function(p) {
        var q = p.getDocked(),
        h = this.positionMap[q],
        a = p.$dockWrapper,
        b = this.getContainer(),
        j = b.indexOf(p),
        g = p.element,
        n = this.items,
        m = n[h],
        f,
        k,
        o,
        e,
        d;
        if (a) {
            a.removeItem(p)
        }
        p.$dockWrapper = this;
        p.addCls("x-dock-item");
        p.addCls("x-docked-" + q);
        for (f = 0, k = m.length; f < k; f++) {
            o = m[f];
            d = b.indexOf(o);
            if (d > j) {
                e = o.element;
                m.splice(f, 0, p);
                break
            }
        }
        if (!e) {
            m.push(p);
            e = this.getBodyElement()
        }
        this.itemsCount++;
        if (h === "start") {
            g.insertBefore(e)
        } else {
            g.insertAfter(e)
        }
    },
    removeItem: function(d) {
        var a = d.getDocked(),
        b = this.items[this.positionMap[a]];
        Ext.Array.remove(b, d);
        d.element.detach();
        delete d.$dockWrapper;
        d.removeCls("x-dock-item");
        d.removeCls("x-docked-" + a);
        if (--this.itemsCount === 0) {
            this.destroy()
        }
    },
    getItemsSlice: function(d) {
        var a = this.getContainer(),
        b = this.items,
        j = [],
        h,
        e,
        g,
        f;
        for (h = b.start, e = 0, g = h.length; e < g; e++) {
            f = h[e];
            if (a.indexOf(f) > d) {
                j.push(f)
            }
        }
        for (h = b.end, e = 0, g = h.length; e < g; e++) {
            f = h[e];
            if (a.indexOf(f) > d) {
                j.push(f)
            }
        }
        return j
    },
    applyElement: function(a) {
        return Ext.Element.create(a)
    },
    updateElement: function(a) {
        a.addCls("x-dock-" + this.getDirection())
    },
    applyBodyElement: function(a) {
        return Ext.Element.create(a)
    },
    updateBodyElement: function(a) {
        this.getElement().append(a)
    },
    updateInnerWrapper: function(a, d) {
        var b = this.getBodyElement();
        if (d && d.$outerWrapper === this) {
            d.getElement().detach();
            delete d.$outerWrapper
        }
        if (a) {
            a.setSizeState(this.getSizeState());
            a.$outerWrapper = this;
            b.append(a.getElement())
        }
    },
    updateSizeState: function(b) {
        var a = this.getInnerWrapper();
        this.getElement().setSizeState(b);
        if (a) {
            a.setSizeState(b)
        }
    },
    destroy: function() {
        var d = this.getInnerWrapper(),
        b = this.$outerWrapper,
        a;
        if (d) {
            if (b) {
                b.setInnerWrapper(d)
            } else {
                a = d.getElement();
                if (!a.isDestroyed) {
                    a.replace(this.getElement())
                }
                delete d.$outerWrapper
            }
        }
        delete this.$outerWrapper;
        this.setInnerWrapper(null);
        this.unlink("_bodyElement", "_element");
        this.callSuper()
    }
});
Ext.define("Ext.layout.wrapper.Inner", {
    config: {
        sizeState: null,
        container: null
    },
    constructor: function(a) {
        this.initConfig(a)
    },
    getElement: function() {
        return this.getContainer().bodyElement
    },
    setInnerWrapper: Ext.emptyFn,
    getInnerWrapper: Ext.emptyFn
});
Ext.define("Ext.layout.Default", {
    extend: Ext.layout.Abstract,
    isAuto: true,
    alias: ["layout.default", "layout.auto"],
    config: {
        animation: null
    },
    centerWrapperClass: "x-center",
    dockWrapperClass: "x-dock",
    positionMap: {
        top: "start",
        left: "start",
        middle: "center",
        bottom: "end",
        right: "end"
    },
    positionDirectionMap: {
        top: "vertical",
        bottom: "vertical",
        left: "horizontal",
        right: "horizontal"
    },
    setContainer: function(a) {
        var b = {
            delegate: "> component"
        };
        this.dockedItems = [];
        this.callSuper(arguments);
        a.on("centeredchange", "onItemCenteredChange", this, b, "before").on("floatingchange", "onItemFloatingChange", this, b, "before").on("dockedchange", "onBeforeItemDockedChange", this, b, "before").on("afterdockedchange", "onAfterItemDockedChange", this, b)
    },
    monitorSizeStateChange: function() {
        this.monitorSizeStateChange = Ext.emptyFn;
        this.container.on("sizestatechange", "onContainerSizeStateChange", this)
    },
    monitorSizeFlagsChange: function() {
        this.monitorSizeFlagsChange = Ext.emptyFn;
        this.container.on("sizeflagschange", "onContainerSizeFlagsChange", this)
    },
    onItemAdd: function(a) {
        var b = a.getDocked();
        if (b !== null) {
            this.dockItem(a)
        } else {
            if (a.isCentered()) {
                this.onItemCenteredChange(a, true)
            } else {
                if (a.isFloating()) {
                    this.onItemFloatingChange(a, true)
                } else {
                    this.onItemInnerStateChange(a, true)
                }
            }
        }
    },
    onItemInnerStateChange: function(b, a, d) {
        if (a) {
            this.insertInnerItem(b, this.container.innerIndexOf(b))
        } else {
            this.removeInnerItem(b)
        }
    },
    insertInnerItem: function(g, e) {
        var b = this.container,
        i = b.innerElement.dom,
        f = g.element.dom,
        h = e !== -1 ? b.getInnerAt(e + 1) : null,
        d = null,
        a;
        if (h) {
            a = h.getTranslatable();
            if (a && a.getUseWrapper()) {
                d = a.getWrapper().dom
            } else {
                d = h ? h.element.dom: null
            }
        }
        i.insertBefore(f, d);
        return this
    },
    insertBodyItem: function(d) {
        var a = this.container.setUseBodyElement(true),
        b = a.bodyElement.dom;
        if (d.getZIndex() === null) {
            d.setZIndex((a.indexOf(d) + 1) * 2)
        }
        b.insertBefore(d.element.dom, b.firstChild);
        return this
    },
    removeInnerItem: function(a) {
        a.element.detach()
    },
    removeBodyItem: function(a) {
        a.setZIndex(null);
        a.element.detach()
    },
    onItemRemove: function(b, a, d) {
        var e = b.getDocked();
        if (e) {
            this.undockItem(b)
        } else {
            if (b.isCentered()) {
                this.onItemCenteredChange(b, false)
            } else {
                if (b.isFloating()) {
                    this.onItemFloatingChange(b, false)
                } else {
                    this.onItemInnerStateChange(b, false, d)
                }
            }
        }
    },
    onItemMove: function(b, d, a) {
        if (b.isCentered() || b.isFloating()) {
            b.setZIndex((d + 1) * 2)
        } else {
            if (b.isInnerItem()) {
                this.insertInnerItem(b, this.container.innerIndexOf(b))
            } else {
                this.undockItem(b);
                this.dockItem(b)
            }
        }
    },
    onItemCenteredChange: function(d, a) {
        var b = "$centerWrapper";
        if (a) {
            this.insertBodyItem(d);
            d.link(b, new Ext.util.Wrapper({
                className: this.centerWrapperClass
            },
            d.element))
        } else {
            d.unlink(b);
            this.removeBodyItem(d)
        }
    },
    onItemFloatingChange: function(a, b) {
        if (b) {
            this.insertBodyItem(a)
        } else {
            this.removeBodyItem(a)
        }
    },
    onBeforeItemDockedChange: function(a, d, b) {
        if (b) {
            this.undockItem(a)
        }
    },
    onAfterItemDockedChange: function(a, d, b) {
        if (d) {
            this.dockItem(a)
        }
    },
    onContainerSizeStateChange: function() {
        var a = this.getDockWrapper();
        if (a) {
            a.setSizeState(this.container.getSizeState())
        }
    },
    onContainerSizeFlagsChange: function() {
        var a = this.dockedItems,
        b, e, d;
        for (b = 0, e = a.length; b < e; b++) {
            d = a[b];
            this.refreshDockedItemLayoutSizeFlags(d)
        }
    },
    refreshDockedItemLayoutSizeFlags: function(e) {
        var b = this.container,
        f = this.positionDirectionMap[e.getDocked()],
        d = (f === "horizontal") ? b.LAYOUT_HEIGHT: b.LAYOUT_WIDTH,
        a = (b.getSizeFlags() & d);
        e.setLayoutSizeFlags(a)
    },
    dockItem: function(u) {
        var b = Ext.layout.wrapper.BoxDock,
        r = this.dockedItems,
        h = r.length,
        j = this.container,
        v = j.indexOf(u),
        g = this.positionDirectionMap,
        y = g[u.getDocked()],
        t = this.dockInnerWrapper,
        n,
        o,
        z,
        f,
        s,
        m,
        p,
        a,
        e,
        q,
        d,
        k;
        this.monitorSizeStateChange();
        this.monitorSizeFlagsChange();
        if (!t) {
            t = this.link("dockInnerWrapper", new Ext.layout.wrapper.Inner({
                container: this.container
            }))
        }
        if (h === 0) {
            r.push(u);
            q = new b({
                container: this.container,
                direction: y
            });
            q.addItem(u);
            q.getElement().replace(t.getElement());
            q.setInnerWrapper(t);
            j.onInitialized("onContainerSizeStateChange", this)
        } else {
            for (o = 0; o < h; o++) {
                z = r[o];
                f = j.indexOf(z);
                if (f > v) {
                    p = s || r[0];
                    r.splice(o, 0, u);
                    break
                }
                s = z
            }
            if (!p) {
                p = r[h - 1];
                r.push(u)
            }
            a = p.getDocked();
            e = p.$dockWrapper;
            n = g[a];
            if (y === n) {
                e.addItem(u)
            } else {
                m = e.getItemsSlice(v);
                q = new b({
                    container: this.container,
                    direction: y
                });
                if (m.length > 0) {
                    if (m.length === e.itemsCount) {
                        d = e;
                        q.setSizeState(d.getSizeState());
                        q.getElement().replace(d.getElement())
                    } else {
                        d = new b({
                            container: this.container,
                            direction: n
                        });
                        d.setInnerWrapper(e.getInnerWrapper());
                        d.addItems(m);
                        e.setInnerWrapper(q)
                    }
                    q.setInnerWrapper(d)
                } else {
                    k = e.getInnerWrapper();
                    e.setInnerWrapper(null);
                    q.setInnerWrapper(k);
                    e.setInnerWrapper(q)
                }
                q.addItem(u)
            }
        }
        j.onInitialized("refreshDockedItemLayoutSizeFlags", this, [u])
    },
    getDockWrapper: function() {
        var a = this.dockedItems;
        if (a.length > 0) {
            return a[0].$dockWrapper
        }
        return null
    },
    undockItem: function(b) {
        var a = this.dockedItems;
        if (b.$dockWrapper) {
            b.$dockWrapper.removeItem(b)
        }
        Ext.Array.remove(a, b);
        b.setLayoutSizeFlags(0)
    },
    destroy: function() {
        this.dockedItems.length = 0;
        delete this.dockedItems;
        this.callSuper()
    }
});
Ext.define("Ext.layout.Float", {
    extend: Ext.layout.Default,
    alias: "layout.float",
    config: {
        direction: "left"
    },
    layoutClass: "layout-float",
    itemClass: "layout-float-item",
    setContainer: function(a) {
        this.callSuper(arguments);
        a.innerElement.addCls(this.layoutClass)
    },
    onItemInnerStateChange: function(b, a) {
        this.callSuper(arguments);
        b.toggleCls(this.itemClass, a)
    },
    updateDirection: function(d, a) {
        var b = "direction-";
        this.container.innerElement.swapCls(b + d, b + a)
    }
});
Ext.define("Ext.layout.Fit", {
    extend: Ext.layout.Default,
    isFit: true,
    alias: "layout.fit",
    layoutClass: "x-layout-fit",
    itemClass: "x-layout-fit-item",
    setContainer: function(a) {
        this.callSuper(arguments);
        a.innerElement.addCls(this.layoutClass);
        this.onContainerSizeFlagsChange();
        this.monitorSizeFlagsChange()
    },
    onContainerSizeFlagsChange: function() {
        var a = this.container,
        b = a.getSizeFlags(),
        h = Boolean(b & a.LAYOUT_STRETCHED),
        g = a.innerItems,
        d,
        f,
        e;
        this.callSuper();
        for (d = 0, f = g.length; d < f; d++) {
            e = g[d];
            e.setLayoutSizeFlags(b)
        }
        a.innerElement.toggleCls("x-stretched", h)
    },
    onItemInnerStateChange: function(b, a) {
        this.callSuper(arguments);
        b.toggleCls(this.itemClass, a);
        b.setLayoutSizeFlags(a ? this.container.getSizeFlags() : 0)
    }
});
Ext.define("Ext.fx.layout.card.Abstract", {
    extend: Ext.Evented,
    isAnimation: true,
    config: {
        direction: "left",
        duration: null,
        reverse: null,
        layout: null
    },
    updateLayout: function() {
        this.enable()
    },
    enable: function() {
        var a = this.getLayout();
        if (a) {
            a.onBefore("activeitemchange", "onActiveItemChange", this)
        }
    },
    disable: function() {
        var a = this.getLayout();
        if (this.isAnimating) {
            this.stopAnimation()
        }
        if (a) {
            a.unBefore("activeitemchange", "onActiveItemChange", this)
        }
    },
    onActiveItemChange: Ext.emptyFn,
    destroy: function() {
        var a = this.getLayout();
        if (this.isAnimating) {
            this.stopAnimation()
        }
        if (a) {
            a.unBefore("activeitemchange", "onActiveItemChange", this)
        }
        this.setLayout(null);
        if (this.observableId) {
            this.fireEvent("destroy", this);
            this.clearListeners();
            this.clearManagedListeners()
        }
    }
});
Ext.define("Ext.fx.State", {
    isAnimatable: {
        "background-color": true,
        "background-image": true,
        "background-position": true,
        "border-bottom-color": true,
        "border-bottom-width": true,
        "border-color": true,
        "border-left-color": true,
        "border-left-width": true,
        "border-right-color": true,
        "border-right-width": true,
        "border-spacing": true,
        "border-top-color": true,
        "border-top-width": true,
        "border-width": true,
        bottom: true,
        color: true,
        crop: true,
        "font-size": true,
        "font-weight": true,
        height: true,
        left: true,
        "letter-spacing": true,
        "line-height": true,
        "margin-bottom": true,
        "margin-left": true,
        "margin-right": true,
        "margin-top": true,
        "max-height": true,
        "max-width": true,
        "min-height": true,
        "min-width": true,
        opacity: true,
        "outline-color": true,
        "outline-offset": true,
        "outline-width": true,
        "padding-bottom": true,
        "padding-left": true,
        "padding-right": true,
        "padding-top": true,
        right: true,
        "text-indent": true,
        "text-shadow": true,
        top: true,
        "vertical-align": true,
        visibility: true,
        width: true,
        "word-spacing": true,
        "z-index": true,
        zoom: true,
        transform: true
    },
    constructor: function(a) {
        this.data = {};
        this.set(a)
    },
    setConfig: function(a) {
        this.set(a);
        return this
    },
    setRaw: function(a) {
        this.data = a;
        return this
    },
    clear: function() {
        return this.setRaw({})
    },
    setTransform: function(d, h) {
        var g = this.data,
        a = Ext.isArray(h),
        b = g.transform,
        f,
        e;
        if (!b) {
            b = g.transform = {
                translateX: 0,
                translateY: 0,
                translateZ: 0,
                scaleX: 1,
                scaleY: 1,
                scaleZ: 1,
                rotate: 0,
                rotateX: 0,
                rotateY: 0,
                rotateZ: 0,
                skewX: 0,
                skewY: 0
            }
        }
        if (typeof d == "string") {
            switch (d) {
            case "translate":
                if (a) {
                    f = h.length;
                    if (f == 0) {
                        break
                    }
                    b.translateX = h[0];
                    if (f == 1) {
                        break
                    }
                    b.translateY = h[1];
                    if (f == 2) {
                        break
                    }
                    b.translateZ = h[2]
                } else {
                    b.translateX = h
                }
                break;
            case "rotate":
                if (a) {
                    f = h.length;
                    if (f == 0) {
                        break
                    }
                    b.rotateX = h[0];
                    if (f == 1) {
                        break
                    }
                    b.rotateY = h[1];
                    if (f == 2) {
                        break
                    }
                    b.rotateZ = h[2]
                } else {
                    b.rotate = h
                }
                break;
            case "scale":
                if (a) {
                    f = h.length;
                    if (f == 0) {
                        break
                    }
                    b.scaleX = h[0];
                    if (f == 1) {
                        break
                    }
                    b.scaleY = h[1];
                    if (f == 2) {
                        break
                    }
                    b.scaleZ = h[2]
                } else {
                    b.scaleX = h;
                    b.scaleY = h
                }
                break;
            case "skew":
                if (a) {
                    f = h.length;
                    if (f == 0) {
                        break
                    }
                    b.skewX = h[0];
                    if (f == 1) {
                        break
                    }
                    b.skewY = h[1]
                } else {
                    b.skewX = h
                }
                break;
            default:
                b[d] = h
            }
        } else {
            for (e in d) {
                if (d.hasOwnProperty(e)) {
                    h = d[e];
                    this.setTransform(e, h)
                }
            }
        }
    },
    set: function(a, e) {
        var d = this.data,
        b;
        if (typeof a != "string") {
            for (b in a) {
                e = a[b];
                if (b === "transform") {
                    this.setTransform(e)
                } else {
                    d[b] = e
                }
            }
        } else {
            if (a === "transform") {
                this.setTransform(e)
            } else {
                d[a] = e
            }
        }
        return this
    },
    unset: function(a) {
        var b = this.data;
        if (b.hasOwnProperty(a)) {
            delete b[a]
        }
        return this
    },
    getData: function() {
        return this.data
    }
});
Ext.define("Ext.fx.animation.Abstract", {
    extend: Ext.Evented,
    isAnimation: true,
    config: {
        name: "",
        element: null,
        before: null,
        from: {},
        to: {},
        after: null,
        states: {},
        duration: 300,
        easing: "linear",
        iteration: 1,
        direction: "normal",
        delay: 0,
        onBeforeStart: null,
        onEnd: null,
        onBeforeEnd: null,
        scope: null,
        reverse: null,
        preserveEndState: false,
        replacePrevious: true
    },
    STATE_FROM: "0%",
    STATE_TO: "100%",
    DIRECTION_UP: "up",
    DIRECTION_DOWN: "down",
    DIRECTION_LEFT: "left",
    DIRECTION_RIGHT: "right",
    stateNameRegex: /^(?:[\d\.]+)%$/,
    constructor: function() {
        this.states = {};
        this.callParent(arguments);
        return this
    },
    applyElement: function(a) {
        return Ext.get(a)
    },
    applyBefore: function(a, b) {
        if (a) {
            return Ext.factory(a, Ext.fx.State, b)
        }
    },
    applyAfter: function(b, a) {
        if (b) {
            return Ext.factory(b, Ext.fx.State, a)
        }
    },
    setFrom: function(a) {
        return this.setState(this.STATE_FROM, a)
    },
    setTo: function(a) {
        return this.setState(this.STATE_TO, a)
    },
    getFrom: function() {
        return this.getState(this.STATE_FROM)
    },
    getTo: function() {
        return this.getState(this.STATE_TO)
    },
    setStates: function(a) {
        var d = this.stateNameRegex,
        b;
        for (b in a) {
            if (d.test(b)) {
                this.setState(b, a[b])
            }
        }
        return this
    },
    getStates: function() {
        return this.states
    },
    stop: function() {
        this.fireEvent("stop", this)
    },
    destroy: function() {
        this.stop();
        this.callParent()
    },
    setState: function(b, e) {
        var a = this.getStates(),
        d;
        d = Ext.factory(e, Ext.fx.State, a[b]);
        if (d) {
            a[b] = d
        }
        return this
    },
    getState: function(a) {
        return this.getStates()[a]
    },
    getData: function() {
        var m = this.getStates(),
        f = {},
        h = this.getBefore(),
        d = this.getAfter(),
        i = m[this.STATE_FROM],
        j = m[this.STATE_TO],
        k = i.getData(),
        g = j.getData(),
        e,
        b,
        a;
        for (b in m) {
            if (m.hasOwnProperty(b)) {
                a = m[b];
                e = a.getData();
                f[b] = e
            }
        }
        if (Ext.browser.is.AndroidStock2) {
            f["0.0001%"] = k
        }
        return {
            before: h ? h.getData() : {},
            after: d ? d.getData() : {},
            states: f,
            from: k,
            to: g,
            duration: this.getDuration(),
            iteration: this.getIteration(),
            direction: this.getDirection(),
            easing: this.getEasing(),
            delay: this.getDelay(),
            onEnd: this.getOnEnd(),
            onBeforeEnd: this.getOnBeforeEnd(),
            onBeforeStart: this.getOnBeforeStart(),
            scope: this.getScope(),
            preserveEndState: this.getPreserveEndState(),
            replacePrevious: this.getReplacePrevious()
        }
    }
});
Ext.define("Ext.fx.animation.Slide", {
    extend: Ext.fx.animation.Abstract,
    alternateClassName: "Ext.fx.animation.SlideIn",
    alias: ["animation.slide", "animation.slideIn"],
    config: {
        direction: "left",
        out: false,
        offset: 0,
        easing: "auto",
        containerBox: "auto",
        elementBox: "auto",
        isElementBoxFit: true,
        useCssTransform: true
    },
    reverseDirectionMap: {
        up: "down",
        down: "up",
        left: "right",
        right: "left"
    },
    applyEasing: function(a) {
        if (a === "auto") {
            return "ease-" + ((this.getOut()) ? "in": "out")
        }
        return a
    },
    getContainerBox: function() {
        var a = this._containerBox;
        if (a === "auto") {
            a = this.getElement().getParent().getPageBox()
        }
        return a
    },
    getElementBox: function() {
        var a = this._elementBox;
        if (this.getIsElementBoxFit()) {
            return this.getContainerBox()
        }
        if (a === "auto") {
            a = this.getElement().getPageBox()
        }
        return a
    },
    getData: function() {
        var r = this.getElementBox(),
        d = this.getContainerBox(),
        h = r ? r: d,
        p = this.getFrom(),
        q = this.getTo(),
        g = this.getOut(),
        f = this.getOffset(),
        o = this.getDirection(),
        b = this.getUseCssTransform(),
        i = this.getReverse(),
        e = 0,
        a = 0,
        n,
        k,
        m,
        j;
        if (i) {
            o = this.reverseDirectionMap[o]
        }
        switch (o) {
        case this.DIRECTION_UP:
            if (g) {
                a = d.top - h.top - h.height - f
            } else {
                a = d.bottom - h.bottom + h.height + f
            }
            break;
        case this.DIRECTION_DOWN:
            if (g) {
                a = d.bottom - h.bottom + h.height + f
            } else {
                a = d.top - h.height - h.top - f
            }
            break;
        case this.DIRECTION_RIGHT:
            if (g) {
                e = d.right - h.right + h.width + f
            } else {
                e = d.left - h.left - h.width - f
            }
            break;
        case this.DIRECTION_LEFT:
            if (g) {
                e = d.left - h.left - h.width - f
            } else {
                e = d.right - h.right + h.width + f
            }
            break
        }
        n = (g) ? 0 : e;
        k = (g) ? 0 : a;
        if (b) {
            p.setTransform({
                translateX: n,
                translateY: k
            })
        } else {
            p.set("left", n);
            p.set("top", k)
        }
        m = (g) ? e: 0;
        j = (g) ? a: 0;
        if (b) {
            q.setTransform({
                translateX: m,
                translateY: j
            })
        } else {
            q.set("left", m);
            q.set("top", j)
        }
        return this.callParent(arguments)
    }
});
Ext.define("Ext.fx.animation.SlideOut", {
    extend: Ext.fx.animation.Slide,
    alias: ["animation.slideOut"],
    config: {
        out: true
    }
});
Ext.define("Ext.fx.animation.Fade", {
    extend: Ext.fx.animation.Abstract,
    alternateClassName: "Ext.fx.animation.FadeIn",
    alias: ["animation.fade", "animation.fadeIn"],
    config: {
        out: false,
        before: {
            display: null,
            opacity: 0
        },
        after: {
            opacity: null
        },
        reverse: null
    },
    updateOut: function(a) {
        var d = this.getTo(),
        b = this.getFrom();
        if (a) {
            b.set("opacity", 1);
            d.set("opacity", 0)
        } else {
            b.set("opacity", 0);
            d.set("opacity", 1)
        }
    }
});
Ext.define("Ext.fx.animation.FadeOut", {
    extend: Ext.fx.animation.Fade,
    alias: "animation.fadeOut",
    config: {
        out: true,
        before: {}
    }
});
Ext.define("Ext.fx.animation.Flip", {
    extend: Ext.fx.animation.Abstract,
    alias: "animation.flip",
    config: {
        easing: "ease-in",
        direction: "right",
        half: false,
        out: null
    },
    getData: function() {
        var i = this.getFrom(),
        j = this.getTo(),
        h = this.getDirection(),
        b = this.getOut(),
        n = this.getHalf(),
        d = (n) ? 90 : 180,
        f = 1,
        a = 1,
        m = 0,
        k = 0,
        g = 0,
        e = 0;
        if (b) {
            a = 0.8
        } else {
            f = 0.8
        }
        switch (h) {
        case this.DIRECTION_UP:
            if (b) {
                g = d
            } else {
                m = -d
            }
            break;
        case this.DIRECTION_DOWN:
            if (b) {
                g = -d
            } else {
                m = d
            }
            break;
        case this.DIRECTION_RIGHT:
            if (b) {
                e = d
            } else {
                k = -d
            }
            break;
        case this.DIRECTION_LEFT:
            if (b) {
                e = -d
            } else {
                k = d
            }
            break
        }
        i.setTransform({
            rotateX: m,
            rotateY: k,
            scale: f
        });
        j.setTransform({
            rotateX: g,
            rotateY: e,
            scale: a
        });
        return this.callParent(arguments)
    }
});
Ext.define("Ext.fx.animation.Pop", {
    extend: Ext.fx.animation.Abstract,
    alias: ["animation.pop", "animation.popIn"],
    alternateClassName: "Ext.fx.animation.PopIn",
    config: {
        out: false,
        before: {
            display: null,
            opacity: 0
        },
        after: {
            opacity: null
        }
    },
    getData: function() {
        var d = this.getTo(),
        b = this.getFrom(),
        a = this.getOut();
        if (a) {
            b.set("opacity", 1);
            b.setTransform({
                scale: 1
            });
            d.set("opacity", 0);
            d.setTransform({
                scale: 0
            })
        } else {
            b.set("opacity", 0);
            b.setTransform({
                scale: 0
            });
            d.set("opacity", 1);
            d.setTransform({
                scale: 1
            })
        }
        return this.callParent(arguments)
    }
});
Ext.define("Ext.fx.animation.PopOut", {
    extend: Ext.fx.animation.Pop,
    alias: "animation.popOut",
    config: {
        out: true,
        before: {}
    }
});
Ext.define("Ext.fx.Animation", {
    constructor: function(b) {
        var a = Ext.fx.animation.Abstract,
        d;
        if (typeof b == "string") {
            d = b;
            b = {}
        } else {
            if (b && b.type) {
                d = b.type
            }
        }
        if (d) {
            if (Ext.browser.is.AndroidStock2) {
                if (d == "pop") {
                    d = "fade"
                }
                if (d == "popIn") {
                    d = "fadeIn"
                }
                if (d == "popOut") {
                    d = "fadeOut"
                }
            }
            a = Ext.ClassManager.getByAlias("animation." + d)
        }
        return Ext.factory(b, a)
    }
});
Ext.define("Ext.fx.layout.card.Style", {
    extend: Ext.fx.layout.card.Abstract,
    config: {
        inAnimation: {
            before: {
                visibility: null
            },
            preserveEndState: false,
            replacePrevious: true
        },
        outAnimation: {
            preserveEndState: false,
            replacePrevious: true
        }
    },
    constructor: function(b) {
        var d, a;
        this.initConfig(b);
        this.endAnimationCounter = 0;
        d = this.getInAnimation();
        a = this.getOutAnimation();
        d.on("animationend", "incrementEnd", this);
        a.on("animationend", "incrementEnd", this)
    },
    updateDirection: function(a) {
        this.getInAnimation().setDirection(a);
        this.getOutAnimation().setDirection(a)
    },
    updateDuration: function(a) {
        this.getInAnimation().setDuration(a);
        this.getOutAnimation().setDuration(a)
    },
    updateReverse: function(a) {
        this.getInAnimation().setReverse(a);
        this.getOutAnimation().setReverse(a)
    },
    incrementEnd: function() {
        this.endAnimationCounter++;
        if (this.endAnimationCounter > 1) {
            this.endAnimationCounter = 0;
            this.fireEvent("animationend", this)
        }
    },
    applyInAnimation: function(b, a) {
        return Ext.factory(b, Ext.fx.Animation, a)
    },
    applyOutAnimation: function(b, a) {
        return Ext.factory(b, Ext.fx.Animation, a)
    },
    updateInAnimation: function(a) {
        a.setScope(this)
    },
    updateOutAnimation: function(a) {
        a.setScope(this)
    },
    onActiveItemChange: function(a, f, i, j, e) {
        var b = this.getInAnimation(),
        h = this.getOutAnimation(),
        g,
        d;
        if (f && i && i.isPainted()) {
            g = f.renderElement;
            d = i.renderElement;
            b.setElement(g);
            h.setElement(d);
            h.setOnBeforeEnd(function(k, m) {
                if (m || Ext.Animator.hasRunningAnimations(k)) {
                    e.firingArguments[1] = null;
                    e.firingArguments[2] = null
                }
            });
            h.setOnEnd(function() {
                e.resume()
            });
            g.dom.style.setProperty("visibility", "hidden", "important");
            f.show();
            Ext.Animator.run([h, b]);
            e.pause()
        }
    },
    destroy: function() {
        Ext.destroy(this.getInAnimation(), this.getOutAnimation());
        this.callParent(arguments)
    }
});
Ext.define("Ext.fx.layout.card.Slide", {
    extend: Ext.fx.layout.card.Style,
    alias: "fx.layout.card.slide",
    config: {
        inAnimation: {
            type: "slide",
            easing: "ease-out"
        },
        outAnimation: {
            type: "slide",
            easing: "ease-out",
            out: true
        }
    },
    updateReverse: function(a) {
        this.getInAnimation().setReverse(a);
        this.getOutAnimation().setReverse(a)
    }
});
Ext.define("Ext.fx.layout.card.Cover", {
    extend: Ext.fx.layout.card.Style,
    alias: "fx.layout.card.cover",
    config: {
        reverse: null,
        inAnimation: {
            before: {
                "z-index": 100
            },
            after: {
                "z-index": 0
            },
            type: "slide",
            easing: "ease-out"
        },
        outAnimation: {
            easing: "ease-out",
            from: {
                opacity: 0.99
            },
            to: {
                opacity: 1
            },
            out: true
        }
    },
    updateReverse: function(a) {
        this.getInAnimation().setReverse(a);
        this.getOutAnimation().setReverse(a)
    }
});
Ext.define("Ext.fx.layout.card.Reveal", {
    extend: Ext.fx.layout.card.Style,
    alias: "fx.layout.card.reveal",
    config: {
        inAnimation: {
            easing: "ease-out",
            from: {
                opacity: 0.99
            },
            to: {
                opacity: 1
            }
        },
        outAnimation: {
            before: {
                "z-index": 100
            },
            after: {
                "z-index": 0
            },
            type: "slide",
            easing: "ease-out",
            out: true
        }
    },
    updateReverse: function(a) {
        this.getInAnimation().setReverse(a);
        this.getOutAnimation().setReverse(a)
    }
});
Ext.define("Ext.fx.layout.card.Fade", {
    extend: Ext.fx.layout.card.Style,
    alias: "fx.layout.card.fade",
    config: {
        reverse: null,
        inAnimation: {
            type: "fade",
            easing: "ease-out"
        },
        outAnimation: {
            type: "fade",
            easing: "ease-out",
            out: true
        }
    }
});
Ext.define("Ext.fx.layout.card.Flip", {
    extend: Ext.fx.layout.card.Style,
    alias: "fx.layout.card.flip",
    config: {
        duration: 500,
        inAnimation: {
            type: "flip",
            half: true,
            easing: "ease-out",
            before: {
                "backface-visibility": "hidden"
            },
            after: {
                "backface-visibility": null
            }
        },
        outAnimation: {
            type: "flip",
            half: true,
            easing: "ease-in",
            before: {
                "backface-visibility": "hidden"
            },
            after: {
                "backface-visibility": null
            },
            out: true
        }
    },
    onActiveItemChange: function(f, d, g, b, a) {
        var e = d.element.getParent();
        e.addCls("x-layout-card-perspective");
        this.on("animationend",
        function() {
            e.removeCls("x-layout-card-perspective")
        },
        this, {
            single: true
        });
        this.callParent(arguments)
    },
    updateDuration: function(e) {
        var d = e / 2,
        b = this.getInAnimation(),
        a = this.getOutAnimation();
        b.setDelay(d);
        b.setDuration(d);
        a.setDuration(d)
    }
});
Ext.define("Ext.fx.layout.card.Pop", {
    extend: Ext.fx.layout.card.Style,
    alias: "fx.layout.card.pop",
    config: {
        duration: 500,
        inAnimation: {
            type: "pop",
            easing: "ease-out"
        },
        outAnimation: {
            type: "pop",
            easing: "ease-in",
            out: true
        }
    },
    updateDuration: function(e) {
        var d = e / 2,
        b = this.getInAnimation(),
        a = this.getOutAnimation();
        b.setDelay(d);
        b.setDuration(d);
        a.setDuration(d)
    }
});
Ext.define("Ext.fx.layout.card.Scroll", {
    extend: Ext.fx.layout.card.Abstract,
    alias: "fx.layout.card.scroll",
    config: {
        duration: 150
    },
    constructor: function(a) {
        this.initConfig(a)
    },
    getEasing: function() {
        var a = this.easing;
        if (!a) {
            this.easing = a = new Ext.fx.easing.Linear()
        }
        return a
    },
    updateDuration: function(a) {
        this.getEasing().setDuration(a)
    },
    onActiveItemChange: function(a, e, n, o, d) {
        var j = this.getDirection(),
        h = this.getEasing(),
        m,
        f,
        b,
        i,
        k,
        g;
        if (e && n) {
            if (this.isAnimating) {
                this.stopAnimation()
            }
            e.setWidth("100%");
            e.setHeight("100%");
            m = this.getLayout().container.innerElement;
            i = m.getWidth();
            k = m.getHeight();
            f = e.renderElement;
            b = n.renderElement;
            this.oldItem = n;
            this.newItem = e;
            this.currentEventController = d;
            this.containerElement = m;
            this.isReverse = g = this.getReverse();
            e.show();
            if (j == "right") {
                j = "left";
                this.isReverse = g = !g
            } else {
                if (j == "down") {
                    j = "up";
                    this.isReverse = g = !g
                }
            }
            if (j == "left") {
                if (g) {
                    h.setConfig({
                        startValue: i,
                        endValue: 0
                    });
                    m.dom.scrollLeft = i;
                    b.setLeft(i)
                } else {
                    h.setConfig({
                        startValue: 0,
                        endValue: i
                    });
                    f.setLeft(i)
                }
            } else {
                if (g) {
                    h.setConfig({
                        startValue: k,
                        endValue: 0
                    });
                    m.dom.scrollTop = k;
                    b.setTop(k)
                } else {
                    h.setConfig({
                        startValue: 0,
                        endValue: k
                    });
                    f.setTop(k)
                }
            }
            this.startAnimation();
            d.pause()
        }
    },
    startAnimation: function() {
        this.isAnimating = true;
        this.getEasing().setStartTime(Date.now());
        Ext.AnimationQueue.start(this.doAnimationFrame, this)
    },
    doAnimationFrame: function() {
        var e = this.getEasing(),
        d = this.getDirection(),
        a = "scrollTop",
        b;
        if (d == "left" || d == "right") {
            a = "scrollLeft"
        }
        if (e.isEnded) {
            this.stopAnimation()
        } else {
            b = e.getValue();
            this.containerElement.dom[a] = b
        }
    },
    stopAnimation: function() {
        var d = this,
        f = d.getDirection(),
        a = "setTop",
        e = d.oldItem,
        b = d.newItem;
        if (f == "left" || f == "right") {
            a = "setLeft"
        }
        d.currentEventController.resume();
        if (d.isReverse && e && e.renderElement && e.renderElement.dom) {
            e.renderElement[a](null)
        } else {
            if (b && b.renderElement && b.renderElement.dom) {
                b.renderElement[a](null)
            }
        }
        Ext.AnimationQueue.stop(this.doAnimationFrame, this);
        d.isAnimating = false;
        d.fireEvent("animationend", d)
    }
});
Ext.define("Ext.fx.layout.Card", {
    constructor: function(b) {
        var a = Ext.fx.layout.card.Abstract,
        d;
        if (!b) {
            return null
        }
        if (typeof b == "string") {
            d = b;
            b = {}
        } else {
            if (b.type) {
                d = b.type
            }
        }
        b.elementBox = false;
        if (d) {
            if (Ext.browser.is.AndroidStock2) {
                if (d != "fade") {
                    d = "scroll"
                }
            }
            a = Ext.ClassManager.getByAlias("fx.layout.card." + d)
        }
        return Ext.factory(b, a)
    }
});
Ext.define("Ext.layout.Card", {
    extend: Ext.layout.Default,
    alias: "layout.card",
    isCard: true,
    layoutClass: "x-layout-card",
    itemClass: "x-layout-card-item",
    applyAnimation: function(a) {
        return new Ext.fx.layout.Card(a)
    },
    updateAnimation: function(b, a) {
        if (b && b.isAnimation) {
            b.setLayout(this)
        }
        if (a) {
            a.destroy()
        }
    },
    setContainer: function(a) {
        this.callSuper(arguments);
        a.innerElement.addCls(this.layoutClass);
        a.onInitialized("onContainerInitialized", this)
    },
    onContainerInitialized: function() {
        var a = this.container,
        b = a.getInnerAt(0),
        d = a.getActiveItem();
        if (d) {
            d.show();
            if (b && b !== d) {
                b.hide()
            }
        }
        a.on("activeitemchange", "onContainerActiveItemChange", this)
    },
    onContainerActiveItemChange: function(a) {
        this.relayEvent(arguments, "doActiveItemChange")
    },
    onItemInnerStateChange: function(d, b, e) {
        this.callSuper(arguments);
        var a = this.container,
        f = a.getActiveItem();
        d.toggleCls(this.itemClass, b);
        d.setLayoutSizeFlags(b ? a.LAYOUT_BOTH: 0);
        if (b) {
            if (f !== a.innerIndexOf(d) && f !== d && d !== a.pendingActiveItem) {
                d.hide()
            }
        } else {
            if (!e && !d.isDestroyed && d.isDestroying !== true) {
                d.show()
            }
        }
    },
    doActiveItemChange: function(b, d, a) {
        if (a) {
            a.hide()
        }
        if (d) {
            d.show()
        }
    },
    destroy: function() {
        this.callParent(arguments);
        Ext.destroy(this.getAnimation())
    }
});
Ext.define("Ext.layout.Box", {
    extend: Ext.layout.Default,
    config: {
        orient: "horizontal",
        align: "start",
        pack: "start"
    },
    alias: "layout.tablebox",
    layoutBaseClass: "x-layout-tablebox",
    itemClass: "x-layout-tablebox-item",
    setContainer: function(a) {
        this.callSuper(arguments);
        a.innerElement.addCls(this.layoutBaseClass);
        a.on("flexchange", "onItemFlexChange", this, {
            delegate: "> component"
        })
    },
    onItemInnerStateChange: function(b, a) {
        this.callSuper(arguments);
        b.toggleCls(this.itemClass, a)
    },
    onItemFlexChange: function() {}
});
Ext.define("Ext.layout.FlexBox", {
    extend: Ext.layout.Box,
    alias: "layout.box",
    config: {
        align: "stretch"
    },
    layoutBaseClass: "x-layout-box",
    itemClass: "x-layout-box-item",
    setContainer: function(a) {
        this.callSuper(arguments);
        this.monitorSizeFlagsChange()
    },
    applyOrient: function(a) {
        return a
    },
    updateOrient: function(d, b) {
        var a = this.container,
        e = {
            delegate: "> component"
        };
        if (d === "horizontal") {
            this.sizePropertyName = "width"
        } else {
            this.sizePropertyName = "height"
        }
        a.innerElement.swapCls("x-" + d, "x-" + b);
        if (b) {
            a.un(b === "horizontal" ? "widthchange": "heightchange", "onItemSizeChange", this, e);
            this.redrawContainer()
        }
        a.on(d === "horizontal" ? "widthchange": "heightchange", "onItemSizeChange", this, e)
    },
    onItemInnerStateChange: function(e, d) {
        this.callSuper(arguments);
        var a, b;
        e.toggleCls(this.itemClass, d);
        if (d) {
            a = e.getFlex();
            b = e.get(this.sizePropertyName);
            if (a) {
                this.doItemFlexChange(e, a)
            } else {
                if (b) {
                    this.doItemSizeChange(e, b)
                }
            }
        }
        this.refreshItemSizeState(e)
    },
    refreshItemSizeState: function(f) {
        var d = f.isInnerItem(),
        a = this.container,
        g = a.LAYOUT_HEIGHT,
        e = a.LAYOUT_WIDTH,
        h = this.sizePropertyName,
        b = 0,
        i = a.getSizeFlags();
        if (d) {
            b |= a.LAYOUT_STRETCHED;
            if (this.getAlign() === "stretch") {
                b |= i & (h === "width" ? g: e)
            }
            if (f.getFlex()) {
                b |= i & (h === "width" ? e: g)
            }
        }
        f.setLayoutSizeFlags(b)
    },
    refreshAllItemSizedStates: function() {
        var e = this.container.innerItems,
        a, d, b;
        for (a = 0, d = e.length; a < d; a++) {
            b = e[a];
            this.refreshItemSizeState(b)
        }
    },
    onContainerSizeFlagsChange: function() {
        this.refreshAllItemSizedStates();
        this.callSuper(arguments)
    },
    onItemSizeChange: function(b, a) {
        if (b.isInnerItem()) {
            this.doItemSizeChange(b, a)
        }
    },
    doItemSizeChange: function(b, a) {
        if (a) {
            b.setFlex(null);
            this.redrawContainer()
        }
    },
    onItemFlexChange: function(b, a) {
        if (b.isInnerItem()) {
            this.doItemFlexChange(b, a);
            this.refreshItemSizeState(b)
        }
    },
    doItemFlexChange: function(b, a) {
        this.setItemFlex(b, a);
        if (a) {
            b.set(this.sizePropertyName, null)
        } else {
            this.redrawContainer()
        }
    },
    redrawContainer: function() {
        var a = this.container,
        b = a.element.dom.parentNode;
        if (b && b.nodeType !== 11) {
            a.innerElement.redraw()
        }
    },
    setItemFlex: function(d, a) {
        var b = d.element;
        b.toggleCls("x-flexed", !!a);
        if (!a) {
            a = ""
        } else {
            a = String(a)
        }
        if (Ext.browser.is.WebKit) {
            b.dom.style.setProperty("-webkit-box-flex", a, null)
        } else {
            if (Ext.browser.is.IE) {
                b.dom.style.setProperty("-ms-flex", a + " 0 0px", null)
            } else {
                b.dom.style.setProperty("flex", a + " 0 0px", null)
            }
        }
    },
    convertPosition: function(a) {
        var b = this.positionMap;
        if (b.hasOwnProperty(a)) {
            return b[a]
        }
        return a
    },
    applyAlign: function(a) {
        return this.convertPosition(a)
    },
    updateAlign: function(d, b) {
        var a = this.container;
        a.innerElement.swapCls(d, b, true, "x-align");
        if (b !== undefined) {
            this.refreshAllItemSizedStates()
        }
    },
    applyPack: function(a) {
        return this.convertPosition(a)
    },
    updatePack: function(a, b) {
        this.container.innerElement.swapCls(a, b, true, "x-pack")
    }
});
Ext.define("Ext.layout.HBox", {
    extend: Ext.layout.FlexBox,
    alias: "layout.hbox"
});
Ext.define("Ext.layout.VBox", {
    extend: Ext.layout.FlexBox,
    alias: "layout.vbox",
    config: {
        orient: "vertical"
    }
});
Ext.define("Ext.util.Filter", {
    isFilter: true,
    config: {
        property: null,
        value: null,
        filterFn: Ext.emptyFn,
        anyMatch: false,
        exactMatch: false,
        caseSensitive: false,
        root: null,
        id: undefined,
        scope: null
    },
    applyId: function(a) {
        if (!a) {
            if (this.getProperty()) {
                a = this.getProperty() + "-" + String(this.getValue())
            }
            if (!a) {
                a = Ext.id(null, "ext-filter-")
            }
        }
        return a
    },
    constructor: function(a) {
        this.initConfig(a)
    },
    applyFilterFn: function(b) {
        if (b === Ext.emptyFn) {
            b = this.getInitialConfig("filter");
            if (b) {
                return b
            }
            var a = this.getValue();
            if (!this.getProperty() && !a && a !== 0) {
                return Ext.emptyFn
            } else {
                return this.createFilterFn()
            }
        }
        return b
    },
    createFilterFn: function() {
        var a = this,
        b = a.createValueMatcher();
        return function(e) {
            var d = a.getRoot(),
            f = a.getProperty();
            if (d) {
                e = e[d]
            }
            return b.test(e[f])
        }
    },
    createValueMatcher: function() {
        var e = this,
        f = e.getValue(),
        g = e.getAnyMatch(),
        d = e.getExactMatch(),
        a = e.getCaseSensitive(),
        b = Ext.String.escapeRegex;
        if (f === null || f === undefined || !f.exec) {
            f = String(f);
            if (g === true) {
                f = b(f)
            } else {
                f = "^" + b(f);
                if (d === true) {
                    f += "$"
                }
            }
            f = new RegExp(f, a ? "": "i")
        }
        return f
    }
});
Ext.define("Ext.util.AbstractMixedCollection", {
    mixins: {
        observable: Ext.mixin.Observable
    },
    constructor: function(b, a) {
        var d = this;
        d.items = [];
        d.map = {};
        d.keys = [];
        d.length = 0;
        d.allowFunctions = b === true;
        if (a) {
            d.getKey = a
        }
        d.mixins.observable.constructor.call(d)
    },
    allowFunctions: false,
    add: function(b, f) {
        var e = this,
        g = f,
        d = b,
        a;
        if (arguments.length == 1) {
            g = d;
            d = e.getKey(g)
        }
        if (typeof d != "undefined" && d !== null) {
            a = e.map[d];
            if (typeof a != "undefined") {
                return e.replace(d, g)
            }
            e.map[d] = g
        }
        e.length++;
        e.items.push(g);
        e.keys.push(d);
        e.fireEvent("add", e.length - 1, g, d);
        return g
    },
    getKey: function(a) {
        return a.id
    },
    replace: function(d, f) {
        var e = this,
        a, b;
        if (arguments.length == 1) {
            f = arguments[0];
            d = e.getKey(f)
        }
        a = e.map[d];
        if (typeof d == "undefined" || d === null || typeof a == "undefined") {
            return e.add(d, f)
        }
        b = e.indexOfKey(d);
        e.items[b] = f;
        e.map[d] = f;
        e.fireEvent("replace", d, a, f);
        return f
    },
    addAll: function(g) {
        var f = this,
        e = 0,
        b, a, d;
        if (arguments.length > 1 || Ext.isArray(g)) {
            b = arguments.length > 1 ? arguments: g;
            for (a = b.length; e < a; e++) {
                f.add(b[e])
            }
        } else {
            for (d in g) {
                if (g.hasOwnProperty(d)) {
                    if (f.allowFunctions || typeof g[d] != "function") {
                        f.add(d, g[d])
                    }
                }
            }
        }
    },
    each: function(f, e) {
        var b = [].concat(this.items),
        d = 0,
        a = b.length,
        g;
        for (; d < a; d++) {
            g = b[d];
            if (f.call(e || g, g, d, a) === false) {
                break
            }
        }
    },
    eachKey: function(f, e) {
        var g = this.keys,
        b = this.items,
        d = 0,
        a = g.length;
        for (; d < a; d++) {
            f.call(e || window, g[d], b[d], d, a)
        }
    },
    findBy: function(f, e) {
        var g = this.keys,
        b = this.items,
        d = 0,
        a = b.length;
        for (; d < a; d++) {
            if (f.call(e || window, b[d], g[d])) {
                return b[d]
            }
        }
        return null
    },
    insert: function(a, b, f) {
        var e = this,
        d = b,
        g = f;
        if (arguments.length == 2) {
            g = d;
            d = e.getKey(g)
        }
        if (e.containsKey(d)) {
            e.suspendEvents();
            e.removeAtKey(d);
            e.resumeEvents()
        }
        if (a >= e.length) {
            return e.add(d, g)
        }
        e.length++;
        Ext.Array.splice(e.items, a, 0, g);
        if (typeof d != "undefined" && d !== null) {
            e.map[d] = g
        }
        Ext.Array.splice(e.keys, a, 0, d);
        e.fireEvent("add", a, g, d);
        return g
    },
    remove: function(a) {
        return this.removeAt(this.indexOf(a))
    },
    removeAll: function(a) {
        Ext.each(a || [],
        function(b) {
            this.remove(b)
        },
        this);
        return this
    },
    removeAt: function(a) {
        var d = this,
        e, b;
        if (a < d.length && a >= 0) {
            d.length--;
            e = d.items[a];
            Ext.Array.erase(d.items, a, 1);
            b = d.keys[a];
            if (typeof b != "undefined") {
                delete d.map[b]
            }
            Ext.Array.erase(d.keys, a, 1);
            d.fireEvent("remove", e, b);
            return e
        }
        return false
    },
    removeAtKey: function(a) {
        return this.removeAt(this.indexOfKey(a))
    },
    getCount: function() {
        return this.length
    },
    indexOf: function(a) {
        return Ext.Array.indexOf(this.items, a)
    },
    indexOfKey: function(a) {
        return Ext.Array.indexOf(this.keys, a)
    },
    get: function(b) {
        var e = this,
        a = e.map[b],
        d = a !== undefined ? a: (typeof b == "number") ? e.items[b] : undefined;
        return typeof d != "function" || e.allowFunctions ? d: null
    },
    getAt: function(a) {
        return this.items[a]
    },
    getByKey: function(a) {
        return this.map[a]
    },
    contains: function(a) {
        return Ext.Array.contains(this.items, a)
    },
    containsKey: function(a) {
        return typeof this.map[a] != "undefined"
    },
    clear: function() {
        var a = this;
        a.length = 0;
        a.items = [];
        a.keys = [];
        a.map = {};
        a.fireEvent("clear")
    },
    first: function() {
        return this.items[0]
    },
    last: function() {
        return this.items[this.length - 1]
    },
    sum: function(h, b, j, a) {
        var d = this.extractValues(h, b),
        g = d.length,
        f = 0,
        e;
        j = j || 0;
        a = (a || a === 0) ? a: g - 1;
        for (e = j; e <= a; e++) {
            f += d[e]
        }
        return f
    },
    collect: function(k, f, h) {
        var m = this.extractValues(k, f),
        a = m.length,
        b = {},
        d = [],
        j,
        g,
        e;
        for (e = 0; e < a; e++) {
            j = m[e];
            g = String(j);
            if ((h || !Ext.isEmpty(j)) && !b[g]) {
                b[g] = true;
                d.push(j)
            }
        }
        return d
    },
    extractValues: function(d, a) {
        var b = this.items;
        if (a) {
            b = Ext.Array.pluck(b, a)
        }
        return Ext.Array.pluck(b, d)
    },
    getRange: function(g, a) {
        var f = this,
        d = f.items,
        b = [],
        e;
        if (d.length < 1) {
            return b
        }
        g = g || 0;
        a = Math.min(typeof a == "undefined" ? f.length - 1 : a, f.length - 1);
        if (g <= a) {
            for (e = g; e <= a; e++) {
                b[b.length] = d[e]
            }
        } else {
            for (e = g; e >= a; e--) {
                b[b.length] = d[e]
            }
        }
        return b
    },
    filter: function(e, d, g, a) {
        var b = [],
        f;
        if (Ext.isString(e)) {
            b.push(Ext.create("Ext.util.Filter", {
                property: e,
                value: d,
                anyMatch: g,
                caseSensitive: a
            }))
        } else {
            if (Ext.isArray(e) || e instanceof Ext.util.Filter) {
                b = b.concat(e)
            }
        }
        f = function(h) {
            var o = true,
            p = b.length,
            j;
            for (j = 0; j < p; j++) {
                var n = b[j],
                m = n.getFilterFn(),
                k = n.getScope();
                o = o && m.call(k, h)
            }
            return o
        };
        return this.filterBy(f)
    },
    filterBy: function(f, e) {
        var j = this,
        a = new this.self(),
        h = j.keys,
        b = j.items,
        g = b.length,
        d;
        a.getKey = j.getKey;
        for (d = 0; d < g; d++) {
            if (f.call(e || j, b[d], h[d])) {
                a.add(h[d], b[d])
            }
        }
        return a
    },
    findIndex: function(d, b, f, e, a) {
        if (Ext.isEmpty(b, false)) {
            return - 1
        }
        b = this.createValueMatcher(b, e, a);
        return this.findIndexBy(function(g) {
            return g && b.test(g[d])
        },
        null, f)
    },
    findIndexBy: function(f, e, j) {
        var h = this,
        g = h.keys,
        b = h.items,
        d = j || 0,
        a = b.length;
        for (; d < a; d++) {
            if (f.call(e || h, b[d], g[d])) {
                return d
            }
        }
        return - 1
    },
    createValueMatcher: function(d, f, a, b) {
        if (!d.exec) {
            var e = Ext.String.escapeRegex;
            d = String(d);
            if (f === true) {
                d = e(d)
            } else {
                d = "^" + e(d);
                if (b === true) {
                    d += "$"
                }
            }
            d = new RegExp(d, a ? "": "i")
        }
        return d
    },
    clone: function() {
        var f = this,
        g = new this.self(),
        e = f.keys,
        b = f.items,
        d = 0,
        a = b.length;
        for (; d < a; d++) {
            g.add(e[d], b[d])
        }
        g.getKey = f.getKey;
        return g
    }
});
Ext.define("Ext.util.Sorter", {
    isSorter: true,
    config: {
        property: null,
        sorterFn: null,
        root: null,
        transform: null,
        direction: "ASC",
        id: undefined
    },
    constructor: function(a) {
        this.initConfig(a)
    },
    applyId: function(a) {
        if (!a) {
            a = this.getProperty();
            if (!a) {
                a = Ext.id(null, "ext-sorter-")
            }
        }
        return a
    },
    createSortFunction: function(b) {
        var d = this,
        a = d.getDirection().toUpperCase() == "DESC" ? -1 : 1;
        return function(f, e) {
            return a * b.call(d, f, e)
        }
    },
    defaultSortFn: function(f, d) {
        var h = this,
        g = h._transform,
        b = h._root,
        e, a, i = h._property;
        if (b !== null && b !== undefined) {
            f = f[b];
            d = d[b]
        }
        e = f[i];
        a = d[i];
        if (g) {
            e = g(e);
            a = g(a)
        }
        return e > a ? 1 : (e < a ? -1 : 0)
    },
    updateDirection: function() {
        this.updateSortFn()
    },
    updateSortFn: function() {
        this.sort = this.createSortFunction(this.getSorterFn() || this.defaultSortFn)
    },
    toggle: function() {
        this.setDirection(Ext.String.toggle(this.getDirection(), "ASC", "DESC"))
    }
});
Ext.define("Ext.util.Sortable", {
    extend: Ext.mixin.Mixin,
    isSortable: true,
    mixinConfig: {
        hooks: {
            destroy: "destroy"
        }
    },
    defaultSortDirection: "ASC",
    initSortable: function() {
        var a = this,
        b = a.sorters;
        a.sorters = Ext.create("Ext.util.AbstractMixedCollection", false,
        function(d) {
            return d.id || d.property
        });
        if (b) {
            a.sorters.addAll(a.decodeSorters(b))
        }
    },
    sort: function(h, g, d, f) {
        var e = this,
        i, b, a;
        if (Ext.isArray(h)) {
            f = d;
            d = g;
            a = h
        } else {
            if (Ext.isObject(h)) {
                f = d;
                d = g;
                a = [h]
            } else {
                if (Ext.isString(h)) {
                    i = e.sorters.get(h);
                    if (!i) {
                        i = {
                            property: h,
                            direction: g
                        };
                        a = [i]
                    } else {
                        if (g === undefined) {
                            i.toggle()
                        } else {
                            i.setDirection(g)
                        }
                    }
                }
            }
        }
        if (a && a.length) {
            a = e.decodeSorters(a);
            if (Ext.isString(d)) {
                if (d === "prepend") {
                    h = e.sorters.clone().items;
                    e.sorters.clear();
                    e.sorters.addAll(a);
                    e.sorters.addAll(h)
                } else {
                    e.sorters.addAll(a)
                }
            } else {
                e.sorters.clear();
                e.sorters.addAll(a)
            }
            if (f !== false) {
                e.onBeforeSort(a)
            }
        }
        if (f !== false) {
            h = e.sorters.items;
            if (h.length) {
                b = function(m, k) {
                    var j = h[0].sort(m, k),
                    o = h.length,
                    n;
                    for (n = 1; n < o; n++) {
                        j = j || h[n].sort.call(this, m, k)
                    }
                    return j
                };
                e.doSort(b)
            }
        }
        return h
    },
    onBeforeSort: Ext.emptyFn,
    decodeSorters: function(g) {
        if (!Ext.isArray(g)) {
            if (g === undefined) {
                g = []
            } else {
                g = [g]
            }
        }
        var e = g.length,
        h = Ext.util.Sorter,
        a = this.model ? this.model.prototype.fields: null,
        f,
        b,
        d;
        for (d = 0; d < e; d++) {
            b = g[d];
            if (! (b instanceof h)) {
                if (Ext.isString(b)) {
                    b = {
                        property: b
                    }
                }
                Ext.applyIf(b, {
                    root: this.sortRoot,
                    direction: "ASC"
                });
                if (b.fn) {
                    b.sorterFn = b.fn
                }
                if (typeof b == "function") {
                    b = {
                        sorterFn: b
                    }
                }
                if (a && !b.transform) {
                    f = a.get(b.property);
                    b.transform = f ? f.sortType: undefined
                }
                g[d] = Ext.create("Ext.util.Sorter", b)
            }
        }
        return g
    },
    getSorters: function() {
        return this.sorters.items
    },
    destroy: function() {
        this.callSuper();
        Ext.destroy(this.sorters)
    }
});
Ext.define("Ext.util.MixedCollection", {
    extend: Ext.util.AbstractMixedCollection,
    mixins: {
        sortable: Ext.util.Sortable
    },
    constructor: function() {
        var a = this;
        a.callParent(arguments);
        a.mixins.sortable.initSortable.call(a)
    },
    doSort: function(a) {
        this.sortBy(a)
    },
    _sort: function(k, a, j) {
        var h = this,
        d, e, b = String(a).toUpperCase() == "DESC" ? -1 : 1,
        g = [],
        m = h.keys,
        f = h.items;
        j = j ||
        function(n, i) {
            return n - i
        };
        for (d = 0, e = f.length; d < e; d++) {
            g[g.length] = {
                key: m[d],
                value: f[d],
                index: d
            }
        }
        Ext.Array.sort(g,
        function(n, i) {
            var o = j(n[k], i[k]) * b;
            if (o === 0) {
                o = (n.index < i.index ? -1 : 1)
            }
            return o
        });
        for (d = 0, e = g.length; d < e; d++) {
            f[d] = g[d].value;
            m[d] = g[d].key
        }
        h.fireEvent("sort", h)
    },
    sortBy: function(d) {
        var h = this,
        b = h.items,
        g = h.keys,
        f = b.length,
        a = [],
        e;
        for (e = 0; e < f; e++) {
            a[e] = {
                key: g[e],
                value: b[e],
                index: e
            }
        }
        Ext.Array.sort(a,
        function(j, i) {
            var k = d(j.value, i.value);
            if (k === 0) {
                k = (j.index < i.index ? -1 : 1)
            }
            return k
        });
        for (e = 0; e < f; e++) {
            b[e] = a[e].value;
            g[e] = a[e].key
        }
        h.fireEvent("sort", h, b, g)
    },
    reorder: function(e) {
        var h = this,
        b = h.items,
        d = 0,
        g = b.length,
        a = [],
        f = [],
        i;
        h.suspendEvents();
        for (i in e) {
            a[e[i]] = b[i]
        }
        for (d = 0; d < g; d++) {
            if (e[d] == undefined) {
                f.push(b[d])
            }
        }
        for (d = 0; d < g; d++) {
            if (a[d] == undefined) {
                a[d] = f.shift()
            }
        }
        h.clear();
        h.addAll(a);
        h.resumeEvents();
        h.fireEvent("sort", h)
    },
    sortByKey: function(a, b) {
        this._sort("key", a, b ||
        function(e, d) {
            var g = String(e).toUpperCase(),
            f = String(d).toUpperCase();
            return g > f ? 1 : (g < f ? -1 : 0)
        })
    }
});
Ext.define("Ext.ItemCollection", {
    extend: Ext.util.MixedCollection,
    getKey: function(a) {
        return a.getItemId()
    },
    has: function(a) {
        return this.map.hasOwnProperty(a.getId())
    }
});
Ext.define("Ext.fx.easing.Momentum", {
    extend: Ext.fx.easing.Abstract,
    config: {
        acceleration: 30,
        friction: 0,
        startVelocity: 0
    },
    alpha: 0,
    updateFriction: function(b) {
        var a = Math.log(1 - (b / 10));
        this.theta = a;
        this.alpha = a / this.getAcceleration()
    },
    updateStartVelocity: function(a) {
        this.velocity = a * this.getAcceleration()
    },
    updateAcceleration: function(a) {
        this.velocity = this.getStartVelocity() * a;
        this.alpha = this.theta / a
    },
    getValue: function() {
        return this.getStartValue() - this.velocity * (1 - this.getFrictionFactor()) / this.theta
    },
    getFrictionFactor: function() {
        var a = Ext.Date.now() - this.getStartTime();
        return Math.exp(a * this.alpha)
    },
    getVelocity: function() {
        return this.getFrictionFactor() * this.velocity
    }
});
Ext.define("Ext.fx.easing.Bounce", {
    extend: Ext.fx.easing.Abstract,
    config: {
        springTension: 0.3,
        acceleration: 30,
        startVelocity: 0
    },
    getValue: function() {
        var b = Ext.Date.now() - this.getStartTime(),
        d = (b / this.getAcceleration()),
        a = d * Math.pow(Math.E, -this.getSpringTension() * d);
        return this.getStartValue() + (this.getStartVelocity() * a)
    }
});
Ext.define("Ext.fx.easing.BoundMomentum", {
    extend: Ext.fx.easing.Abstract,
    config: {
        momentum: null,
        bounce: null,
        minMomentumValue: 0,
        maxMomentumValue: 0,
        minVelocity: 0.01,
        startVelocity: 0
    },
    applyMomentum: function(a, b) {
        return Ext.factory(a, Ext.fx.easing.Momentum, b)
    },
    applyBounce: function(a, b) {
        return Ext.factory(a, Ext.fx.easing.Bounce, b)
    },
    updateStartTime: function(a) {
        this.getMomentum().setStartTime(a);
        this.callParent(arguments)
    },
    updateStartVelocity: function(a) {
        this.getMomentum().setStartVelocity(a)
    },
    updateStartValue: function(a) {
        this.getMomentum().setStartValue(a)
    },
    reset: function() {
        this.lastValue = null;
        this.isBouncingBack = false;
        this.isOutOfBound = false;
        return this.callParent(arguments)
    },
    getValue: function() {
        var a = this.getMomentum(),
        k = this.getBounce(),
        f = a.getStartVelocity(),
        g = f > 0 ? 1 : -1,
        h = this.getMinMomentumValue(),
        e = this.getMaxMomentumValue(),
        d = (g == 1) ? e: h,
        i = this.lastValue,
        j,
        b;
        if (f === 0) {
            return this.getStartValue()
        }
        if (!this.isOutOfBound) {
            j = a.getValue();
            b = a.getVelocity();
            if (Math.abs(b) < this.getMinVelocity()) {
                this.isEnded = true
            }
            if (j >= h && j <= e) {
                return j
            }
            this.isOutOfBound = true;
            k.setStartTime(Ext.Date.now()).setStartVelocity(b).setStartValue(d)
        }
        j = k.getValue();
        if (!this.isEnded) {
            if (!this.isBouncingBack) {
                if (i !== null) {
                    if ((g == 1 && j < i) || (g == -1 && j > i)) {
                        this.isBouncingBack = true
                    }
                }
            } else {
                if (Math.round(j) == d) {
                    this.isEnded = true
                }
            }
        }
        this.lastValue = j;
        return j
    }
});
Ext.define("Ext.fx.easing.EaseOut", {
    extend: Ext.fx.easing.Linear,
    alias: "easing.ease-out",
    config: {
        exponent: 4,
        duration: 1500
    },
    getValue: function() {
        var g = Ext.Date.now() - this.getStartTime(),
        e = this.getDuration(),
        b = this.getStartValue(),
        i = this.getEndValue(),
        a = this.distance,
        d = g / e,
        h = 1 - d,
        f = 1 - Math.pow(h, this.getExponent()),
        j = b + (f * a);
        if (g >= e) {
            this.isEnded = true;
            return i
        }
        return j
    }
});
Ext.define("Ext.scroll.Scroller", {
    extend: Ext.Evented,
    config: {
        element: null,
        direction: "auto",
        fps: "auto",
        disabled: null,
        directionLock: false,
        momentumEasing: {
            momentum: {
                acceleration: 30,
                friction: 0.5
            },
            bounce: {
                acceleration: 30,
                springTension: 0.3
            },
            minVelocity: 1
        },
        bounceEasing: {
            duration: 400
        },
        outOfBoundRestrictFactor: 0.5,
        startMomentumResetTime: 300,
        maxAbsoluteVelocity: 6,
        containerSize: "auto",
        size: "auto",
        autoRefresh: true,
        initialOffset: {
            x: 0,
            y: 0
        },
        slotSnapSize: {
            x: 0,
            y: 0
        },
        slotSnapOffset: {
            x: 0,
            y: 0
        },
        slotSnapEasing: {
            duration: 150
        },
        translatable: {
            translationMethod: "auto",
            useWrapper: false
        }
    },
    cls: Ext.baseCSSPrefix + "scroll-scroller",
    containerCls: Ext.baseCSSPrefix + "scroll-container",
    dragStartTime: 0,
    dragEndTime: 0,
    isDragging: false,
    isAnimating: false,
    constructor: function(a) {
        var b = a && a.element;
        this.listeners = {
            scope: this,
            touchstart: "onTouchStart",
            touchend: "onTouchEnd",
            dragstart: "onDragStart",
            drag: "onDrag",
            dragend: "onDragEnd"
        };
        this.minPosition = {
            x: 0,
            y: 0
        };
        this.startPosition = {
            x: 0,
            y: 0
        };
        this.position = {
            x: 0,
            y: 0
        };
        this.velocity = {
            x: 0,
            y: 0
        };
        this.isAxisEnabledFlags = {
            x: false,
            y: false
        };
        this.flickStartPosition = {
            x: 0,
            y: 0
        };
        this.flickStartTime = {
            x: 0,
            y: 0
        };
        this.lastDragPosition = {
            x: 0,
            y: 0
        };
        this.dragDirection = {
            x: 0,
            y: 0
        };
        this.initialConfig = a;
        if (b) {
            this.setElement(b)
        }
        return this
    },
    applyElement: function(a) {
        if (!a) {
            return
        }
        return Ext.get(a)
    },
    updateElement: function(a) {
        this.initialize();
        if (!this.FixedHBoxStretching) {
            a.addCls(this.cls)
        }
        if (!this.getDisabled()) {
            this.attachListeneners()
        }
        this.onConfigUpdate(["containerSize", "size"], "refreshMaxPosition");
        this.on("maxpositionchange", "snapToBoundary");
        this.on("minpositionchange", "snapToBoundary");
        return this
    },
    applyTranslatable: function(b, a) {
        return Ext.factory(b, Ext.util.Translatable, a)
    },
    updateTranslatable: function(a) {
        a.setConfig({
            element: this.getElement(),
            listeners: {
                animationframe: "onAnimationFrame",
                animationend: "onAnimationEnd",
                scope: this
            }
        })
    },
    updateFps: function(a) {
        if (a !== "auto") {
            this.getTranslatable().setFps(a)
        }
    },
    attachListeneners: function() {
        this.getContainer().on(this.listeners)
    },
    detachListeners: function() {
        this.getContainer().un(this.listeners)
    },
    updateDisabled: function(a) {
        if (a) {
            this.detachListeners()
        } else {
            this.attachListeneners()
        }
    },
    updateInitialOffset: function(d) {
        if (typeof d == "number") {
            d = {
                x: d,
                y: d
            }
        }
        var b = this.position,
        a, e;
        b.x = a = d.x;
        b.y = e = d.y;
        this.getTranslatable().translate( - a, -e)
    },
    applyDirection: function(a) {
        var f = this.getMinPosition(),
        e = this.getMaxPosition(),
        d,
        b;
        this.givenDirection = a;
        if (a === "auto") {
            d = e.x > f.x;
            b = e.y > f.y;
            if (d && b) {
                a = "both"
            } else {
                if (d) {
                    a = "horizontal"
                } else {
                    a = "vertical"
                }
            }
        }
        return a
    },
    updateDirection: function(g, f) {
        var b = this.isAxisEnabledFlags,
        e = this.cls + "-vertical",
        a = this.cls + "-horizontal",
        d = this.getElement();
        if (f === "both" || f === "horizontal") {
            d.removeCls(a)
        }
        if (f === "both" || f === "vertical") {
            d.removeCls(e)
        }
        b.x = b.y = false;
        if (g === "both" || g === "horizontal") {
            b.x = true;
            d.addCls(a)
        }
        if (g === "both" || g === "vertical") {
            b.y = true;
            d.addCls(e)
        }
    },
    isAxisEnabled: function(a) {
        this.getDirection();
        return this.isAxisEnabledFlags[a]
    },
    applyMomentumEasing: function(b) {
        var a = Ext.fx.easing.BoundMomentum;
        return {
            x: Ext.factory(b, a),
            y: Ext.factory(b, a)
        }
    },
    applyBounceEasing: function(b) {
        var a = Ext.fx.easing.EaseOut;
        return {
            x: Ext.factory(b, a),
            y: Ext.factory(b, a)
        }
    },
    updateBounceEasing: function(a) {
        this.getTranslatable().setEasingX(a.x).setEasingY(a.y)
    },
    applySlotSnapEasing: function(b) {
        var a = Ext.fx.easing.EaseOut;
        return {
            x: Ext.factory(b, a),
            y: Ext.factory(b, a)
        }
    },
    getMinPosition: function() {
        var a = this.minPosition;
        if (!a) {
            this.minPosition = a = {
                x: 0,
                y: 0
            };
            this.fireEvent("minpositionchange", this, a)
        }
        return a
    },
    getMaxPosition: function() {
        var d = this.maxPosition,
        a, b;
        if (!d) {
            a = this.getSize();
            b = this.getContainerSize();
            this.maxPosition = d = {
                x: Math.max(0, a.x - b.x),
                y: Math.max(0, a.y - b.y)
            };
            this.fireEvent("maxpositionchange", this, d)
        }
        return d
    },
    refreshMaxPosition: function() {
        this.maxPosition = null;
        this.getMaxPosition()
    },
    applyContainerSize: function(b) {
        var d = this.getContainer().dom,
        a,
        e;
        if (!d) {
            return
        }
        this.givenContainerSize = b;
        if (b === "auto") {
            a = d.offsetWidth;
            e = d.offsetHeight
        } else {
            a = b.x;
            e = b.y
        }
        return {
            x: a,
            y: e
        }
    },
    applySize: function(b) {
        var d = this.getElement().dom,
        a,
        e;
        if (!d) {
            return
        }
        this.givenSize = b;
        if (b === "auto") {
            a = d.offsetWidth;
            e = d.offsetHeight
        } else {
            if (typeof b == "number") {
                a = b;
                e = b
            } else {
                a = b.x;
                e = b.y
            }
        }
        return {
            x: a,
            y: e
        }
    },
    updateAutoRefresh: function(a) {
        this.getElement().toggleListener(a, "resize", "onElementResize", this);
        this.getContainer().toggleListener(a, "resize", "onContainerResize", this)
    },
    applySlotSnapSize: function(a) {
        if (typeof a == "number") {
            return {
                x: a,
                y: a
            }
        }
        return a
    },
    applySlotSnapOffset: function(a) {
        if (typeof a == "number") {
            return {
                x: a,
                y: a
            }
        }
        return a
    },
    getContainer: function() {
        var a = this.container,
        b;
        if (!a) {
            b = this.getElement().getParent();
            this.container = a = this.FixedHBoxStretching ? b.getParent() : b;
            a.addCls(this.containerCls)
        }
        return a
    },
    refresh: function() {
        this.stopAnimation();
        this.getTranslatable().refresh();
        this.setSize(this.givenSize);
        this.setContainerSize(this.givenContainerSize);
        this.setDirection(this.givenDirection);
        this.fireEvent("refresh", this);
        return this
    },
    onElementResize: function(a, b) {
        this.setSize({
            x: b.width,
            y: b.height
        });
        this.refresh()
    },
    onContainerResize: function(a, b) {
        this.setContainerSize({
            x: b.width,
            y: b.height
        });
        this.refresh()
    },
    scrollTo: function(d, i, h) {
        if (this.isDestroyed) {
            return this
        }
        var b = this.getTranslatable(),
        a = this.position,
        e = false,
        g,
        f;
        if (this.isAxisEnabled("x")) {
            if (isNaN(d) || typeof d != "number") {
                d = a.x
            } else {
                if (a.x !== d) {
                    a.x = d;
                    e = true
                }
            }
            g = -d
        }
        if (this.isAxisEnabled("y")) {
            if (isNaN(i) || typeof i != "number") {
                i = a.y
            } else {
                if (a.y !== i) {
                    a.y = i;
                    e = true
                }
            }
            f = -i
        }
        if (e) {
            if (h !== undefined && h !== false) {
                b.translateAnimated(g, f, h)
            } else {
                this.fireEvent("scroll", this, a.x, a.y);
                b.translate(g, f)
            }
        }
        return this
    },
    scrollToTop: function(b) {
        var a = this.getInitialOffset();
        return this.scrollTo(a.x, a.y, b)
    },
    scrollToEnd: function(d) {
        var b = this.getSize(),
        a = this.getContainerSize();
        return this.scrollTo(b.x - a.x, b.y - a.y, d)
    },
    scrollBy: function(b, e, d) {
        var a = this.position;
        b = (typeof b == "number") ? b + a.x: null;
        e = (typeof e == "number") ? e + a.y: null;
        return this.scrollTo(b, e, d)
    },
    onTouchStart: function() {
        this.isTouching = true;
        this.stopAnimation()
    },
    onTouchEnd: function() {
        var a = this.position;
        this.isTouching = false;
        if (!this.isDragging && this.snapToSlot()) {
            this.fireEvent("scrollstart", this, a.x, a.y)
        }
    },
    onDragStart: function(n) {
        var q = this.getDirection(),
        h = n.absDeltaX,
        g = n.absDeltaY,
        k = this.getDirectionLock(),
        j = this.startPosition,
        f = this.flickStartPosition,
        m = this.flickStartTime,
        i = this.lastDragPosition,
        d = this.position,
        b = this.dragDirection,
        p = d.x,
        o = d.y,
        a = Ext.Date.now();
        this.isDragging = true;
        if (k && q !== "both") {
            if ((q === "horizontal" && h > g) || (q === "vertical" && g > h)) {
                n.stopPropagation()
            } else {
                this.isDragging = false;
                return
            }
        }
        i.x = p;
        i.y = o;
        f.x = p;
        f.y = o;
        j.x = p;
        j.y = o;
        m.x = a;
        m.y = a;
        b.x = 0;
        b.y = 0;
        this.dragStartTime = a;
        this.isDragging = true;
        this.fireEvent("scrollstart", this, p, o)
    },
    onAxisDrag: function(j, s) {
        if (!this.isAxisEnabled(j)) {
            return
        }
        var i = this.flickStartPosition,
        n = this.flickStartTime,
        k = this.lastDragPosition,
        f = this.dragDirection,
        h = this.position[j],
        m = this.getMinPosition()[j],
        q = this.getMaxPosition()[j],
        e = this.startPosition[j],
        r = k[j],
        p = e - s,
        d = f[j],
        o = this.getOutOfBoundRestrictFactor(),
        g = this.getStartMomentumResetTime(),
        b = Ext.Date.now(),
        a;
        if (p < m) {
            p *= o
        } else {
            if (p > q) {
                a = p - q;
                p = q + a * o
            }
        }
        if (p > r) {
            f[j] = 1
        } else {
            if (p < r) {
                f[j] = -1
            }
        }
        if ((d !== 0 && (f[j] !== d)) || (b - n[j]) > g) {
            i[j] = h;
            n[j] = b
        }
        k[j] = p
    },
    onDrag: function(b) {
        if (!this.isDragging) {
            return
        }
        var a = this.lastDragPosition;
        this.onAxisDrag("x", b.deltaX);
        this.onAxisDrag("y", b.deltaY);
        this.scrollTo(a.x, a.y)
    },
    onDragEnd: function(d) {
        var b, a;
        if (!this.isDragging) {
            return
        }
        this.dragEndTime = Ext.Date.now();
        this.onDrag(d);
        this.isDragging = false;
        b = this.getAnimationEasing("x", d);
        a = this.getAnimationEasing("y", d);
        if (b || a) {
            this.getTranslatable().animate(b, a)
        } else {
            this.onScrollEnd()
        }
    },
    getAnimationEasing: function(h, k) {
        if (!this.isAxisEnabled(h)) {
            return null
        }
        var g = this.position[h],
        d = this.getMinPosition()[h],
        j = this.getMaxPosition()[h],
        a = this.getMaxAbsoluteVelocity(),
        f = null,
        b = this.dragEndTime,
        i = k.flick.velocity[h],
        m;
        if (g < d) {
            f = d
        } else {
            if (g > j) {
                f = j
            }
        }
        if (f !== null) {
            m = this.getBounceEasing()[h];
            m.setConfig({
                startTime: b,
                startValue: -g,
                endValue: -f
            });
            return m
        }
        if (i === 0) {
            return null
        }
        if (i < -a) {
            i = -a
        } else {
            if (i > a) {
                i = a
            }
        }
        if (Ext.browser.is.IE) {
            i *= 2
        }
        m = this.getMomentumEasing()[h];
        m.setConfig({
            startTime: b,
            startValue: -g,
            startVelocity: i * 1.5,
            minMomentumValue: -j,
            maxMomentumValue: 0
        });
        return m
    },
    onAnimationFrame: function(d, b, e) {
        var a = this.position;
        a.x = -b;
        a.y = -e;
        this.fireEvent("scroll", this, a.x, a.y)
    },
    onAnimationEnd: function() {
        this.snapToBoundary();
        this.onScrollEnd()
    },
    stopAnimation: function() {
        this.getTranslatable().stopAnimation()
    },
    onScrollEnd: function() {
        var a = this.position;
        if (this.isTouching || !this.snapToSlot()) {
            this.fireEvent("scrollend", this, a.x, a.y)
        }
    },
    snapToSlot: function() {
        var b = this.getSnapPosition("x"),
        a = this.getSnapPosition("y"),
        d = this.getSlotSnapEasing();
        if (b !== null || a !== null) {
            this.scrollTo(b, a, {
                easingX: d.x,
                easingY: d.y
            });
            return true
        }
        return false
    },
    getSnapPosition: function(d) {
        var h = this.getSlotSnapSize()[d],
        e = null,
        a,
        g,
        f,
        b;
        if (h !== 0 && this.isAxisEnabled(d)) {
            a = this.position[d];
            g = this.getSlotSnapOffset()[d];
            f = this.getMaxPosition()[d];
            b = Math.floor((a - g) % h);
            if (b !== 0) {
                if (a !== f) {
                    if (Math.abs(b) > h / 2) {
                        e = Math.min(f, a + ((b > 0) ? h - b: b - h))
                    } else {
                        e = a - b
                    }
                } else {
                    e = a - b
                }
            }
        }
        return e
    },
    snapToBoundary: function() {
        var h = this.position,
        d = this.getMinPosition(),
        g = this.getMaxPosition(),
        f = d.x,
        e = d.y,
        b = g.x,
        a = g.y,
        j = Math.round(h.x),
        i = Math.round(h.y);
        if (j < f) {
            j = f
        } else {
            if (j > b) {
                j = b
            }
        }
        if (i < e) {
            i = e
        } else {
            if (i > a) {
                i = a
            }
        }
        this.scrollTo(j, i)
    },
    destroy: function() {
        var d = this.getElement(),
        b = this.sizeMonitors,
        a;
        if (b) {
            b.element.destroy();
            b.container.destroy()
        }
        if (d && !d.isDestroyed) {
            d.removeCls(this.cls);
            a = this.getContainer();
            if (a && !a.isDestroyed) {
                a.removeCls(this.containerCls)
            }
        }
        Ext.destroy(this.getTranslatable());
        this.callParent(arguments)
    }
},
function() {}); (function() {
    var d = 0,
    f = ["ms", "moz", "webkit", "o"],
    b = f.length,
    a,
    e;
    for (a = 0; a < b && !window.requestAnimationFrame; ++a) {
        e = f[a];
        if (window[e + "RequestAnimationFrame"]) {
            window.requestAnimationFrame = window[e + "RequestAnimationFrame"];
            window.cancelAnimationFrame = window[e + "CancelAnimationFrame"] || window[e + "CancelRequestAnimationFrame"]
        }
    }
    if (!window.Ext) {
        window.Ext = {}
    }
    Ext.performance = {};
    if (window.performance && window.performance.now) {
        Ext.performance.now = function() {
            return window.performance.now()
        }
    } else {
        Ext.performance.now = function() {
            return Date.now()
        }
    }
    if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function(j) {
            var g = Ext.performance.now(),
            h = Math.max(0, 16 - (g - d)),
            i = window.setTimeout(function() {
                j(g + h)
            },
            h);
            d = g + h;
            return i
        }
    } else {
        Ext.trueRequestAnimationFrames = true
    }
    if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function(g) {
            clearTimeout(g)
        }
    }
} ()); (function(a) {
    Ext.define("Ext.AnimationQueue", {
        singleton: true,
        constructor: function() {
            var b = Ext.Function.bind;
            this.queue = [];
            this.taskQueue = [];
            this.runningQueue = [];
            this.idleQueue = [];
            this.isRunning = false;
            this.isIdle = true;
            this.run = b(this.run, this);
            this.whenIdle = b(this.whenIdle, this);
            this.processIdleQueueItem = b(this.processIdleQueueItem, this);
            this.processTaskQueueItem = b(this.processTaskQueueItem, this);
            if (Ext.os.is.iOS) {
                setInterval(this.watch, 500)
            }
        },
        start: function(e, d, b) {
            this.queue.push(arguments);
            if (!this.isRunning) {
                if (this.hasOwnProperty("idleTimer")) {
                    clearTimeout(this.idleTimer);
                    delete this.idleTimer
                }
                if (this.hasOwnProperty("idleQueueTimer")) {
                    clearTimeout(this.idleQueueTimer);
                    delete this.idleQueueTimer
                }
                this.isIdle = false;
                this.isRunning = true;
                this.doStart()
            }
        },
        watch: function() {
            if (this.isRunning && Date.now() - this.lastRunTime >= 500) {
                this.run()
            }
        },
        run: function() {
            if (!this.isRunning) {
                return
            }
            var b = this.runningQueue,
            d, e;
            this.lastRunTime = Date.now();
            this.frameStartTime = Ext.performance.now();
            b.push.apply(b, this.queue);
            for (d = 0, e = b.length; d < e; d++) {
                this.invoke(b[d])
            }
            b.length = 0;
            this.doIterate()
        },
        doStart: function() {
            this.animationFrameId = requestAnimationFrame(this.run);
            this.lastRunTime = Date.now()
        },
        doIterate: function() {
            this.animationFrameId = requestAnimationFrame(this.run)
        },
        doStop: function() {
            cancelAnimationFrame(this.animationFrameId)
        },
        stop: function(g, f, d) {
            if (!this.isRunning) {
                return
            }
            var b = this.queue,
            j = b.length,
            e, h;
            for (e = 0; e < j; e++) {
                h = b[e];
                if (h[0] === g && h[1] === f && h[2] === d) {
                    b.splice(e, 1);
                    e--;
                    j--
                }
            }
            if (j === 0) {
                this.doStop();
                this.isRunning = false;
                this.idleTimer = setTimeout(this.whenIdle, 100)
            }
        },
        onIdle: function(g, f, b) {
            var e = this.idleQueue,
            d, h, j;
            for (d = 0, h = e.length; d < h; d++) {
                j = e[d];
                if (g === j[0] && f === j[1] && b === j[2]) {
                    return
                }
            }
            e.push(arguments);
            if (this.isIdle) {
                this.processIdleQueue()
            }
        },
        unIdle: function(g, f, b) {
            var e = this.idleQueue,
            d, h, j;
            for (d = 0, h = e.length; d < h; d++) {
                j = e[d];
                if (g === j[0] && f === j[1] && b === j[2]) {
                    e.splice(d, 1);
                    return true
                }
            }
            return false
        },
        queueTask: function(e, d, b) {
            this.taskQueue.push(arguments);
            this.processTaskQueue()
        },
        dequeueTask: function(g, f, b) {
            var e = this.taskQueue,
            d, h, j;
            for (d = 0, h = e.length; d < h; d++) {
                j = e[d];
                if (g === j[0] && f === j[1] && b === j[2]) {
                    e.splice(d, 1);
                    d--;
                    h--
                }
            }
        },
        invoke: function(f) {
            var e = f[0],
            d = f[1],
            b = f[2];
            e = (typeof e == "string" ? d[e] : e);
            if (Ext.isArray(b)) {
                e.apply(d, b)
            } else {
                e.call(d, b)
            }
        },
        whenIdle: function() {
            this.isIdle = true;
            this.processIdleQueue()
        },
        processIdleQueue: function() {
            if (!this.hasOwnProperty("idleQueueTimer")) {
                this.idleQueueTimer = setTimeout(this.processIdleQueueItem, 1)
            }
        },
        processIdleQueueItem: function() {
            delete this.idleQueueTimer;
            if (!this.isIdle) {
                return
            }
            var b = this.idleQueue,
            d;
            if (b.length > 0) {
                d = b.shift();
                this.invoke(d);
                this.processIdleQueue()
            }
        },
        processTaskQueue: function() {
            if (!this.hasOwnProperty("taskQueueTimer")) {
                this.taskQueueTimer = setTimeout(this.processTaskQueueItem, 15)
            }
        },
        processTaskQueueItem: function() {
            delete this.taskQueueTimer;
            var b = this.taskQueue,
            d;
            if (b.length > 0) {
                d = b.shift();
                this.invoke(d);
                this.processTaskQueue()
            }
        },
        showFps: function() {
            if (!Ext.trueRequestAnimationFrames) {
                alert("This browser does not support requestAnimationFrame. The FPS listed will not be accurate")
            }
            Ext.onReady(function() {
                Ext.Viewport.add([{
                    xtype: "component",
                    bottom: 50,
                    left: 0,
                    width: 50,
                    height: 20,
                    html: "Average",
                    style: "background-color: black; color: white; text-align: center; line-height: 20px; font-size: 8px;"
                },
                {
                    id: "__averageFps",
                    xtype: "component",
                    bottom: 0,
                    left: 0,
                    width: 50,
                    height: 50,
                    html: "0",
                    style: "background-color: red; color: white; text-align: center; line-height: 50px;"
                },
                {
                    xtype: "component",
                    bottom: 50,
                    left: 50,
                    width: 50,
                    height: 20,
                    html: "Min (Last 1k)",
                    style: "background-color: black; color: white; text-align: center; line-height: 20px; font-size: 8px;"
                },
                {
                    id: "__minFps",
                    xtype: "component",
                    bottom: 0,
                    left: 50,
                    width: 50,
                    height: 50,
                    html: "0",
                    style: "background-color: orange; color: white; text-align: center; line-height: 50px;"
                },
                {
                    xtype: "component",
                    bottom: 50,
                    left: 100,
                    width: 50,
                    height: 20,
                    html: "Max (Last 1k)",
                    style: "background-color: black; color: white; text-align: center; line-height: 20px; font-size: 8px;"
                },
                {
                    id: "__maxFps",
                    xtype: "component",
                    bottom: 0,
                    left: 100,
                    width: 50,
                    height: 50,
                    html: "0",
                    style: "background-color: yellow; color: black; text-align: center; line-height: 50px;"
                },
                {
                    xtype: "component",
                    bottom: 50,
                    left: 150,
                    width: 50,
                    height: 20,
                    html: "Current",
                    style: "background-color: black; color: white; text-align: center; line-height: 20px; font-size: 8px;"
                },
                {
                    id: "__currentFps",
                    xtype: "component",
                    bottom: 0,
                    left: 150,
                    width: 50,
                    height: 50,
                    html: "0",
                    style: "background-color: green; color: white; text-align: center; line-height: 50px;"
                }]);
                Ext.AnimationQueue.resetFps()
            })
        },
        resetFps: function() {
            var e = Ext.getCmp("__currentFps"),
            d = Ext.getCmp("__averageFps"),
            j = Ext.getCmp("__minFps"),
            i = Ext.getCmp("__maxFps"),
            f = 1000,
            b = 0,
            h = 0,
            g = 0;
            Ext.AnimationQueue.onFpsChanged = function(k) {
                h++;
                if (! (h % 10)) {
                    f = 1000;
                    b = 0
                }
                g += k;
                f = Math.min(f, k);
                b = Math.max(b, k);
                e.setHtml(Math.round(k));
                d.setHtml(Math.round(g / h));
                j.setHtml(Math.round(f));
                i.setHtml(Math.round(b))
            }
        }
    },
    function() {})
})(this);
Ext.define("Ext.TaskQueue", {
    singleton: true,
    pending: false,
    mode: true,
    constructor: function() {
        this.readQueue = [];
        this.writeQueue = [];
        this.run = Ext.Function.bind(this.run, this);
        this.watch = Ext.Function.bind(this.watch, this);
        if (Ext.os.is.iOS) {
            setInterval(this.watch, 500)
        }
    },
    requestRead: function(d, b, a) {
        this.request(true);
        this.readQueue.push(arguments)
    },
    requestWrite: function(d, b, a) {
        this.request(false);
        this.writeQueue.push(arguments)
    },
    request: function(a) {
        if (!this.pending) {
            this.pendingTime = Date.now();
            this.pending = true;
            this.mode = a;
            if (a) {
                setTimeout(this.run, 1)
            } else {
                requestAnimationFrame(this.run)
            }
        }
    },
    watch: function() {
        if (this.pending && Date.now() - this.pendingTime >= 500) {
            this.run()
        }
    },
    run: function() {
        this.pending = false;
        var k = this.readQueue,
        f = this.writeQueue,
        d = null,
        g;
        if (this.mode) {
            g = k;
            if (f.length > 0) {
                d = false
            }
        } else {
            g = f;
            if (k.length > 0) {
                d = true
            }
        }
        var b = g.slice(),
        e,
        h,
        a,
        j,
        m;
        g.length = 0;
        for (e = 0, h = b.length; e < h; e++) {
            a = b[e];
            j = a[0];
            m = a[1];
            if (typeof j == "string") {
                j = m[j]
            }
            if (a.length > 2) {
                j.apply(m, a[2])
            } else {
                j.call(m)
            }
        }
        b.length = 0;
        if (d !== null) {
            this.request(d)
        }
    }
});
Ext.define("Ext.scroll.indicator.Abstract", {
    extend: Ext.Component,
    config: {
        baseCls: "x-scroll-indicator",
        axis: "x",
        value: null,
        length: null,
        minLength: 6,
        hidden: true,
        ui: "dark",
        autoHide: true
    },
    cachedConfig: {
        ratio: 1,
        barCls: "x-scroll-bar",
        active: true
    },
    barElement: null,
    barLength: 0,
    gapLength: 0,
    getElementConfig: function() {
        return {
            reference: "barElement",
            children: [this.callParent()]
        }
    },
    applyRatio: function(a) {
        if (isNaN(a) || a > 1) {
            a = 1
        }
        return a
    },
    refresh: function() {
        var g = this.barElement,
        f = g.dom,
        d = this.getRatio(),
        b = this.getAxis(),
        a = (b === "x") ? f.offsetWidth: f.offsetHeight,
        e = a * d;
        this.barLength = a;
        this.gapLength = a - e;
        this.setLength(e);
        this.updateValue(this.getValue())
    },
    updateBarCls: function(a) {
        this.barElement.addCls(a)
    },
    updateAxis: function(a) {
        this.element.addCls(this.getBaseCls(), null, a);
        this.barElement.addCls(this.getBarCls(), null, a)
    },
    updateValue: function(g) {
        var b = this.barLength,
        d = this.gapLength,
        e = this.getLength(),
        f,
        h,
        a;
        if (g <= 0) {
            h = 0;
            this.updateLength(this.applyLength(e + g * b))
        } else {
            if (g >= 1) {
                a = Math.round((g - 1) * b);
                f = this.applyLength(e - a);
                a = e - f;
                this.updateLength(f);
                h = d + a
            } else {
                h = d * g
            }
        }
        this.setOffset(h)
    },
    updateActive: function(a) {
        this.barElement[a ? "addCls": "removeCls"]("active")
    },
    doSetHidden: function(b) {
        var a = this;
        if (b) {
            a.getAutoHide() && a.setOffset( - 10000)
        } else {
            delete a.lastLength;
            delete a.lastOffset;
            a.updateValue(a.getValue())
        }
    },
    applyLength: function(a) {
        return Math.max(this.getMinLength(), a)
    },
    updateLength: function(a) {
        a = Math.round(a);
        if (this.lastLength === a) {
            return
        }
        this.lastLength = a;
        Ext.TaskQueue.requestWrite("doUpdateLength", this, [a])
    },
    doUpdateLength: function(d) {
        if (!this.isDestroyed) {
            var b = this.getAxis(),
            a = this.element;
            if (b === "x") {
                a.setWidth(d)
            } else {
                a.setHeight(d)
            }
        }
    },
    setOffset: function(a) {
        a = Math.round(a);
        if (this.lastOffset === a || this.lastOffset === -10000) {
            return
        }
        this.lastOffset = a;
        Ext.TaskQueue.requestWrite("doSetOffset", this, [a])
    },
    doSetOffset: function(d) {
        if (!this.isDestroyed) {
            var b = this.getAxis(),
            a = this.element;
            if (b === "x") {
                a.translate(d, 0)
            } else {
                a.translate(0, d)
            }
        }
    }
});
Ext.define("Ext.scroll.indicator.CssTransform", {
    extend: Ext.scroll.indicator.Abstract,
    config: {
        cls: "csstransform"
    }
});
Ext.define("Ext.scroll.indicator.ScrollPosition", {
    extend: Ext.scroll.indicator.Abstract,
    config: {
        cls: "scrollposition"
    },
    getElementConfig: function() {
        var a = this.callParent(arguments);
        a.children.unshift({
            className: "x-scroll-bar-stretcher"
        });
        return a
    },
    updateValue: function(a) {
        if (this.gapLength === 0) {
            if (a >= 1) {
                a--
            }
            this.setOffset(this.barLength * a)
        } else {
            this.setOffset(this.gapLength * a)
        }
    },
    doUpdateLength: function() {
        if (!this.isDestroyed) {
            var a = this.barLength,
            b = this.element;
            this.callParent(arguments);
            if (this.getAxis() === "x") {
                b.setLeft(a)
            } else {
                b.setTop(a)
            }
        }
    },
    doSetOffset: function(e) {
        if (!this.isDestroyed) {
            var b = this.barLength,
            a = this.getMinLength(),
            d = this.barElement.dom;
            if (e !== -10000) {
                e = Math.min(b - a, Math.max(e, a - this.getLength()));
                e = b - e
            }
            if (this.getAxis() === "x") {
                d.scrollLeft = e
            } else {
                d.scrollTop = e
            }
        }
    }
});
Ext.define("Ext.scroll.indicator.Rounded", {
    extend: Ext.scroll.indicator.Abstract,
    config: {
        cls: "rounded"
    },
    constructor: function() {
        this.callParent(arguments);
        this.transformPropertyName = Ext.browser.getVendorProperyName("transform")
    },
    getElementConfig: function() {
        var a = this.callParent();
        a.children[0].children = [{
            reference: "startElement"
        },
        {
            reference: "middleElement"
        },
        {
            reference: "endElement"
        }];
        return a
    },
    refresh: function() {
        var e = this.getAxis(),
        d = this.startElement.dom,
        a = this.endElement.dom,
        f = this.middleElement,
        b,
        g;
        if (e === "x") {
            b = d.offsetWidth;
            g = a.offsetWidth;
            f.setLeft(b)
        } else {
            b = d.offsetHeight;
            g = a.offsetHeight;
            f.setTop(b)
        }
        this.startElementLength = b;
        this.endElementLength = g;
        this.callParent()
    },
    doUpdateLength: function(d) {
        if (!this.isDestroyed) {
            var b = this.getAxis(),
            a = this.endElement,
            f = this.middleElement.dom.style,
            e = this.endElementLength,
            i = d - e,
            h = i - this.startElementLength,
            g = this.transformPropertyName;
            if (b === "x") {
                a.translate(i, 0);
                f[g] = "translate3d(0, 0, 0) scaleX(" + h + ")"
            } else {
                a.translate(0, i);
                f[g] = "translate3d(0, 0, 0) scaleY(" + h + ")"
            }
        }
    }
});
Ext.define("Ext.scroll.Indicator", {
    alternateClassName: "Ext.util.Indicator",
    constructor: function(a) {
        var b = Ext.scroll.indicator;
        switch (Ext.browser.getPreferredTranslationMethod(a)) {
        case "scrollposition":
            return new b.ScrollPosition(a);
        case "csstransform":
            if (Ext.browser.is.AndroidStock4) {
                return new b.CssTransform(a)
            } else {
                return new b.Rounded(a)
            }
        }
    }
});
Ext.define("Ext.scroll.View", {
    extend: Ext.Evented,
    alternateClassName: "Ext.util.ScrollView",
    config: {
        indicatorsUi: "dark",
        element: null,
        scroller: {},
        indicators: {
            x: {
                axis: "x"
            },
            y: {
                axis: "y"
            }
        },
        indicatorsHidingDelay: 100,
        cls: Ext.baseCSSPrefix + "scroll-view"
    },
    processConfig: function(d) {
        if (!d) {
            return null
        }
        if (typeof d == "string") {
            d = {
                direction: d
            }
        }
        d = Ext.merge({},
        d);
        var a = d.scroller,
        b;
        if (!a) {
            d.scroller = a = {}
        }
        for (b in d) {
            if (d.hasOwnProperty(b)) {
                if (!this.hasConfig(b)) {
                    a[b] = d[b];
                    delete d[b]
                }
            }
        }
        return d
    },
    constructor: function(a) {
        a = this.processConfig(a);
        this.useIndicators = {
            x: true,
            y: true
        };
        this.doHideIndicators = Ext.Function.bind(this.doHideIndicators, this);
        this.initConfig(a)
    },
    setConfig: function(a) {
        return this.callParent([this.processConfig(a)])
    },
    updateIndicatorsUi: function(a) {
        var b = this.getIndicators();
        b.x.setUi(a);
        b.y.setUi(a)
    },
    applyScroller: function(a, b) {
        return Ext.factory(a, Ext.scroll.Scroller, b)
    },
    applyIndicators: function(b, e) {
        var a = Ext.scroll.Indicator,
        d = this.useIndicators;
        if (!b) {
            b = {}
        }
        if (!b.x) {
            d.x = false;
            b.x = {}
        }
        if (!b.y) {
            d.y = false;
            b.y = {}
        }
        return {
            x: Ext.factory(b.x, a, e && e.x),
            y: Ext.factory(b.y, a, e && e.y)
        }
    },
    updateIndicators: function(a) {
        this.indicatorsGrid = Ext.Element.create({
            className: "x-scroll-bar-grid-wrapper",
            children: [{
                className: "x-scroll-bar-grid",
                children: [{
                    children: [{},
                    {
                        children: [a.y.barElement]
                    }]
                },
                {
                    children: [{
                        children: [a.x.barElement]
                    },
                    {}]
                }]
            }]
        })
    },
    updateScroller: function(a) {
        a.on({
            scope: this,
            scrollstart: "onScrollStart",
            scroll: "onScroll",
            scrollend: "onScrollEnd",
            refresh: "refreshIndicators"
        })
    },
    isAxisEnabled: function(a) {
        return this.getScroller().isAxisEnabled(a) && this.useIndicators[a]
    },
    applyElement: function(a) {
        if (a) {
            return Ext.get(a)
        }
    },
    updateElement: function(d) {
        var b = this.getScroller(),
        a;
        a = d.getFirstChild().getFirstChild();
        if (this.FixedHBoxStretching) {
            a = a.getFirstChild()
        }
        d.addCls(this.getCls());
        d.insertFirst(this.indicatorsGrid);
        b.setElement(a);
        this.refreshIndicators();
        return this
    },
    showIndicators: function() {
        var a = this.getIndicators();
        if (this.hasOwnProperty("indicatorsHidingTimer")) {
            clearTimeout(this.indicatorsHidingTimer);
            delete this.indicatorsHidingTimer
        }
        if (this.isAxisEnabled("x")) {
            a.x.show()
        }
        if (this.isAxisEnabled("y")) {
            a.y.show()
        }
    },
    hideIndicators: function() {
        var a = this.getIndicatorsHidingDelay();
        if (a > 0) {
            this.indicatorsHidingTimer = setTimeout(this.doHideIndicators, a)
        } else {
            this.doHideIndicators()
        }
    },
    doHideIndicators: function() {
        var a = this.getIndicators();
        if (this.isAxisEnabled("x")) {
            a.x.hide()
        }
        if (this.isAxisEnabled("y")) {
            a.y.hide()
        }
    },
    onScrollStart: function() {
        this.onScroll.apply(this, arguments);
        this.showIndicators()
    },
    onScrollEnd: function() {
        this.hideIndicators()
    },
    onScroll: function(b, a, d) {
        this.setIndicatorValue("x", a);
        this.setIndicatorValue("y", d)
    },
    setIndicatorValue: function(b, g) {
        if (!this.isAxisEnabled(b)) {
            return this
        }
        var a = this.getScroller(),
        d = a.getMaxPosition()[b],
        f = a.getContainerSize()[b],
        e;
        if (d === 0) {
            e = g / f;
            if (g >= 0) {
                e += 1
            }
        } else {
            if (g > d) {
                e = 1 + ((g - d) / f)
            } else {
                if (g < 0) {
                    e = g / f
                } else {
                    e = g / d
                }
            }
        }
        this.getIndicators()[b].setValue(e)
    },
    refreshIndicator: function(e) {
        if (!this.isAxisEnabled(e)) {
            return this
        }
        var a = this.getScroller(),
        b = this.getIndicators()[e],
        f = a.getContainerSize()[e],
        g = a.getSize()[e],
        d = f / g;
        b.setRatio(d);
        b.refresh()
    },
    refresh: function() {
        return this.getScroller().refresh()
    },
    refreshIndicators: function() {
        var a = this.getIndicators();
        a.x.setActive(this.isAxisEnabled("x"));
        a.y.setActive(this.isAxisEnabled("y"));
        this.refreshIndicator("x");
        this.refreshIndicator("y")
    },
    destroy: function() {
        var a = this.getElement(),
        b = this.getIndicators();
        Ext.destroy(this.getScroller(), this.indicatorsGrid);
        if (this.hasOwnProperty("indicatorsHidingTimer")) {
            clearTimeout(this.indicatorsHidingTimer);
            delete this.indicatorsHidingTimer
        }
        if (a && !a.isDestroyed) {
            a.removeCls(this.getCls())
        }
        b.x.destroy();
        b.y.destroy();
        delete this.indicatorsGrid;
        this.callParent(arguments)
    }
});
Ext.define("Ext.behavior.Scrollable", {
    extend: Ext.behavior.Behavior,
    constructor: function() {
        this.listeners = {
            painted: "onComponentPainted",
            scope: this
        };
        this.callParent(arguments)
    },
    onComponentPainted: function() {
        this.scrollView.refresh()
    },
    setConfig: function(g) {
        var d = this.scrollView,
        f = this.component,
        b, e, a, h;
        if (g) {
            if (!d) {
                this.scrollView = d = new Ext.scroll.View(g);
                d.on("destroy", "onScrollViewDestroy", this);
                f.setUseBodyElement(true);
                this.scrollerElement = b = f.innerElement;
                if (!Ext.feature.has.ProperHBoxStretching) {
                    a = d.getScroller();
                    h = (Ext.isObject(g) ? g.direction: g) || "auto";
                    if (h !== "vertical") {
                        e = b.wrap();
                        e.addCls(Ext.baseCSSPrefix + "translatable-hboxfix");
                        if (h == "horizontal") {
                            e.setStyle({
                                height: "100%"
                            })
                        }
                        this.scrollContainer = e.wrap();
                        d.FixedHBoxStretching = a.FixedHBoxStretching = true
                    } else {
                        this.scrollContainer = b.wrap()
                    }
                } else {
                    this.scrollContainer = b.wrap()
                }
                d.setElement(f.bodyElement);
                if (f.isPainted()) {
                    this.onComponentPainted()
                }
                f.on(this.listeners)
            } else {
                if (Ext.isString(g) || Ext.isObject(g)) {
                    d.setConfig(g)
                }
            }
        } else {
            if (d) {
                d.destroy()
            }
        }
        return this
    },
    getScrollView: function() {
        return this.scrollView
    },
    onScrollViewDestroy: function() {
        var b = this.component,
        a = this.scrollerElement;
        if (!a.isDestroyed) {
            this.scrollerElement.unwrap()
        }
        this.scrollContainer.destroy();
        if (!b.isDestroyed) {
            b.un(this.listeners)
        }
        delete this.scrollerElement;
        delete this.scrollView;
        delete this.scrollContainer
    },
    onComponentDestroy: function() {
        var a = this.scrollView;
        if (a) {
            a.destroy()
        }
    }
});
Ext.define("Ext.util.InputBlocker", {
    singleton: true,
    blockInputs: function() {
        if (Ext.browser.is.ie) {
            Ext.select(".x-field-text .x-field-input:not(.x-item-disabled) .x-input-el, .x-field-textarea .x-field-input:not(.x-item-disabled) .x-input-el, .x-field-search .x-field-input:not(.x-item-disabled) .x-input-el").each(function(a) {
                if (a.dom.offsetWidth > 0) {
                    a.dom.setAttribute("disabled", true);
                    a.dom.setAttribute("overlayfix", true)
                }
            })
        }
    },
    unblockInputs: function() {
        if (Ext.browser.is.ie) {
            Ext.select("[overlayfix]").each(function(a) {
                a.dom.removeAttribute("disabled");
                a.dom.removeAttribute("overlayfix")
            })
        }
    }
});
Ext.define("Ext.Mask", {
    extend: Ext.Component,
    xtype: "mask",
    config: {
        baseCls: Ext.baseCSSPrefix + "mask",
        transparent: false,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
    },
    initialize: function() {
        this.callSuper();
        this.element.on("*", "onEvent", this);
        this.on({
            hide: "onHide"
        })
    },
    onHide: function() {
        Ext.util.InputBlocker.unblockInputs();
        if (Ext.browser.is.AndroidStock4 && Ext.os.version.getMinor() === 0) {
            var a = this.element.getFirstChild();
            if (a) {
                a.redraw()
            }
        }
    },
    onEvent: function(b) {
        var a = arguments[arguments.length - 1];
        if (a.info.eventName === "tap") {
            this.fireEvent("tap", this, b);
            return false
        }
        if (b && b.stopEvent) {
            b.stopEvent()
        }
        return false
    },
    updateTransparent: function(a) {
        this[a ? "addCls": "removeCls"](this.getBaseCls() + "-transparent")
    }
});
Ext.define("Ext.Container", {
    extend: Ext.Component,
    alternateClassName: "Ext.lib.Container",
    xtype: "container",
    eventedConfig: {
        activeItem: 0,
        scrollable: null
    },
    config: {
        layout: null,
        control: {},
        defaults: null,
        items: null,
        autoDestroy: true,
        defaultType: null,
        useBodyElement: null,
        masked: null,
        modal: null,
        hideOnMaskTap: null
    },
    isContainer: true,
    constructor: function(a) {
        var b = this;
        b._items = b.items = new Ext.ItemCollection();
        b.innerItems = [];
        b.onItemAdd = b.onFirstItemAdd;
        b.callParent(arguments)
    },
    getElementConfig: function() {
        return {
            reference: "element",
            classList: ["x-container", "x-unsized"],
            children: [{
                reference: "innerElement",
                className: "x-inner"
            }]
        }
    },
    applyMasked: function(b) {
        var a = true,
        d;
        if (b === false) {
            b = true;
            a = false
        }
        d = Ext.factory(b, Ext.Mask, this.getMasked());
        if (d) {
            this.add(d);
            d.setHidden(!a)
        }
        return d
    },
    mask: function(a) {
        this.setMasked(a || true)
    },
    unmask: function() {
        this.setMasked(false)
    },
    setParent: function(a) {
        this.callSuper(arguments);
        if (a) {
            var b = this.getModal();
            if (b) {
                a.insertBefore(b, this);
                b.setZIndex(this.getZIndex() - 1)
            }
        }
    },
    applyModal: function(d, b) {
        var a = true;
        if (d === false) {
            d = true;
            a = false
        }
        b = Ext.factory(d, Ext.Mask, b);
        if (b) {
            b.setVisibility(a)
        }
        return b
    },
    updateModal: function(b) {
        var a = this.getParent();
        if (a) {
            if (b) {
                a.insertBefore(b, this);
                b.setZIndex(this.getZIndex() - 1)
            } else {
                a.remove(b)
            }
        }
    },
    updateHideOnMaskTap: function(b) {
        var a = this.getModal();
        if (a) {
            a[b ? "on": "un"].call(a, "tap", "hide", this)
        }
    },
    updateZIndex: function(b) {
        var a = this.getModal();
        this.callParent(arguments);
        if (a) {
            a.setZIndex(b - 1)
        }
    },
    updateBaseCls: function(a, b) {
        var d = this,
        e = d.getUi();
        if (b) {
            this.element.removeCls(b);
            this.innerElement.removeCls(a, null, "inner");
            if (e) {
                this.element.removeCls(this.currentUi)
            }
        }
        if (a) {
            this.element.addCls(a);
            this.innerElement.addCls(a, null, "inner");
            if (e) {
                this.element.addCls(a, null, e);
                this.currentUi = a + "-" + e
            }
        }
    },
    updateUseBodyElement: function(a) {
        if (a) {
            this.link("bodyElement", this.innerElement.wrap({
                cls: "x-body"
            }))
        }
    },
    applyItems: function(a, e) {
        if (a) {
            var b = this;
            b.getDefaultType();
            b.getDefaults();
            if (b.initialized && e.length > 0) {
                b.removeAll()
            }
            b.add(a);
            if (b.initialized) {
                var d = b.initialConfig.activeItem || b.config.activeItem || 0;
                b.setActiveItem(d)
            }
        }
    },
    applyControl: function(d) {
        var a, b, f, e;
        for (a in d) {
            e = d[a];
            for (b in e) {
                f = e[b];
                if (Ext.isObject(f)) {
                    f.delegate = a
                }
            }
            e.delegate = a;
            this.addListener(e)
        }
        return d
    },
    onFirstItemAdd: function() {
        delete this.onItemAdd;
        if (this.innerHtmlElement && !this.getHtml()) {
            this.innerHtmlElement.destroy();
            delete this.innerHtmlElement
        }
        this.on("innerstatechange", "onItemInnerStateChange", this, {
            delegate: "> component"
        });
        return this.onItemAdd.apply(this, arguments)
    },
    getLayout: function() {
        var a = this.layout;
        if (!a) {
            a = this.link("_layout", this.link("layout", Ext.factory(this._layout || "default", Ext.layout.Default, null, "layout")));
            a.setContainer(this)
        }
        return a
    },
    updateDefaultType: function(a) {
        this.defaultItemClass = Ext.ClassManager.getByAlias("widget." + a)
    },
    applyDefaults: function(a) {
        if (a) {
            this.factoryItem = this.factoryItemWithDefaults;
            return a
        }
    },
    factoryItem: function(a) {
        return Ext.factory(a, this.defaultItemClass)
    },
    factoryItemWithDefaults: function(d) {
        var b = this,
        e = b.getDefaults(),
        a;
        if (!e) {
            return Ext.factory(d, b.defaultItemClass)
        }
        if (d.isComponent) {
            a = d;
            if (e && d.isInnerItem() && !b.has(a)) {
                a.setConfig(e, true)
            }
        } else {
            if (e && !d.ignoreDefaults) {
                if (! (d.hasOwnProperty("left") && d.hasOwnProperty("right") && d.hasOwnProperty("top") && d.hasOwnProperty("bottom") && d.hasOwnProperty("docked") && d.hasOwnProperty("centered"))) {
                    d = Ext.mergeIf({},
                    d, e)
                }
            }
            a = Ext.factory(d, b.defaultItemClass)
        }
        return a
    },
    add: function(a) {
        var f = this,
        b, e, d, g;
        if (Ext.isArray(a)) {
            for (b = 0, e = a.length; b < e; b++) {
                d = f.factoryItem(a[b]);
                this.doAdd(d);
                if (!g && !this.getActiveItem() && this.innerItems.length > 0 && d.isInnerItem()) {
                    g = d
                }
            }
        } else {
            d = f.factoryItem(a);
            this.doAdd(d);
            if (!g && !this.getActiveItem() && this.innerItems.length > 0 && d.isInnerItem()) {
                g = d
            }
        }
        if (g) {
            this.setActiveItem(g)
        }
        return d
    },
    doAdd: function(e) {
        var d = this,
        a = d.getItems(),
        b;
        if (!a.has(e)) {
            b = a.length;
            a.add(e);
            if (e.isInnerItem()) {
                d.insertInner(e)
            }
            e.setParent(d);
            d.onItemAdd(e, b)
        }
    },
    remove: function(e, b) {
        var d = this,
        a = d.indexOf(e),
        f = d.getInnerItems();
        if (b === undefined) {
            b = d.getAutoDestroy()
        }
        if (a !== -1) {
            if (!d.removingAll && f.length > 1 && e === d.getActiveItem()) {
                d.on({
                    activeitemchange: "doRemove",
                    scope: d,
                    single: true,
                    order: "after",
                    args: [e, a, b]
                });
                d.doResetActiveItem(f.indexOf(e))
            } else {
                d.doRemove(e, a, b);
                if (f.length === 0) {
                    d.setActiveItem(null)
                }
            }
        }
        return d
    },
    doResetActiveItem: function(a) {
        if (a === 0) {
            this.setActiveItem(1)
        } else {
            this.setActiveItem(0)
        }
    },
    doRemove: function(e, a, b) {
        var d = this;
        d.items.remove(e);
        if (e.isInnerItem()) {
            d.removeInner(e)
        }
        d.onItemRemove(e, a, b);
        e.setParent(null);
        if (b) {
            e.destroy()
        }
    },
    removeAll: function(d, g) {
        var a = this.items,
        f = a.length,
        b = 0,
        e;
        if (typeof d != "boolean") {
            d = this.getAutoDestroy()
        }
        g = Boolean(g);
        this.removingAll = true;
        for (; b < f; b++) {
            e = a.getAt(b);
            if (e && (g || e.isInnerItem())) {
                this.doRemove(e, b, d);
                b--;
                f--
            }
        }
        this.setActiveItem(null);
        this.removingAll = false;
        return this
    },
    getAt: function(a) {
        return this.items.getAt(a)
    },
    getInnerAt: function(a) {
        return this.innerItems[a]
    },
    removeAt: function(a) {
        var b = this.getAt(a);
        if (b) {
            this.remove(b)
        }
        return this
    },
    removeInnerAt: function(a) {
        var b = this.getInnerItems()[a];
        if (b) {
            this.remove(b)
        }
        return this
    },
    has: function(a) {
        return this.getItems().indexOf(a) != -1
    },
    hasInnerItem: function(a) {
        return this.innerItems.indexOf(a) != -1
    },
    indexOf: function(a) {
        return this.getItems().indexOf(a)
    },
    innerIndexOf: function(a) {
        return this.innerItems.indexOf(a)
    },
    insertInner: function(e, b) {
        var a = this.getItems().items,
        g = this.innerItems,
        h = g.indexOf(e),
        d = -1,
        f;
        if (h !== -1) {
            g.splice(h, 1)
        }
        if (typeof b == "number") {
            do {
                f = a[++b]
            } while ( f && ! f . isInnerItem ());
            if (f) {
                d = g.indexOf(f);
                g.splice(d, 0, e)
            }
        }
        if (d === -1) {
            g.push(e);
            d = g.length - 1
        }
        if (h !== -1) {
            this.onInnerItemMove(e, d, h)
        }
        return this
    },
    onInnerItemMove: Ext.emptyFn,
    removeInner: function(a) {
        Ext.Array.remove(this.innerItems, a);
        return this
    },
    insert: function(a, e) {
        var d = this,
        b;
        if (Ext.isArray(e)) {
            for (b = e.length - 1; b >= 0; b--) {
                d.insert(a, e[b])
            }
            return d
        }
        e = this.factoryItem(e);
        this.doInsert(a, e);
        return e
    },
    doInsert: function(e, g) {
        var f = this,
        b = f.items,
        d = b.length,
        a, h;
        h = g.isInnerItem();
        if (e > d) {
            e = d
        }
        if (b[e - 1] === g) {
            return f
        }
        a = f.indexOf(g);
        if (a !== -1) {
            if (a < e) {
                e -= 1
            }
            b.removeAt(a)
        }
        b.insert(e, g);
        if (a === -1) {
            g.setParent(f)
        }
        if (h) {
            f.insertInner(g, e)
        }
        if (a !== -1) {
            f.onItemMove(g, e, a)
        } else {
            f.onItemAdd(g, e)
        }
    },
    insertFirst: function(a) {
        return this.insert(0, a)
    },
    insertLast: function(a) {
        return this.insert(this.getItems().length, a)
    },
    insertBefore: function(d, a) {
        var b = this.indexOf(a);
        if (b !== -1) {
            this.insert(b, d)
        }
        return this
    },
    insertAfter: function(d, a) {
        var b = this.indexOf(a);
        if (b !== -1) {
            this.insert(b + 1, d)
        }
        return this
    },
    onItemAdd: function(b, a) {
        this.doItemLayoutAdd(b, a);
        if (this.initialized) {
            this.fireEvent("add", this, b, a)
        }
    },
    doItemLayoutAdd: function(d, a) {
        var b = this.getLayout();
        if (this.isRendered() && d.setRendered(true)) {
            d.fireAction("renderedchange", [this, d, true], "onItemAdd", b, {
                args: [d, a]
            })
        } else {
            b.onItemAdd(d, a)
        }
    },
    onItemRemove: function(b, a, d) {
        this.doItemLayoutRemove(b, a, d);
        this.fireEvent("remove", this, b, a)
    },
    doItemLayoutRemove: function(d, a, e) {
        var b = this.getLayout();
        if (this.isRendered() && d.setRendered(false)) {
            d.fireAction("renderedchange", [this, d, false], "onItemRemove", b, {
                args: [d, a, e]
            })
        } else {
            b.onItemRemove(d, a, e)
        }
    },
    onItemMove: function(b, d, a) {
        if (b.isDocked()) {
            b.setDocked(null)
        }
        this.doItemLayoutMove(b, d, a);
        this.fireEvent("move", this, b, d, a)
    },
    doItemLayoutMove: function(b, d, a) {
        this.getLayout().onItemMove(b, d, a)
    },
    onItemInnerStateChange: function(d, a) {
        var b = this.getLayout();
        if (a) {
            this.insertInner(d, this.items.indexOf(d))
        } else {
            this.removeInner(d)
        }
        b.onItemInnerStateChange.apply(b, arguments)
    },
    getInnerItems: function() {
        return this.innerItems
    },
    getDockedItems: function() {
        var a = this.getItems().items,
        d = [],
        f = a.length,
        e,
        b;
        for (b = 0; b < f; b++) {
            e = a[b];
            if (e.isDocked()) {
                d.push(e)
            }
        }
        return d
    },
    applyActiveItem: function(e, a) {
        var d = this.getInnerItems();
        this.getItems();
        if (!e && d.length === 0) {
            return 0
        } else {
            if (typeof e == "number") {
                e = Math.max(0, Math.min(e, d.length - 1));
                e = d[e];
                if (e) {
                    return e
                } else {
                    if (a) {
                        return null
                    }
                }
            } else {
                if (e) {
                    var b;
                    if (typeof e == "string") {
                        b = this.child(e);
                        e = {
                            xtype: e
                        }
                    }
                    if (!b || !b.isComponent) {
                        b = this.factoryItem(e)
                    }
                    this.pendingActiveItem = b;
                    if (!this.has(b)) {
                        this.add(b)
                    }
                    return b
                }
            }
        }
    },
    animateActiveItem: function(e, d) {
        var b = this.getLayout(),
        a;
        if (this.activeItemAnimation) {
            this.activeItemAnimation.destroy()
        }
        this.activeItemAnimation = d = new Ext.fx.layout.Card(d);
        if (d && b.isCard) {
            d.setLayout(b);
            a = b.getAnimation();
            if (a) {
                a.disable()
            }
            d.on("animationend",
            function() {
                if (a) {
                    a.enable()
                }
                d.destroy()
            },
            this)
        }
        return this.setActiveItem(e)
    },
    doSetActiveItem: function(b, a) {
        delete this.pendingActiveItem;
        if (a) {
            a.fireEvent("deactivate", a, this, b)
        }
        if (b) {
            b.fireEvent("activate", b, this, a)
        }
    },
    show: function() {
        this.callParent(arguments);
        var a = this.getModal();
        if (a) {
            a.setHidden(false)
        }
        return this
    },
    hide: function() {
        this.callParent(arguments);
        var a = this.getModal();
        if (a) {
            a.setHidden(true)
        }
        return this
    },
    doSetHidden: function(b) {
        var a = this.getModal();
        if (a && (a.getHidden() !== b)) {
            a.setHidden(b)
        }
        this.callSuper(arguments)
    },
    setRendered: function(e) {
        if (this.callParent(arguments)) {
            var a = this.items.items,
            b, d;
            for (b = 0, d = a.length; b < d; b++) {
                a[b].setRendered(e)
            }
            return true
        }
        return false
    },
    getScrollableBehavior: function() {
        var a = this.scrollableBehavior;
        if (!a) {
            a = this.scrollableBehavior = new Ext.behavior.Scrollable(this)
        }
        return a
    },
    applyScrollable: function(a) {
        if (typeof a === "boolean") {
            this.getScrollableBehavior().setConfig({
                disabled: !a
            })
        } else {
            if (a && !a.isObservable) {
                this.getScrollableBehavior().setConfig(a)
            }
        }
        return a
    },
    doSetScrollable: function() {},
    getScrollable: function() {
        return this.getScrollableBehavior().getScrollView()
    },
    getRefItems: function(a) {
        var b = this.getItems().items.slice(),
        f = b.length,
        d,
        e;
        if (a) {
            for (d = 0; d < f; d++) {
                e = b[d];
                if (e.getRefItems) {
                    b = b.concat(e.getRefItems(true))
                }
            }
        }
        return b
    },
    getComponent: function(a) {
        if (Ext.isObject(a)) {
            a = a.getItemId()
        }
        return this.getItems().get(a)
    },
    getDockedComponent: function(a) {
        if (Ext.isObject(a)) {
            a = a.getItemId()
        }
        var d = this.getDockedItems(),
        f = d.length,
        e,
        b;
        if (Ext.isNumber(a)) {
            return d[a]
        }
        for (b = 0; b < f; b++) {
            e = d[b];
            if (e.id == a) {
                return e
            }
        }
        return false
    },
    query: function(a) {
        return Ext.ComponentQuery.query(a, this)
    },
    child: function(a) {
        return this.query("> " + a)[0] || null
    },
    down: function(a) {
        return this.query(a)[0] || null
    },
    destroy: function() {
        var b = this,
        a = b.getModal();
        if (a) {
            a.destroy()
        }
        b.removeAll(true, true);
        b.unlink("_scrollable");
        Ext.destroy(b.items);
        b.callSuper()
    }
},
function() {
    this.addMember("defaultItemClass", this)
});
Ext.define("Ext.util.Point", {
    radianToDegreeConstant: 180 / Math.PI,
    statics: {
        fromEvent: function(b) {
            var a = b.changedTouches,
            d = (a && a.length > 0) ? a[0] : b;
            return this.fromTouch(d)
        },
        fromTouch: function(a) {
            return new this(a.pageX, a.pageY)
        },
        from: function(a) {
            if (!a) {
                return new this(0, 0)
            }
            if (! (a instanceof this)) {
                return new this(a.x, a.y)
            }
            return a
        }
    },
    constructor: function(a, b) {
        if (typeof a == "undefined") {
            a = 0
        }
        if (typeof b == "undefined") {
            b = 0
        }
        this.x = a;
        this.y = b;
        return this
    },
    clone: function() {
        return new this.self(this.x, this.y)
    },
    copy: function() {
        return this.clone.apply(this, arguments)
    },
    copyFrom: function(a) {
        this.x = a.x;
        this.y = a.y;
        return this
    },
    toString: function() {
        return "Point[" + this.x + "," + this.y + "]"
    },
    equals: function(a) {
        return (this.x === a.x && this.y === a.y)
    },
    isCloseTo: function(d, b) {
        if (typeof b == "number") {
            b = {
                x: b
            };
            b.y = b.x
        }
        var a = d.x,
        g = d.y,
        f = b.x,
        e = b.y;
        return (this.x <= a + f && this.x >= a - f && this.y <= g + e && this.y >= g - e)
    },
    isWithin: function() {
        return this.isCloseTo.apply(this, arguments)
    },
    translate: function(a, b) {
        this.x += a;
        this.y += b;
        return this
    },
    roundedEquals: function(a) {
        if (typeof a != "object") {
            a = {
                x: 0,
                y: 0
            }
        }
        return (Math.round(this.x) === Math.round(a.x) && Math.round(this.y) === Math.round(a.y))
    },
    getDistanceTo: function(b) {
        if (typeof b != "object") {
            b = {
                x: 0,
                y: 0
            }
        }
        var d = this.x - b.x,
        a = this.y - b.y;
        return Math.sqrt(d * d + a * a)
    },
    getAngleTo: function(b) {
        if (typeof b != "object") {
            b = {
                x: 0,
                y: 0
            }
        }
        var d = this.x - b.x,
        a = this.y - b.y;
        return Math.atan2(a, d) * this.radianToDegreeConstant
    }
});
Ext.define("Ext.util.LineSegment", {
    constructor: function(b, a) {
        var d = Ext.util.Point;
        this.point1 = d.from(b);
        this.point2 = d.from(a)
    },
    intersects: function(n) {
        var q = this.point1,
        o = this.point2,
        j = n.point1,
        g = n.point2,
        e = q.x,
        b = o.x,
        a = j.x,
        s = g.x,
        r = q.y,
        p = o.y,
        m = j.y,
        i = g.y,
        h = (e - b) * (m - i) - (r - p) * (a - s),
        k,
        f;
        if (h == 0) {
            return null
        }
        k = ((a - s) * (e * p - r * b) - (e - b) * (a * i - m * s)) / h;
        f = ((m - i) * (e * p - r * b) - (r - p) * (a * i - m * s)) / h;
        if (k < Math.min(e, b) || k > Math.max(e, b) || k < Math.min(a, s) || k > Math.max(a, s) || f < Math.min(r, p) || f > Math.max(r, p) || f < Math.min(m, i) || f > Math.max(m, i)) {
            return null
        }
        return new Ext.util.Point(k, f)
    },
    getLength: function() {
        return Math.abs(this.point1.getDistanceTo(this.point2))
    },
    getAngleToX: function() {
        var e = this.point1,
        d = this.point2,
        a = d.y - e.y,
        b = d.x - e.x;
        return Math.atan2(a, b)
    },
    getInBetweenPoint: function(f) {
        var b = this.point1,
        d = this.getAngleToX(),
        a = b.x + Math.cos(d) * f,
        e = b.y + Math.sin(d) * f;
        return new Ext.util.Point(a, e)
    },
    toString: function() {
        return this.point1.toString() + " " + this.point2.toString()
    }
});
Ext.define("Ext.Panel", {
    extend: Ext.Container,
    alternateClassName: "Ext.lib.Panel",
    xtype: "panel",
    isPanel: true,
    config: {
        baseCls: Ext.baseCSSPrefix + "panel",
        bodyPadding: null,
        bodyMargin: null,
        bodyBorder: null
    },
    getElementConfig: function() {
        return {
            reference: "element",
            classList: ["x-container", "x-unsized"],
            children: [{
                reference: "innerElement",
                className: "x-inner"
            },
            {
                reference: "tipElement",
                className: "x-anchor",
                hidden: true
            }]
        }
    },
    applyBodyPadding: function(a) {
        if (a === true) {
            a = 5
        }
        if (a) {
            a = Ext.dom.Element.unitizeBox(a)
        }
        return a
    },
    updateBodyPadding: function(a) {
        this.element.setStyle("padding", a)
    },
    applyBodyMargin: function(a) {
        if (a === true) {
            a = 5
        }
        if (a) {
            a = Ext.dom.Element.unitizeBox(a)
        }
        return a
    },
    updateBodyMargin: function(a) {
        this.element.setStyle("margin", a)
    },
    applyBodyBorder: function(a) {
        if (a === true) {
            a = 1
        }
        if (a) {
            a = Ext.dom.Element.unitizeBox(a)
        }
        return a
    },
    updateBodyBorder: function(a) {
        this.element.setStyle("border-width", a)
    },
    alignTo: function(p, j) {
        var u = this.getAlignmentInfo(p, j);
        if (u.isAligned) {
            return
        }
        var C = this.tipElement;
        C.hide();
        if (this.currentTipPosition) {
            C.removeCls("x-anchor-" + this.currentTipPosition)
        }
        this.callParent(arguments);
        var g = Ext.util.LineSegment,
        e = p.isComponent ? p.renderElement: p,
        a = this.renderElement,
        q = e.getPageBox(),
        n = a.getPageBox(),
        b = n.left,
        z = n.top,
        I = n.right,
        i = n.bottom,
        m = b + (n.width / 2),
        k = z + (n.height / 2),
        r = {
            x: b,
            y: z
        },
        o = {
            x: I,
            y: z
        },
        H = {
            x: b,
            y: i
        },
        J = {
            x: I,
            y: i
        },
        E = {
            x: m,
            y: k
        },
        y = q.left + (q.width / 2),
        t = q.top + (q.height / 2),
        B = {
            x: y,
            y: t
        },
        d = new g(E, B),
        h = 0,
        G = 0,
        f,
        F,
        v,
        s,
        D,
        A;
        C.setVisibility(false);
        C.show();
        f = C.getSize();
        F = f.width;
        v = f.height;
        if (d.intersects(new g(r, o))) {
            D = Math.min(Math.max(y, b + F), I - (F));
            A = z;
            G = v + 10;
            s = "top"
        } else {
            if (d.intersects(new g(r, H))) {
                D = b;
                A = Math.min(Math.max(t + (F / 2), F * 1.6), i - (F / 2.2));
                h = v + 10;
                s = "left"
            } else {
                if (d.intersects(new g(H, J))) {
                    D = Math.min(Math.max(y, b + F), I - F);
                    A = i;
                    G = -v - 10;
                    s = "bottom"
                } else {
                    if (d.intersects(new g(o, J))) {
                        D = I;
                        A = Math.max(Math.min(t - v, i - F * 1.3), F / 2);
                        h = -v - 10;
                        s = "right"
                    }
                }
            }
        }
        if (D || A) {
            this.currentTipPosition = s;
            C.addCls("x-anchor-" + s);
            C.setLeft(D - b);
            C.setTop(A - z);
            C.setVisibility(true);
            this.setLeft(this.getLeft() + h);
            this.setTop(this.getTop() + G)
        }
    }
});
Ext.define("Ext.Button", {
    extend: Ext.Component,
    xtype: "button",
    cachedConfig: {
        pressedCls: Ext.baseCSSPrefix + "button-pressing",
        badgeCls: Ext.baseCSSPrefix + "badge",
        hasBadgeCls: Ext.baseCSSPrefix + "hasbadge",
        labelCls: Ext.baseCSSPrefix + "button-label",
        iconCls: null
    },
    config: {
        badgeText: null,
        text: null,
        icon: false,
        iconAlign: "left",
        pressedDelay: 0,
        handler: null,
        scope: null,
        autoEvent: null,
        ui: "normal",
        baseCls: Ext.baseCSSPrefix + "button"
    },
    template: [{
        tag: "span",
        reference: "badgeElement",
        hidden: true
    },
    {
        tag: "span",
        className: Ext.baseCSSPrefix + "button-icon",
        reference: "iconElement"
    },
    {
        tag: "span",
        reference: "textElement",
        hidden: true
    }],
    initialize: function() {
        this.callParent();
        this.element.on({
            scope: this,
            tap: "onTap",
            touchstart: "onPress",
            touchend: "onRelease"
        })
    },
    updateBadgeText: function(d) {
        var a = this.element,
        b = this.badgeElement;
        if (d) {
            b.show();
            b.setText(d)
        } else {
            b.hide()
        }
        a[(d) ? "addCls": "removeCls"](this.getHasBadgeCls())
    },
    updateText: function(b) {
        var a = this.textElement;
        if (a) {
            if (b) {
                a.show();
                a.setHtml(b)
            } else {
                a.hide()
            }
            this.refreshIconAlign()
        }
    },
    updateHtml: function(b) {
        var a = this.textElement;
        if (b) {
            a.show();
            a.setHtml(b)
        } else {
            a.hide()
        }
    },
    updateBadgeCls: function(b, a) {
        this.badgeElement.replaceCls(a, b)
    },
    updateHasBadgeCls: function(b, d) {
        var a = this.element;
        if (a.hasCls(d)) {
            a.replaceCls(d, b)
        }
    },
    updateLabelCls: function(b, a) {
        this.textElement.replaceCls(a, b)
    },
    updatePressedCls: function(b, d) {
        var a = this.element;
        if (a.hasCls(d)) {
            a.replaceCls(d, b)
        }
    },
    updateIcon: function(b) {
        var d = this,
        a = d.iconElement;
        if (b) {
            d.showIconElement();
            a.setStyle("background-image", "url(" + b + ")");
            d.refreshIconAlign()
        } else {
            a.setStyle("background-image", "");
            d.hideIconElement()
        }
    },
    updateIconCls: function(d, a) {
        var e = this,
        b = e.iconElement;
        if (d) {
            e.showIconElement();
            b.replaceCls(a, d);
            e.refreshIconAlign()
        } else {
            b.removeCls(a);
            e.hideIconElement()
        }
    },
    updateIconAlign: function(e, d) {
        var b = this.element,
        a = Ext.baseCSSPrefix + "iconalign-";
        if (!this.getText()) {
            e = "center"
        }
        b.removeCls(a + "center");
        b.removeCls(a + d);
        if (this.getIcon() || this.getIconCls()) {
            b.addCls(a + e)
        }
    },
    refreshIconAlign: function() {
        this.updateIconAlign(this.getIconAlign())
    },
    applyAutoEvent: function(b) {
        var a = this;
        if (typeof b == "string") {
            b = {
                name: b,
                scope: a.scope || a
            }
        }
        return b
    },
    updateAutoEvent: function(d) {
        var a = d.name,
        b = d.scope;
        this.setHandler(function() {
            b.fireEvent(a, b, this)
        });
        this.setScope(b)
    },
    hideIconElement: function() {
        this.iconElement.removeCls(Ext.baseCSSPrefix + "shown");
        this.iconElement.addCls(Ext.baseCSSPrefix + "hidden")
    },
    showIconElement: function() {
        this.iconElement.removeCls(Ext.baseCSSPrefix + "hidden");
        this.iconElement.addCls(Ext.baseCSSPrefix + "shown")
    },
    applyUi: function(a) {
        if (a && Ext.isString(a)) {
            var b = a.split("-");
            if (b && (b[1] == "back" || b[1] == "forward")) {
                return b
            }
        }
        return a
    },
    getUi: function() {
        var a = this._ui;
        if (Ext.isArray(a)) {
            return a.join("-")
        }
        return a
    },
    applyPressedDelay: function(a) {
        if (Ext.isNumber(a)) {
            return a
        }
        return (a) ? 100 : 0
    },
    onPress: function() {
        var d = this,
        a = d.element,
        e = d.getPressedDelay(),
        b = d.getPressedCls();
        if (!d.getDisabled()) {
            if (e > 0) {
                d.pressedTimeout = setTimeout(function() {
                    delete d.pressedTimeout;
                    if (a) {
                        a.addCls(b)
                    }
                },
                e)
            } else {
                a.addCls(b)
            }
        }
    },
    onRelease: function(a) {
        this.fireAction("release", [this, a], "doRelease")
    },
    doRelease: function(a, b) {
        if (!a.getDisabled()) {
            if (a.hasOwnProperty("pressedTimeout")) {
                clearTimeout(a.pressedTimeout);
                delete a.pressedTimeout
            } else {
                a.element.removeCls(a.getPressedCls())
            }
        }
    },
    onTap: function(a) {
        if (this.getDisabled()) {
            return false
        }
        this.fireAction("tap", [this, a], "doTap")
    },
    doTap: function(d, f) {
        var b = d.getHandler(),
        a = d.getScope() || d;
        if (!b) {
            return
        }
        if (typeof b == "string") {
            b = a[b]
        }
        if (f && f.preventDefault) {
            f.preventDefault()
        }
        b.apply(a, arguments)
    }
},
function() {});
Ext.define("Ext.Sheet", {
    extend: Ext.Panel,
    xtype: "sheet",
    config: {
        baseCls: Ext.baseCSSPrefix + "sheet",
        modal: true,
        centered: true,
        stretchX: null,
        stretchY: null,
        enter: "bottom",
        exit: "bottom",
        showAnimation: !Ext.browser.is.AndroidStock2 ? {
            type: "slideIn",
            duration: 250,
            easing: "ease-out"
        }: null,
        hideAnimation: !Ext.browser.is.AndroidStock2 ? {
            type: "slideOut",
            duration: 250,
            easing: "ease-in"
        }: null
    },
    isInputRegex: /^(input|textarea|select|a)$/i,
    beforeInitialize: function() {
        var a = this;
        Ext.os.is.iOS && this.element.dom.addEventListener("touchstart",
        function(b) {
            if (!a.isInputRegex.test(b.target.tagName)) {
                b.preventDefault()
            }
        },
        true)
    },
    platformConfig: [{
        theme: ["Windows"],
        enter: "top",
        exit: "top"
    }],
    applyHideAnimation: function(b) {
        var a = this.getExit(),
        e = a;
        if (a === null) {
            return null
        }
        if (b === true) {
            b = {
                type: "slideOut"
            }
        }
        if (Ext.isString(b)) {
            b = {
                type: b
            }
        }
        var d = Ext.factory(b, Ext.fx.Animation);
        if (d) {
            if (a == "bottom") {
                e = "down"
            }
            if (a == "top") {
                e = "up"
            }
            d.setDirection(e)
        }
        return d
    },
    applyShowAnimation: function(a) {
        var e = this.getEnter(),
        d = e;
        if (e === null) {
            return null
        }
        if (a === true) {
            a = {
                type: "slideIn"
            }
        }
        if (Ext.isString(a)) {
            a = {
                type: a
            }
        }
        var b = Ext.factory(a, Ext.fx.Animation);
        if (b) {
            if (e == "bottom") {
                d = "down"
            }
            if (e == "top") {
                d = "up"
            }
            b.setBefore({
                display: null
            });
            b.setReverse(true);
            b.setDirection(d)
        }
        return b
    },
    updateStretchX: function(a) {
        this.getLeft();
        this.getRight();
        if (a) {
            this.setLeft(0);
            this.setRight(0)
        }
    },
    updateStretchY: function(a) {
        this.getTop();
        this.getBottom();
        if (a) {
            this.setTop(0);
            this.setBottom(0)
        }
    }
});
Ext.define("Ext.data.Connection", {
    mixins: {
        observable: Ext.mixin.Observable
    },
    statics: {
        requestId: 0
    },
    config: {
        url: null,
        async: true,
        method: null,
        username: "",
        password: "",
        disableCaching: true,
        disableCachingParam: "_dc",
        timeout: 30000,
        extraParams: null,
        defaultHeaders: null,
        useDefaultHeader: true,
        defaultPostHeader: "application/x-www-form-urlencoded; charset=UTF-8",
        useDefaultXhrHeader: true,
        defaultXhrHeader: "XMLHttpRequest",
        autoAbort: false
    },
    textAreaRe: /textarea/i,
    multiPartRe: /multipart\/form-data/i,
    lineBreakRe: /\r\n/g,
    constructor: function(a) {
        this.initConfig(a);
        this.requests = {}
    },
    request: function(m) {
        m = m || {};
        var g = this,
        k = m.scope || window,
        f = m.username || g.getUsername(),
        i = m.password || g.getPassword() || "",
        h = m.xhr2 === true && Ext.feature.has.XHR2,
        b,
        d,
        e,
        a,
        j;
        if (!Ext.isEmpty(f) && !Ext.isEmpty(i, true) && Ext.isEmpty(m.withCredentials)) {
            m.withCredentials = true
        }
        if (g.fireEvent("beforerequest", g, m) !== false) {
            d = g.setOptions(m, k);
            if (this.isFormUpload(m) === true) {
                this.upload(m.form, d.url, d.data, m);
                return null
            }
            if (m.autoAbort === true || g.getAutoAbort()) {
                g.abort()
            }
            j = this.getXhrInstance();
            b = m.async !== false ? (m.async || g.getAsync()) : false;
            if (f) {
                j.open(d.method, d.url, b, f, i)
            } else {
                j.open(d.method, d.url, b)
            }
            a = g.setupHeaders(j, m, d.data, d.params);
            e = {
                id: ++Ext.data.Connection.requestId,
                xhr: j,
                headers: a,
                options: m,
                async: b,
                timeout: setTimeout(function() {
                    e.timedout = true;
                    g.abort(e)
                },
                m.timeout || g.getTimeout())
            };
            g.requests[e.id] = e;
            if (b) {
                j[h ? "onload": "onreadystatechange"] = Ext.Function.bind(g.onStateChange, g, [e])
            }
            if (h) {
                j.onerror = Ext.Function.bind(g.onStateChange, g, [e])
            }
            if (m.progress) {
                j.onprogress = function(n) {
                    if (m.progress.isProgressable) {
                        if (n.total === 0 && m.progress.getDynamic()) {
                            Ext.Logger.warn("Server is not configured to properly return Content-Length. Dynamic progress will be disabled");
                            m.progress.setState.call(m.progress, "download");
                            m.progress.setDynamic(false);
                            j.onprogress = null;
                            return
                        }
                        Ext.callback(m.progress.updateProgress, m.progress, [(n.loaded / n.total), "download"]);
                        if (n.total > 0 && !m.progress.getDynamic() && m.progress.getInitialConfig().dynamic) {
                            m.progress.setDynamic(true)
                        }
                    } else {
                        if (Ext.isFunction(m.progress)) {
                            Ext.callback(m.progress, m.progressScope || e, [n, "download"])
                        }
                    }
                };
                if (Ext.feature.has.XHRUploadProgress) {
                    j.upload.onprogress = function(n) {
                        g.fireEvent("requestuploadprogress", g, e, n);
                        if (m.progress.isProgressable) {
                            Ext.callback(m.progress.updateProgress, m.progress, [(n.loaded / n.total), "upload"])
                        } else {
                            if (Ext.isFunction(m.progress)) {
                                Ext.callback(m.progress, m.progressScope || e, [n, "upload"])
                            }
                        }
                    }
                }
                if (m.progress.isProgressable) {
                    if (!Ext.feature.has.XHRUploadProgress) {
                        m.progress.setDynamic(false)
                    }
                    Ext.callback(m.progress.startProgress, m.progress)
                }
            }
            j.send(d.data);
            if (!b) {
                return this.onComplete(e)
            }
            return e
        } else {
            Ext.callback(m.callback, m.scope, [m, undefined, undefined]);
            return null
        }
    },
    upload: function(f, d, j, n) {
        f = Ext.getDom(f);
        n = n || {};
        var e = Ext.id(),
        m = this,
        i = document.createElement("iframe"),
        k = [],
        h = "multipart/form-data",
        g = {
            target: f.target,
            method: f.method,
            encoding: f.encoding,
            enctype: f.enctype,
            action: f.action
        },
        b = function(o, p) {
            a = document.createElement("input");
            Ext.fly(a).set({
                type: "hidden",
                value: p,
                name: o
            });
            f.appendChild(a);
            k.push(a)
        },
        a;
        Ext.fly(i).set({
            id: e,
            name: e,
            cls: Ext.baseCSSPrefix + "hide-display",
            src: Ext.SSL_SECURE_URL
        });
        document.body.appendChild(i);
        if (document.frames) {
            document.frames[e].name = e
        }
        Ext.fly(f).set({
            target: e,
            method: "POST",
            enctype: h,
            encoding: h,
            action: d || g.action
        });
        if (j) {
            Ext.iterate(Ext.Object.fromQueryString(j),
            function(o, p) {
                if (Ext.isArray(p)) {
                    Ext.each(p,
                    function(q) {
                        b(o, q)
                    })
                } else {
                    b(o, p)
                }
            })
        }
        i.addEventListener("load",
        function() {
            Ext.callback(m.onUploadComplete, m, [i, n, e]);
            i.removeEventListener("load", arguments.callee)
        });
        f.submit();
        Ext.fly(f).set(g);
        Ext.each(k,
        function(o) {
            Ext.removeNode(o)
        })
    },
    onUploadComplete: function(h, b, i) {
        var a = {
            responseText: "",
            responseXML: null
        },
        g,
        f;
        try {
            g = h.contentWindow || h.contentWindow.document || h.contentDocument || window.frames[i].document;
            if (g) {
                if (g.hasOwnProperty("body") && g.body) {
                    if (this.textAreaRe.test((f = g.body.firstChild || {}).tagName)) {
                        a.responseText = f.value
                    } else {
                        a.responseText = g.body.innerHTML
                    }
                }
                a.responseXML = g.XMLDocument || g
            }
        } catch(d) {
            a.success = false;
            a.message = "Cross-Domain access is not permitted between frames. XHR2 is recommended for this type of request.";
            a.error = d
        }
        this.onAfterUploadComplete(a, h, b)
    },
    onAfterUploadComplete: function(a, e, b) {
        var d = this;
        d.fireEvent("requestcomplete", d, a, b);
        Ext.callback(b.success, b.scope, [a, b]);
        Ext.callback(b.callback, b.scope, [b, true, a]);
        setTimeout(function() {
            Ext.removeNode(e)
        },
        100)
    },
    isFormUpload: function(a) {
        var b = this.getForm(a);
        if (b) {
            return (a.isUpload || (this.multiPartRe).test(b.getAttribute("enctype")))
        }
        return false
    },
    getForm: function(a) {
        return Ext.getDom(a.form) || null
    },
    setOptions: function(m, k) {
        var i = this,
        f = m.params || {},
        h = i.getExtraParams(),
        e = m.urlParams,
        d = m.url || i.getUrl(),
        j = m.jsonData,
        b,
        a,
        g;
        if (Ext.isFunction(f)) {
            f = f.call(k, m)
        }
        if (Ext.isFunction(d)) {
            d = d.call(k, m)
        }
        d = this.setupUrl(m, d);
        g = m.data || m.rawData || m.binaryData || m.xmlData || j || null;
        if (j && !Ext.isPrimitive(j)) {
            g = Ext.encode(g)
        }
        if (m.binaryData) {
            if (g instanceof Array) {
                g = (new Uint8Array(m.binaryData))
            }
            if (g instanceof Uint8Array) {
                g = g.buffer
            }
        }
        if (Ext.isObject(f)) {
            f = Ext.Object.toQueryString(f)
        }
        if (Ext.isObject(h)) {
            h = Ext.Object.toQueryString(h)
        }
        f = f + ((h) ? ((f) ? "&": "") + h: "");
        e = Ext.isObject(e) ? Ext.Object.toQueryString(e) : e;
        f = this.setupParams(m, f);
        b = (m.method || i.getMethod() || ((f || g) ? "POST": "GET")).toUpperCase();
        this.setupMethod(m, b);
        a = m.disableCaching !== false ? (m.disableCaching || i.getDisableCaching()) : false;
        if (a) {
            d = Ext.urlAppend(d, (m.disableCachingParam || i.getDisableCachingParam()) + "=" + (new Date().getTime()))
        }
        if ((b == "GET" || g) && f) {
            d = Ext.urlAppend(d, f);
            f = null
        }
        if (e) {
            d = Ext.urlAppend(d, e)
        }
        return {
            url: d,
            method: b,
            data: g || f || null
        }
    },
    setupUrl: function(b, a) {
        var d = this.getForm(b);
        if (d) {
            a = a || d.action
        }
        return a
    },
    setupParams: function(a, e) {
        var d = this.getForm(a),
        b;
        if (d && !this.isFormUpload(a)) {
            b = Ext.Element.serializeForm(d);
            e = e ? (e + "&" + b) : b
        }
        return e
    },
    setupMethod: function(a, b) {
        if (this.isFormUpload(a)) {
            return "POST"
        }
        return b
    },
    setupHeaders: function(n, o, f, d) {
        var i = this,
        b = Ext.apply({},
        o.headers || {},
        i.getDefaultHeaders() || {}),
        m = i.getDefaultPostHeader(),
        j = o.jsonData,
        a = o.xmlData,
        k,
        g;
        if (!b["Content-Type"] && (f || d)) {
            if (f) {
                if (o.rawData) {
                    m = "text/plain"
                } else {
                    if (a && Ext.isDefined(a)) {
                        m = "text/xml"
                    } else {
                        if (j && Ext.isDefined(j)) {
                            m = "application/json"
                        }
                    }
                }
            }
            if (! (Ext.feature.has.XHR2 && f instanceof FormData)) {
                b["Content-Type"] = m
            }
        }
        if (((i.getUseDefaultXhrHeader() && o.useDefaultXhrHeader !== false) || o.useDefaultXhrHeader) && !b["X-Requested-With"]) {
            b["X-Requested-With"] = i.getDefaultXhrHeader()
        }
        if (!Ext.isEmpty(o.username) && !Ext.isEmpty(o.password)) {
            b.Authorization = "Basic " + btoa(o.username + ":" + o.password)
        }
        try {
            for (k in b) {
                if (b.hasOwnProperty(k)) {
                    g = b[k];
                    n.setRequestHeader(k, g)
                }
            }
        } catch(h) {
            i.fireEvent("exception", k, g)
        }
        if (o.responseType) {
            try {
                n.responseType = o.responseType === "blob" && Ext.browser.is.Safari ? "arraybuffer": o.responseType
            } catch(h) {}
        }
        if (o.withCredentials) {
            n.withCredentials = o.withCredentials
        }
        return b
    },
    getXhrInstance: (function() {
        var b = [function() {
            return new XMLHttpRequest()
        },
        function() {
            return new ActiveXObject("MSXML2.XMLHTTP.3.0")
        },
        function() {
            return new ActiveXObject("MSXML2.XMLHTTP")
        },
        function() {
            return new ActiveXObject("Microsoft.XMLHTTP")
        }],
        d = 0,
        a = b.length,
        g;
        for (; d < a; ++d) {
            try {
                g = b[d];
                g();
                break
            } catch(f) {}
        }
        return g
    })(),
    isLoading: function(a) {
        if (! (a && a.xhr)) {
            return false
        }
        var b = a.xhr.readyState;
        return ! (b === 0 || b == 4)
    },
    abort: function(b) {
        var a = this,
        e = a.requests,
        d;
        if (b && a.isLoading(b)) {
            b.xhr.onreadystatechange = null;
            b.xhr.abort();
            a.clearTimeout(b);
            if (!b.timedout) {
                b.aborted = true
            }
            a.onComplete(b);
            a.cleanup(b)
        } else {
            if (!b) {
                for (d in e) {
                    if (e.hasOwnProperty(d)) {
                        a.abort(e[d])
                    }
                }
            }
        }
    },
    abortAll: function() {
        this.abort()
    },
    onStateChange: function(a) {
        if (a.xhr.readyState == 4) {
            this.clearTimeout(a);
            this.onComplete(a);
            this.cleanup(a)
        }
    },
    clearTimeout: function(a) {
        clearTimeout(a.timeout);
        delete a.timeout
    },
    cleanup: function(a) {
        a.xhr = null;
        delete a.xhr
    },
    onComplete: function(g) {
        var f = this,
        d = g.options,
        a, i, b;
        try {
            a = f.parseStatus(g.xhr.status, g.xhr);
            if (g.timedout) {
                a.success = false
            }
        } catch(h) {
            a = {
                success: false,
                isException: false
            }
        }
        i = a.success;
        if (i) {
            b = f.createResponse(g);
            f.fireEvent("requestcomplete", f, b, d);
            Ext.callback(d.success, d.scope, [b, d])
        } else {
            if (a.isException || g.aborted || g.timedout) {
                b = f.createException(g)
            } else {
                b = f.createResponse(g)
            }
            f.fireEvent("requestexception", f, b, d);
            Ext.callback(d.failure, d.scope, [b, d])
        }
        Ext.callback(d.callback, d.scope, [d, i, b]);
        if (d.progress && d.progress.isProgressable) {
            Ext.callback(d.progress.endProgress, d.progress, [a])
        }
        delete f.requests[g.id];
        return b
    },
    parseStatus: function(a, e) {
        a = a == 1223 ? 204 : a;
        var d = (a >= 200 && a < 300) || a == 304 || (a == 0 && e.responseText && e.responseText.length > 0),
        b = false;
        if (!d) {
            switch (a) {
            case 12002:
            case 12029:
            case 12030:
            case 12031:
            case 12152:
            case 13030:
                b = true;
                break
            }
        }
        return {
            success: d,
            isException: b
        }
    },
    createResponse: function(e) {
        var k = e.xhr,
        a = {},
        m, g, n, h, j, b, f = k.responseType === "blob" || k.responseType === "arraybuffer",
        i = k.responseType === "text",
        d = k.responseType === "document";
        if (e.timedout || e.aborted) {
            e.success = false;
            m = []
        } else {
            m = k.getAllResponseHeaders().replace(this.lineBreakRe, "\n").split("\n")
        }
        g = m.length;
        while (g--) {
            n = m[g];
            h = n.indexOf(":");
            if (h >= 0) {
                j = n.substr(0, h).toLowerCase();
                if (n.charAt(h + 1) == " ") {++h
                }
                a[j] = n.substr(h + 1)
            }
        }
        e.xhr = null;
        delete e.xhr;
        b = {
            request: e,
            requestId: e.id,
            status: k.status,
            statusText: k.statusText,
            getResponseHeader: function(o) {
                return a[o.toLowerCase()]
            },
            getAllResponseHeaders: function() {
                return a
            },
            responseText: f ? null: d ? null: k.responseText,
            responseXML: f ? null: i ? null: k.responseXML,
            responseBytes: f ? k.response: null
        };
        if (e.options.responseType === "blob" && k.responseType === "arraybuffer") {
            b.responseBytes = new Blob([b.responseBytes], {
                type: k.getResponseHeader("Content-Type")
            })
        }
        k = null;
        return b
    },
    createException: function(a) {
        return {
            request: a,
            requestId: a.id,
            status: a.aborted ? -1 : 0,
            statusText: a.aborted ? "transaction aborted": "communication failure",
            aborted: a.aborted,
            timedout: a.timedout
        }
    }
});
Ext.define("Ext.Ajax", {
    extend: Ext.data.Connection,
    singleton: true,
    autoAbort: false
});
Ext.define("Ext.ComponentQuery", {
    singleton: true
},
function() {
    var h = this,
    k = ["var r = [],", "i = 0,", "it = items,", "l = it.length,", "c;", "for (; i < l; i++) {", "c = it[i];", "if (c.{0}) {", "r.push(c);", "}", "}", "return r;"].join(""),
    f = function(q, p) {
        return p.method.apply(this, [q].concat(p.args))
    },
    a = function(r, v) {
        var p = [],
        s = 0,
        u = r.length,
        t,
        q = v !== ">";
        for (; s < u; s++) {
            t = r[s];
            if (t.getRefItems) {
                p = p.concat(t.getRefItems(q))
            }
        }
        return p
    },
    g = function(q) {
        var p = [],
        r = 0,
        t = q.length,
        s;
        for (; r < t; r++) {
            s = q[r];
            while ( !! (s = (s.ownerCt || s.floatParent))) {
                p.push(s)
            }
        }
        return p
    },
    n = function(q, v, u) {
        if (v === "*") {
            return q.slice()
        } else {
            var p = [],
            r = 0,
            t = q.length,
            s;
            for (; r < t; r++) {
                s = q[r];
                if (s.isXType(v, u)) {
                    p.push(s)
                }
            }
            return p
        }
    },
    j = function(q, t) {
        var v = Ext.Array,
        p = [],
        r = 0,
        u = q.length,
        s;
        for (; r < u; r++) {
            s = q[r];
            if (s.el ? s.el.hasCls(t) : v.contains(s.initCls(), t)) {
                p.push(s)
            }
        }
        return p
    },
    o = function(t, y, q, v) {
        var A = [],
        s = 0,
        p = t.length,
        z,
        u,
        r;
        for (; s < p; s++) {
            z = t[s];
            u = Ext.Class.getConfigNameMap(y).get;
            if (z[u]) {
                r = z[u]();
                if (!v ? !!r: (String(r) === v)) {
                    A.push(z)
                }
            } else {
                if (z.config && z.config[y]) {
                    if (!v ? !!z.config[y] : (String(z.config[y]) === v)) {
                        A.push(z)
                    }
                } else {
                    if (!v ? !!z[y] : (String(z[y]) === v)) {
                        A.push(z)
                    }
                }
            }
        }
        return A
    },
    e = function(q, u) {
        var p = [],
        r = 0,
        t = q.length,
        s;
        for (; r < t; r++) {
            s = q[r];
            if (s.getId() === u || s.getItemId() === u) {
                p.push(s)
            }
        }
        return p
    },
    m = function(p, q, r) {
        return h.pseudos[q](p, r)
    },
    i = /^(\s?([>\^])\s?|\s|$)/,
    d = /^(#)?([\w\-]+|\*)(?:\((true|false)\))?/,
    b = [{
        re: /^\.([\w\-]+)(?:\((true|false)\))?/,
        method: n
    },
    {
        re: /^(?:[\[](?:@)?([\w\-]+)\s?(?:(=|.=)\s?['"]?(.*?)["']?)?[\]])/,
        method: o
    },
    {
        re: /^#([\w\-]+)/,
        method: e
    },
    {
        re: /^\:([\w\-]+)(?:\(((?:\{[^\}]+\})|(?:(?!\{)[^\s>\/]*?(?!\})))\))?/,
        method: m
    },
    {
        re: /^(?:\{([^\}]+)\})/,
        method: k
    }];
    h.Query = Ext.extend(Object, {
        constructor: function(p) {
            p = p || {};
            Ext.apply(this, p)
        },
        execute: function(q) {
            var s = this.operations,
            t = 0,
            u = s.length,
            r, p;
            if (!q) {
                p = Ext.ComponentManager.all.getArray()
            } else {
                if (Ext.isArray(q)) {
                    p = q
                }
            }
            for (; t < u; t++) {
                r = s[t];
                if (r.mode === "^") {
                    p = g(p || [q])
                } else {
                    if (r.mode) {
                        p = a(p || [q], r.mode)
                    } else {
                        p = f(p || a([q]), r)
                    }
                }
                if (t === u - 1) {
                    return p
                }
            }
            return []
        },
        is: function(r) {
            var q = this.operations,
            u = Ext.isArray(r) ? r: [r],
            p = u.length,
            v = q[q.length - 1],
            t,
            s;
            u = f(u, v);
            if (u.length === p) {
                if (q.length > 1) {
                    for (s = 0, t = u.length; s < t; s++) {
                        if (Ext.Array.indexOf(this.execute(), u[s]) === -1) {
                            return false
                        }
                    }
                }
                return true
            }
            return false
        }
    });
    Ext.apply(this, {
        cache: {},
        pseudos: {
            not: function(v, p) {
                var y = Ext.ComponentQuery,
                t = 0,
                u = v.length,
                s = [],
                r = -1,
                q;
                for (; t < u; ++t) {
                    q = v[t];
                    if (!y.is(q, p)) {
                        s[++r] = q
                    }
                }
                return s
            }
        },
        query: function(q, z) {
            var A = q.split(","),
            p = A.length,
            r = 0,
            s = [],
            B = [],
            y = {},
            u,
            t,
            v;
            for (; r < p; r++) {
                q = Ext.String.trim(A[r]);
                u = this.parse(q);
                s = s.concat(u.execute(z))
            }
            if (p > 1) {
                t = s.length;
                for (r = 0; r < t; r++) {
                    v = s[r];
                    if (!y[v.id]) {
                        B.push(v);
                        y[v.id] = true
                    }
                }
                s = B
            }
            return s
        },
        is: function(q, p) {
            if (!p) {
                return true
            }
            var r = this.cache[p];
            if (!r) {
                this.cache[p] = r = this.parse(p)
            }
            return r.is(q)
        },
        parse: function(s) {
            var q = [],
            r = b.length,
            y,
            t,
            z,
            A,
            B,
            u,
            v,
            p;
            while (s && y !== s) {
                y = s;
                t = s.match(d);
                if (t) {
                    z = t[1];
                    if (z === "#") {
                        q.push({
                            method: e,
                            args: [Ext.String.trim(t[2])]
                        })
                    } else {
                        if (z === ".") {
                            q.push({
                                method: j,
                                args: [Ext.String.trim(t[2])]
                            })
                        } else {
                            q.push({
                                method: n,
                                args: [Ext.String.trim(t[2]), Boolean(t[3])]
                            })
                        }
                    }
                    s = s.replace(t[0], "")
                }
                while (! (A = s.match(i))) {
                    for (u = 0; s && u < r; u++) {
                        v = b[u];
                        B = s.match(v.re);
                        p = v.method;
                        if (B) {
                            q.push({
                                method: Ext.isString(v.method) ? Ext.functionFactory("items", Ext.String.format.apply(Ext.String, [p].concat(B.slice(1)))) : v.method,
                                args: B.slice(1)
                            });
                            s = s.replace(B[0], "");
                            break
                        }
                    }
                }
                if (A[1]) {
                    q.push({
                        mode: A[2] || A[1]
                    });
                    s = s.replace(A[0], "")
                }
            }
            return new h.Query({
                operations: q
            })
        }
    })
});
Ext.define("Ext.Decorator", {
    extend: Ext.Component,
    isDecorator: true,
    config: {
        component: {}
    },
    statics: {
        generateProxySetter: function(a) {
            return function(d) {
                var b = this.getComponent();
                b[a].call(b, d);
                return this
            }
        },
        generateProxyGetter: function(a) {
            return function() {
                var b = this.getComponent();
                return b[a].call(b)
            }
        }
    },
    onClassExtended: function(d, f) {
        if (!f.hasOwnProperty("proxyConfig")) {
            return
        }
        var g = Ext.Class,
        j = f.proxyConfig,
        e = f.config;
        f.config = (e) ? Ext.applyIf(e, j) : j;
        var b, i, h, a;
        for (b in j) {
            if (j.hasOwnProperty(b)) {
                i = g.getConfigNameMap(b);
                h = i.set;
                a = i.get;
                f[h] = this.generateProxySetter(h);
                f[a] = this.generateProxyGetter(a)
            }
        }
    },
    applyComponent: function(a) {
        return Ext.factory(a, Ext.Component)
    },
    updateComponent: function(a, b) {
        if (b) {
            if (this.isRendered() && b.setRendered(false)) {
                b.fireAction("renderedchange", [this, b, false], "doUnsetComponent", this, {
                    args: [b]
                })
            } else {
                this.doUnsetComponent(b)
            }
        }
        if (a) {
            if (this.isRendered() && a.setRendered(true)) {
                a.fireAction("renderedchange", [this, a, true], "doSetComponent", this, {
                    args: [a]
                })
            } else {
                this.doSetComponent(a)
            }
        }
    },
    doUnsetComponent: function(a) {
        if (a.renderElement.dom) {
            a.setLayoutSizeFlags(0);
            this.innerElement.dom.removeChild(a.renderElement.dom)
        }
    },
    doSetComponent: function(a) {
        if (a.renderElement.dom) {
            a.setLayoutSizeFlags(this.getSizeFlags());
            this.innerElement.dom.appendChild(a.renderElement.dom)
        }
    },
    setRendered: function(b) {
        var a;
        if (this.callParent(arguments)) {
            a = this.getComponent();
            if (a) {
                a.setRendered(b)
            }
            return true
        }
        return false
    },
    setDisabled: function(a) {
        this.callParent(arguments);
        this.getComponent().setDisabled(a)
    },
    destroy: function() {
        Ext.destroy(this.getComponent());
        this.callParent()
    }
});
Ext.define("Ext.LoadMask", {
    extend: Ext.Mask,
    xtype: "loadmask",
    config: {
        message: "Loading...",
        cls: Ext.baseCSSPrefix + "loading-mask",
        messageCls: Ext.baseCSSPrefix + "mask-message",
        indicator: true
    },
    getTemplate: function() {
        var a = Ext.baseCSSPrefix;
        return [{
            reference: "innerElement",
            cls: a + "mask-inner",
            children: [{
                reference: "indicatorElement",
                cls: a + "loading-spinner-outer",
                children: [{
                    cls: a + "loading-spinner",
                    children: [{
                        tag: "span",
                        cls: a + "loading-top"
                    },
                    {
                        tag: "span",
                        cls: a + "loading-right"
                    },
                    {
                        tag: "span",
                        cls: a + "loading-bottom"
                    },
                    {
                        tag: "span",
                        cls: a + "loading-left"
                    }]
                }]
            },
            {
                reference: "messageElement"
            }]
        }]
    },
    updateMessage: function(b) {
        var a = Ext.baseCSSPrefix + "has-message";
        if (b) {
            this.addCls(a)
        } else {
            this.removeCls(a)
        }
        this.messageElement.setHtml(b)
    },
    updateMessageCls: function(b, a) {
        this.messageElement.replaceCls(a, b)
    },
    updateIndicator: function(a) {
        this[a ? "removeCls": "addCls"](Ext.baseCSSPrefix + "indicator-hidden")
    }
},
function() {});
Ext.define("Ext.Title", {
    extend: Ext.Component,
    xtype: "title",
    config: {
        baseCls: "x-title",
        title: ""
    },
    updateTitle: function(a) {
        this.setHtml(a)
    }
});
Ext.define("Ext.Spacer", {
    extend: Ext.Component,
    alias: "widget.spacer",
    config: {},
    constructor: function(a) {
        a = a || {};
        if (!a.width) {
            a.flex = 1
        }
        this.callParent([a])
    }
});
Ext.define("Ext.Toolbar", {
    extend: Ext.Container,
    xtype: "toolbar",
    isToolbar: true,
    config: {
        baseCls: Ext.baseCSSPrefix + "toolbar",
        ui: "dark",
        title: null,
        defaultType: "button",
        minHeight: null,
        layout: {
            type: "hbox",
            align: "center"
        }
    },
    hasCSSMinHeight: true,
    constructor: function(a) {
        a = a || {};
        if (a.docked == "left" || a.docked == "right") {
            a.layout = {
                type: "vbox",
                align: "stretch"
            }
        }
        this.callParent([a])
    },
    applyTitle: function(a) {
        if (typeof a == "string") {
            a = {
                title: a,
                centered: Ext.theme.is.Tizen ? false: true
            }
        }
        return Ext.factory(a, Ext.Title, this.getTitle())
    },
    updateTitle: function(b, a) {
        if (b) {
            this.add(b)
        }
        if (a) {
            a.destroy()
        }
    },
    showTitle: function() {
        var a = this.getTitle();
        if (a) {
            a.show()
        }
    },
    hideTitle: function() {
        var a = this.getTitle();
        if (a) {
            a.hide()
        }
    }
},
function() {});
Ext.define("Ext.field.Input", {
    extend: Ext.Component,
    xtype: "input",
    tag: "input",
    cachedConfig: {
        cls: Ext.baseCSSPrefix + "form-field",
        focusCls: Ext.baseCSSPrefix + "field-focus",
        maskCls: Ext.baseCSSPrefix + "field-mask",
        useMask: "auto",
        type: "text",
        checked: false
    },
    config: {
        baseCls: Ext.baseCSSPrefix + "field-input",
        name: null,
        value: null,
        isFocused: false,
        tabIndex: null,
        placeHolder: null,
        minValue: null,
        maxValue: null,
        stepValue: null,
        maxLength: null,
        autoComplete: null,
        autoCapitalize: null,
        autoCorrect: null,
        readOnly: null,
        maxRows: null,
        pattern: null,
        startValue: false,
        fastFocus: true
    },
    getTemplate: function() {
        var a = [{
            reference: "input",
            tag: this.tag
        },
        {
            reference: "mask",
            classList: [this.config.maskCls]
        },
        {
            reference: "clearIcon",
            cls: "x-clear-icon"
        }];
        return a
    },
    initElement: function() {
        var a = this;
        a.callParent();
        a.input.on({
            scope: a,
            keyup: "onKeyUp",
            keydown: "onKeyDown",
            focus: "onFocus",
            blur: "onBlur",
            input: "onInput",
            paste: "onPaste",
            tap: "onInputTap"
        });
        a.mask.on({
            scope: a,
            tap: "onMaskTap"
        });
        if (a.clearIcon) {
            a.clearIcon.on({
                tap: "onClearIconTap",
                touchstart: "onClearIconPress",
                touchend: "onClearIconRelease",
                scope: a
            })
        }
        if (Ext.browser.is.ie && Ext.browser.version.major >= 10) {
            a.input.on({
                scope: a,
                keypress: "onKeyPress"
            })
        }
    },
    updateFastFocus: function(a) {
        if (a) {
            if (this.getFastFocus() && Ext.os.is.iOS) {
                this.input.on({
                    scope: this,
                    touchstart: "onTouchStart"
                })
            }
        } else {
            this.input.un({
                scope: this,
                touchstart: "onTouchStart"
            })
        }
    },
    useManualMaxLength: function() {
        return Boolean((Ext.os.is.Android && !Ext.browser.is.Chrome))
    },
    applyUseMask: function(a) {
        if (a === "auto") {
            a = Ext.os.is.iOS && Ext.os.version.lt("5")
        }
        return Boolean(a)
    },
    updateUseMask: function(a) {
        this.mask[a ? "show": "hide"]()
    },
    updatePattern: function(a) {
        this.updateFieldAttribute("pattern", a)
    },
    updateFieldAttribute: function(b, d) {
        var a = this.input;
        if (!Ext.isEmpty(d, true)) {
            a.dom.setAttribute(b, d)
        } else {
            a.dom.removeAttribute(b)
        }
    },
    updateCls: function(b, a) {
        this.input.addCls(Ext.baseCSSPrefix + "input-el");
        this.input.replaceCls(a, b)
    },
    updateType: function(a, d) {
        var b = Ext.baseCSSPrefix + "input-";
        this.input.replaceCls(b + d, b + a);
        this.updateFieldAttribute("type", a)
    },
    updateName: function(a) {
        this.updateFieldAttribute("name", a)
    },
    getValue: function() {
        var a = this.input;
        if (a) {
            this._value = a.dom.value
        }
        return this._value
    },
    applyValue: function(a) {
        return (Ext.isEmpty(a)) ? "": a
    },
    updateValue: function(b) {
        var a = this.input;
        if (a) {
            a.dom.value = b
        }
    },
    setValue: function(b) {
        var a = this._value;
        this.updateValue(this.applyValue(b));
        b = this.getValue();
        if (String(b) != String(a) && this.initialized) {
            this.onChange(this, b, a)
        }
        return this
    },
    updateTabIndex: function(a) {
        this.updateFieldAttribute("tabIndex", a)
    },
    testAutoFn: function(a) {
        return [true, "on"].indexOf(a) !== -1
    },
    updateMaxLength: function(a) {
        if (!this.useManualMaxLength()) {
            this.updateFieldAttribute("maxlength", a)
        }
    },
    updatePlaceHolder: function(a) {
        this.updateFieldAttribute("placeholder", a)
    },
    applyAutoComplete: function(a) {
        return this.testAutoFn(a)
    },
    updateAutoComplete: function(a) {
        var b = a ? "on": "off";
        this.updateFieldAttribute("autocomplete", b)
    },
    applyAutoCapitalize: function(a) {
        return this.testAutoFn(a)
    },
    updateAutoCapitalize: function(b) {
        var a = b ? "on": "off";
        this.updateFieldAttribute("autocapitalize", a)
    },
    applyAutoCorrect: function(a) {
        return this.testAutoFn(a)
    },
    updateAutoCorrect: function(a) {
        var b = a ? "on": "off";
        this.updateFieldAttribute("autocorrect", b)
    },
    updateMinValue: function(a) {
        this.updateFieldAttribute("min", a)
    },
    updateMaxValue: function(a) {
        this.updateFieldAttribute("max", a)
    },
    updateStepValue: function(a) {
        this.updateFieldAttribute("step", a)
    },
    checkedRe: /^(true|1|on)/i,
    getChecked: function() {
        var a = this.input,
        b;
        if (a) {
            b = a.dom.checked;
            this._checked = b
        }
        return b
    },
    applyChecked: function(a) {
        return !! this.checkedRe.test(String(a))
    },
    setChecked: function(a) {
        this.updateChecked(this.applyChecked(a));
        this._checked = a
    },
    updateChecked: function(a) {
        this.input.dom.checked = a
    },
    updateReadOnly: function(a) {
        this.updateFieldAttribute("readonly", a ? true: null)
    },
    updateMaxRows: function(a) {
        this.updateFieldAttribute("rows", a)
    },
    doSetDisabled: function(a) {
        this.callParent(arguments);
        if (Ext.browser.is.Safari && !Ext.os.is.BlackBerry) {
            this.input.dom.tabIndex = (a) ? -1 : 0
        }
        this.input.dom.disabled = (Ext.browser.is.Safari && !Ext.os.is.BlackBerry) ? false: a;
        if (!a) {
            this.blur()
        }
    },
    isDirty: function() {
        if (this.getDisabled()) {
            return false
        }
        return String(this.getValue()) !== String(this.originalValue)
    },
    reset: function() {
        this.setValue(this.originalValue)
    },
    onInputTap: function(a) {
        this.fireAction("inputtap", [this, a], "doInputTap")
    },
    doInputTap: function(a, b) {
        if (a.getDisabled()) {
            return false
        }
        if (this.getFastFocus() && Ext.os.is.iOS) {
            a.focus()
        }
    },
    onMaskTap: function(a) {
        this.fireAction("masktap", [this, a], "doMaskTap")
    },
    doMaskTap: function(a, b) {
        if (a.getDisabled()) {
            return false
        }
        a.focus()
    },
    showMask: function() {
        if (this.getUseMask()) {
            this.mask.setStyle("display", "block")
        }
    },
    hideMask: function() {
        if (this.getUseMask()) {
            this.mask.setStyle("display", "none")
        }
    },
    focus: function() {
        var b = this,
        a = b.input;
        if (a && a.dom.focus) {
            a.dom.focus()
        }
        return b
    },
    blur: function() {
        var b = this,
        a = this.input;
        if (a && a.dom.blur) {
            a.dom.blur()
        }
        return b
    },
    select: function() {
        var b = this,
        a = b.input;
        if (a && a.dom.setSelectionRange) {
            a.dom.setSelectionRange(0, 9999)
        }
        return b
    },
    onFocus: function(a) {
        this.fireAction("focus", [a], "doFocus")
    },
    doFocus: function(b) {
        var a = this;
        a.hideMask();
        if (!a.getIsFocused()) {
            a.setStartValue(a.getValue())
        }
        a.setIsFocused(true)
    },
    onTouchStart: function(a) {
        if (document.activeElement != a.target) {
            a.preventDefault()
        }
    },
    onBlur: function(a) {
        this.fireAction("blur", [a], "doBlur")
    },
    doBlur: function(f) {
        var b = this,
        d = b.getValue(),
        a = b.getStartValue();
        b.showMask();
        b.setIsFocused(false);
        if (String(d) != String(a)) {
            b.onChange(b, d, a)
        }
    },
    onClearIconTap: function(a) {
        this.fireEvent("clearicontap", this, a);
        if (Ext.os.is.Android) {
            this.focus()
        }
    },
    onClearIconPress: function() {
        this.clearIcon.addCls(Ext.baseCSSPrefix + "pressing")
    },
    onClearIconRelease: function() {
        this.clearIcon.removeCls(Ext.baseCSSPrefix + "pressing")
    },
    onClick: function(a) {
        this.fireEvent("click", a)
    },
    onChange: function(b, d, a) {
        if (this.useManualMaxLength()) {
            this.trimValueToMaxLength()
        }
        this.fireEvent("change", b, d, a)
    },
    onPaste: function(a) {
        if (this.useManualMaxLength()) {
            this.trimValueToMaxLength()
        }
        this.fireEvent("paste", a)
    },
    onKeyUp: function(a) {
        if (this.useManualMaxLength()) {
            this.trimValueToMaxLength()
        }
        this.fireEvent("keyup", a)
    },
    onKeyDown: function() {
        this.ignoreInput = true
    },
    onInput: function(b) {
        var a = this;
        if (a.ignoreInput) {
            a.ignoreInput = false;
            return
        }
        setTimeout(function() {
            if (!a.ignoreInput) {
                a.fireEvent("keyup", b);
                a.ignoreInput = false
            }
        },
        10)
    },
    onKeyPress: function(a) {
        if (a.browserEvent.keyCode == 13) {
            this.fireEvent("keyup", a)
        }
    },
    onMouseDown: function(a) {
        this.fireEvent("mousedown", a)
    },
    trimValueToMaxLength: function() {
        var a = this.getMaxLength();
        if (a) {
            var b = this.getValue();
            if (b.length > this.getMaxLength()) {
                this.setValue(b.slice(0, a))
            }
        }
    }
});
Ext.define("Ext.field.Field", {
    extend: Ext.Decorator,
    alternateClassName: "Ext.form.Field",
    xtype: "field",
    isField: true,
    isFormField: true,
    config: {
        baseCls: Ext.baseCSSPrefix + "field",
        label: null,
        labelAlign: "left",
        labelWidth: "30%",
        labelWrap: false,
        clearIcon: null,
        required: false,
        inputType: null,
        name: null,
        value: null,
        tabIndex: null
    },
    platformConfig: [{
        theme: ["Windows", "MountainView", "Blackberry", "Tizen"],
        labelAlign: "top"
    }],
    cachedConfig: {
        labelCls: null,
        requiredCls: Ext.baseCSSPrefix + "field-required",
        inputCls: null
    },
    getElementConfig: function() {
        var a = Ext.baseCSSPrefix;
        return {
            reference: "element",
            className: "x-container",
            children: [{
                reference: "label",
                cls: a + "form-label",
                children: [{
                    reference: "labelspan",
                    tag: "span"
                }]
            },
            {
                reference: "innerElement",
                cls: a + "component-outer"
            }]
        }
    },
    updateLabel: function(b, e) {
        var a = this.renderElement,
        d = Ext.baseCSSPrefix;
        if (b) {
            this.labelspan.setHtml(b);
            a.addCls(d + "field-labeled")
        } else {
            a.removeCls(d + "field-labeled")
        }
    },
    updateLabelAlign: function(b, d) {
        var a = this.renderElement,
        e = Ext.baseCSSPrefix;
        if (b) {
            a.addCls(e + "label-align-" + b);
            if (b == "top" || b == "bottom") {
                this.label.setWidth("100%")
            } else {
                this.updateLabelWidth(this.getLabelWidth())
            }
        }
        if (d) {
            a.removeCls(e + "label-align-" + d)
        }
    },
    updateLabelCls: function(a, b) {
        if (a) {
            this.label.addCls(a)
        }
        if (b) {
            this.label.removeCls(b)
        }
    },
    updateLabelWidth: function(b) {
        var a = this.getLabelAlign();
        if (b) {
            if (a == "top" || a == "bottom") {
                this.label.setWidth("100%")
            } else {
                this.label.setWidth(b)
            }
        }
    },
    updateLabelWrap: function(b, d) {
        var a = Ext.baseCSSPrefix + "form-label-nowrap";
        if (!b) {
            this.addCls(a)
        } else {
            this.removeCls(a)
        }
    },
    updateRequired: function(a) {
        this.renderElement[a ? "addCls": "removeCls"](this.getRequiredCls())
    },
    updateRequiredCls: function(a, b) {
        if (this.getRequired()) {
            this.renderElement.replaceCls(b, a)
        }
    },
    initialize: function() {
        var a = this;
        a.callParent();
        a.doInitValue()
    },
    doInitValue: function() {
        this.originalValue = this.getInitialConfig().value
    },
    reset: function() {
        this.setValue(this.originalValue);
        return this
    },
    resetOriginalValue: function() {
        this.originalValue = this.getValue()
    },
    isDirty: function() {
        return false
    }
},
function() {});
Ext.define("Ext.field.Text", {
    extend: Ext.field.Field,
    xtype: "textfield",
    alternateClassName: "Ext.form.Text",
    config: {
        ui: "text",
        clearIcon: true,
        placeHolder: null,
        maxLength: null,
        autoComplete: null,
        autoCapitalize: null,
        autoCorrect: null,
        readOnly: null,
        component: {
            xtype: "input",
            type: "text",
            fastFocus: true
        },
        bubbleEvents: ["action"]
    },
    initialize: function() {
        var a = this;
        a.callParent();
        a.getComponent().on({
            scope: this,
            keyup: "onKeyUp",
            change: "onChange",
            focus: "onFocus",
            blur: "onBlur",
            paste: "onPaste",
            mousedown: "onMouseDown",
            clearicontap: "onClearIconTap"
        });
        a.originalValue = a.getValue() || "";
        a.getComponent().originalValue = a.originalValue;
        a.syncEmptyCls()
    },
    syncEmptyCls: function() {
        var b = (this._value) ? this._value.length: false,
        a = Ext.baseCSSPrefix + "empty";
        if (b) {
            this.removeCls(a)
        } else {
            this.addCls(a)
        }
    },
    updateValue: function(d) {
        var b = this.getComponent(),
        a = d !== undefined && d !== null && d !== "";
        if (b) {
            b.setValue(d)
        }
        this[a && this.isDirty() ? "showClearIcon": "hideClearIcon"]();
        this.syncEmptyCls()
    },
    getValue: function() {
        var a = this;
        a._value = a.getComponent().getValue();
        a.syncEmptyCls();
        return a._value
    },
    updatePlaceHolder: function(a) {
        this.getComponent().setPlaceHolder(a)
    },
    updateMaxLength: function(a) {
        this.getComponent().setMaxLength(a)
    },
    updateAutoComplete: function(a) {
        this.getComponent().setAutoComplete(a)
    },
    updateAutoCapitalize: function(a) {
        this.getComponent().setAutoCapitalize(a)
    },
    updateAutoCorrect: function(a) {
        this.getComponent().setAutoCorrect(a)
    },
    updateReadOnly: function(a) {
        if (a) {
            this.hideClearIcon()
        } else {
            this.showClearIcon()
        }
        this.getComponent().setReadOnly(a)
    },
    updateInputType: function(a) {
        var b = this.getComponent();
        if (b) {
            b.setType(a)
        }
    },
    updateName: function(a) {
        var b = this.getComponent();
        if (b) {
            b.setName(a)
        }
    },
    updateTabIndex: function(b) {
        var a = this.getComponent();
        if (a) {
            a.setTabIndex(b)
        }
    },
    updateInputCls: function(a, b) {
        var d = this.getComponent();
        if (d) {
            d.replaceCls(b, a)
        }
    },
    doSetDisabled: function(b) {
        var d = this;
        d.callParent(arguments);
        var a = d.getComponent();
        if (a) {
            a.setDisabled(b)
        }
        if (b) {
            d.hideClearIcon()
        } else {
            d.showClearIcon()
        }
    },
    showClearIcon: function() {
        var b = this,
        d = b.getValue(),
        a = d !== undefined && d !== null && d !== "";
        if (b.getClearIcon() && !b.getDisabled() && !b.getReadOnly() && a) {
            b.element.addCls(Ext.baseCSSPrefix + "field-clearable")
        }
        return b
    },
    hideClearIcon: function() {
        if (this.getClearIcon()) {
            this.element.removeCls(Ext.baseCSSPrefix + "field-clearable")
        }
    },
    onKeyUp: function(a) {
        this.fireAction("keyup", [this, a], "doKeyUp")
    },
    doKeyUp: function(b, f) {
        var d = b.getValue(),
        a = d !== undefined && d !== null && d !== "";
        this[a ? "showClearIcon": "hideClearIcon"]();
        if (f.browserEvent.keyCode === 13) {
            b.fireAction("action", [b, f], "doAction")
        }
    },
    doAction: function() {
        this.blur()
    },
    onClearIconTap: function(a) {
        this.fireAction("clearicontap", [this, a], "doClearIconTap")
    },
    doClearIconTap: function(a, b) {
        a.setValue("");
        a.getValue()
    },
    onChange: function(b, d, a) {
        b.fireEvent("change", this, d, a)
    },
    onFocus: function(a) {
        this.addCls(Ext.baseCSSPrefix + "field-focused");
        this.isFocused = true;
        this.fireEvent("focus", this, a)
    },
    onBlur: function(b) {
        var a = this;
        this.removeCls(Ext.baseCSSPrefix + "field-focused");
        this.isFocused = false;
        a.fireEvent("blur", a, b);
        setTimeout(function() {
            a.isFocused = false
        },
        50)
    },
    onPaste: function(a) {
        this.fireEvent("paste", this, a)
    },
    onMouseDown: function(a) {
        this.fireEvent("mousedown", this, a)
    },
    focus: function() {
        this.getComponent().focus();
        return this
    },
    blur: function() {
        this.getComponent().blur();
        return this
    },
    select: function() {
        this.getComponent().select();
        return this
    },
    resetOriginalValue: function() {
        this.callParent();
        var a = this.getComponent();
        if (a && a.hasOwnProperty("originalValue")) {
            this.getComponent().originalValue = this.originalValue
        }
        this.reset()
    },
    reset: function() {
        this.getComponent().reset();
        this.getValue();
        this[this.isDirty() ? "showClearIcon": "hideClearIcon"]()
    },
    isDirty: function() {
        var a = this.getComponent();
        if (a) {
            return a.isDirty()
        }
        return false
    }
});
Ext.define("Ext.field.TextAreaInput", {
    extend: Ext.field.Input,
    xtype: "textareainput",
    tag: "textarea"
});
Ext.define("Ext.field.TextArea", {
    extend: Ext.field.Text,
    xtype: "textareafield",
    alternateClassName: "Ext.form.TextArea",
    config: {
        ui: "textarea",
        autoCapitalize: false,
        component: {
            xtype: "textareainput"
        },
        maxRows: null
    },
    updateMaxRows: function(a) {
        this.getComponent().setMaxRows(a)
    },
    doSetHeight: function(a) {
        this.callParent(arguments);
        var b = this.getComponent();
        b.input.setHeight(a)
    },
    doSetWidth: function(b) {
        this.callParent(arguments);
        var a = this.getComponent();
        a.input.setWidth(b)
    },
    doKeyUp: function(a) {
        var b = a.getValue();
        a[b ? "showClearIcon": "hideClearIcon"]()
    }
});
Ext.define("Ext.MessageBox", {
    extend: Ext.Sheet,
    config: {
        ui: "dark",
        baseCls: Ext.baseCSSPrefix + "msgbox",
        iconCls: null,
        showAnimation: {
            type: "popIn",
            duration: 250,
            easing: "ease-out"
        },
        hideAnimation: {
            type: "popOut",
            duration: 250,
            easing: "ease-out"
        },
        zIndex: 999,
        defaultTextHeight: 75,
        title: null,
        buttons: null,
        message: null,
        prompt: null,
        modal: true,
        layout: {
            type: "vbox",
            pack: "center"
        }
    },
    platformConfig: [{
        theme: ["Windows"],
        ui: "light",
        showAnimation: {
            type: "fadeIn"
        },
        hideAnimation: {
            type: "fadeOut"
        }
    },
    {
        theme: ["Blackberry"],
        ui: "plain"
    },
    {
        theme: ["MoutainView"]
    }],
    statics: {
        OK: {
            text: "OK",
            itemId: "ok",
            ui: "action"
        },
        YES: {
            text: "Yes",
            itemId: "yes",
            ui: "action"
        },
        NO: {
            text: "No",
            itemId: "no"
        },
        CANCEL: {
            text: "Cancel",
            itemId: "cancel"
        },
        INFO: Ext.baseCSSPrefix + "msgbox-info",
        WARNING: Ext.baseCSSPrefix + "msgbox-warning",
        QUESTION: Ext.baseCSSPrefix + "msgbox-question",
        ERROR: Ext.baseCSSPrefix + "msgbox-error",
        OKCANCEL: [{
            text: "Cancel",
            itemId: "cancel"
        },
        {
            text: "OK",
            itemId: "ok",
            ui: "action"
        }],
        YESNOCANCEL: [{
            text: "Cancel",
            itemId: "cancel"
        },
        {
            text: "No",
            itemId: "no"
        },
        {
            text: "Yes",
            itemId: "yes",
            ui: "action"
        }],
        YESNO: [{
            text: "No",
            itemId: "no"
        },
        {
            text: "Yes",
            itemId: "yes",
            ui: "action"
        }]
    },
    constructor: function(a) {
        a = a || {};
        if (a.hasOwnProperty("promptConfig")) {
            Ext.applyIf(a, {
                prompt: a.promptConfig
            });
            delete a.promptConfig
        }
        if (a.hasOwnProperty("multiline") || a.hasOwnProperty("multiLine")) {
            a.prompt = a.prompt || {};
            Ext.applyIf(a.prompt, {
                multiLine: a.multiline || a.multiLine
            });
            delete a.multiline;
            delete a.multiLine
        }
        this.defaultAllowedConfig = {};
        var f = ["ui", "showAnimation", "hideAnimation", "title", "message", "prompt", "iconCls", "buttons", "defaultTextHeight"],
        e = f.length,
        b,
        d;
        for (b = 0; b < e; b++) {
            d = f[b];
            this.defaultAllowedConfig[d] = this.defaultConfig[d]
        }
        this.callParent([a])
    },
    applyTitle: function(a) {
        if (typeof a == "string") {
            a = {
                title: a
            }
        }
        var b = "1.3em";
        if (Ext.theme.is.Cupertino) {
            b = "1.5em"
        } else {
            if (Ext.filterPlatform("blackberry") || Ext.filterPlatform("ie10")) {
                b = "2.6em"
            }
        }
        Ext.applyIf(a, {
            docked: "top",
            minHeight: b,
            ui: Ext.filterPlatform("blackberry") ? "light": "dark",
            cls: this.getBaseCls() + "-title"
        });
        if (Ext.theme.is.Tizen) {
            Ext.applyIf(a, {
                centered: false
            })
        }
        return Ext.factory(a, Ext.Toolbar, this.getTitle())
    },
    updateTitle: function(a) {
        if (a) {
            this.add(a)
        }
    },
    updateButtons: function(a) {
        var e = this;
        a = (!a || a.length === 0) ? false: a;
        if (a) {
            if (e.buttonsToolbar) {
                e.buttonsToolbar.show();
                e.buttonsToolbar.removeAll();
                e.buttonsToolbar.setItems(a)
            } else {
                var d = {
                    type: "hbox",
                    pack: "center"
                };
                var b = Ext.theme.is.CupertinoClassic || Ext.theme.is.MountainView || Ext.theme.is.Blackberry;
                e.buttonsToolbar = Ext.create("Ext.Toolbar", {
                    docked: "bottom",
                    defaultType: "button",
                    defaults: {
                        flex: (b) ? 1 : undefined,
                        ui: (Ext.theme.is.Blackberry) ? "action": undefined
                    },
                    layout: d,
                    ui: e.getUi(),
                    cls: e.getBaseCls() + "-buttons",
                    items: a
                });
                e.add(e.buttonsToolbar)
            }
        } else {
            if (e.buttonsToolbar) {
                e.buttonsToolbar.hide()
            }
        }
    },
    applyMessage: function(a) {
        a = {
            html: a,
            cls: this.getBaseCls() + "-text"
        };
        return Ext.factory(a, Ext.Component, this._message)
    },
    updateMessage: function(a) {
        if (a) {
            this.add(a)
        }
    },
    getMessage: function() {
        if (this._message) {
            return this._message.getHtml()
        }
        return null
    },
    applyIconCls: function(a) {
        a = {
            xtype: "component",
            docked: "left",
            width: 40,
            height: 40,
            baseCls: Ext.baseCSSPrefix + "icon",
            hidden: (a) ? false: true,
            cls: a
        };
        return Ext.factory(a, Ext.Component, this._iconCls)
    },
    updateIconCls: function(a, b) {
        this.getTitle();
        this.getButtons();
        if (a) {
            this.add(a)
        } else {
            this.remove(b)
        }
    },
    getIconCls: function() {
        var b = this._iconCls,
        a;
        if (b) {
            a = b.getCls();
            return (a) ? a[0] : null
        }
        return null
    },
    applyPrompt: function(a) {
        if (a) {
            var b = {
                label: false
            };
            if (Ext.isObject(a)) {
                Ext.apply(b, a)
            }
            if (b.multiLine) {
                b.height = Ext.isNumber(b.multiLine) ? parseFloat(b.multiLine) : this.getDefaultTextHeight();
                return Ext.factory(b, Ext.field.TextArea, this.getPrompt())
            } else {
                return Ext.factory(b, Ext.field.Text, this.getPrompt())
            }
        }
        return a
    },
    updatePrompt: function(a, b) {
        if (a) {
            this.add(a)
        }
        if (b) {
            this.remove(b)
        }
    },
    onClick: function(d) {
        if (d) {
            var b = d.config.userConfig || {},
            e = d.getInitialConfig(),
            a = this.getPrompt();
            if (typeof b.fn == "function") {
                d.disable();
                this.on({
                    hiddenchange: function() {
                        b.fn.call(b.scope || null, e.itemId || e.text, a ? a.getValue() : null, b);
                        d.enable()
                    },
                    single: true,
                    scope: this
                })
            }
            if (b.input) {
                b.input.dom.blur()
            }
        }
        this.hide()
    },
    show: function(g) {
        Ext.util.InputBlocker.blockInputs();
        if (!this.getParent() && Ext.Viewport) {
            Ext.Viewport.add(this)
        }
        if (!g) {
            return this.callParent()
        }
        var b = Ext.Object.merge({},
        {
            value: ""
        },
        g);
        var f = g.buttons || Ext.MessageBox.OK || [],
        e = [],
        d = g;
        Ext.each(f,
        function(h) {
            if (!h) {
                return
            }
            e.push(Ext.apply({
                userConfig: d,
                scope: this,
                handler: "onClick"
            },
            h))
        },
        this);
        b.buttons = e;
        if (b.promptConfig) {}
        b.prompt = (b.promptConfig || b.prompt) || null;
        if (b.multiLine) {
            b.prompt = b.prompt || {};
            b.prompt.multiLine = b.multiLine;
            delete b.multiLine
        }
        b = Ext.merge({},
        this.defaultAllowedConfig, b);
        this.setConfig(b);
        var a = this.getPrompt();
        if (a) {
            a.setValue(g.value || "")
        }
        this.callParent();
        return this
    },
    alert: function(e, d, b, a) {
        return this.show({
            title: e || null,
            message: d || null,
            buttons: Ext.MessageBox.OK,
            promptConfig: false,
            fn: function() {
                if (b) {
                    b.apply(a, arguments)
                }
            },
            scope: a
        })
    },
    confirm: function(e, d, b, a) {
        return this.show({
            title: e || null,
            message: d || null,
            buttons: Ext.MessageBox.YESNO,
            promptConfig: false,
            scope: a,
            fn: function() {
                if (b) {
                    b.apply(a, arguments)
                }
            }
        })
    },
    prompt: function(h, e, d, b, g, f, a) {
        return this.show({
            title: h || null,
            message: e || null,
            buttons: Ext.MessageBox.OKCANCEL,
            scope: b,
            prompt: a || true,
            multiLine: g,
            value: f,
            fn: function() {
                if (d) {
                    d.apply(b, arguments)
                }
            }
        })
    }
},
function(a) {
    Ext.onSetup(function() {
        Ext.Msg = new a
    })
});
Ext.define("Ext.SegmentedButton", {
    extend: Ext.Container,
    xtype: "segmentedbutton",
    config: {
        baseCls: Ext.baseCSSPrefix + "segmentedbutton",
        pressedCls: Ext.baseCSSPrefix + "button-pressed",
        allowMultiple: false,
        allowDepress: false,
        allowToggle: true,
        pressedButtons: [],
        layout: {
            type: "hbox",
            align: "stretch"
        },
        defaultType: "button"
    },
    initialize: function() {
        var a = this;
        a.callParent();
        a.on({
            delegate: "> button",
            scope: a,
            tap: "onButtonRelease"
        });
        a.onAfter({
            delegate: "> button",
            scope: a,
            hide: "onButtonHiddenChange",
            show: "onButtonHiddenChange"
        })
    },
    updateAllowMultiple: function(a) {
        if (!this.initialized && !this.getInitialConfig().hasOwnProperty("allowDepress") && a) {
            this.setAllowDepress(true)
        }
    },
    applyItems: function() {
        var f = this,
        g = [],
        e,
        b,
        d,
        a;
        f.callParent(arguments);
        a = this.getItems();
        e = a.length;
        for (b = 0; b < e; b++) {
            d = a.items[b];
            if (d.getInitialConfig("pressed")) {
                g.push(a.items[b])
            }
        }
        f.updateFirstAndLastCls(a);
        f.setPressedButtons(g)
    },
    onButtonRelease: function(a) {
        if (!this.getAllowToggle()) {
            return
        }
        var e = this,
        f = e.getPressedButtons() || [],
        d = [],
        b;
        if (!e.getDisabled() && !a.getDisabled()) {
            if (e.getAllowMultiple()) {
                d = f.concat(d)
            }
            b = (d.indexOf(a) !== -1) || (f.indexOf(a) !== -1);
            if (b && e.getAllowDepress()) {
                Ext.Array.remove(d, a)
            } else {
                if (!b || !e.getAllowDepress()) {
                    d.push(a)
                }
            }
            e.setPressedButtons(d)
        }
    },
    onItemAdd: function() {
        this.callParent(arguments);
        this.updateFirstAndLastCls(this.getItems())
    },
    onItemRemove: function() {
        this.callParent(arguments);
        this.updateFirstAndLastCls(this.getItems())
    },
    onButtonHiddenChange: function() {
        this.updateFirstAndLastCls(this.getItems())
    },
    updateFirstAndLastCls: function(b) {
        var f = b.length,
        g = Ext.baseCSSPrefix,
        a = g + "first",
        h = g + "last",
        e, d;
        for (d = 0; d < f; d++) {
            e = b.items[d];
            e.removeCls(a);
            e.removeCls(h)
        }
        for (d = 0; d < f; d++) {
            e = b.items[d];
            if (!e.isHidden()) {
                e.addCls(a);
                break
            }
        }
        for (d = f - 1; d >= 0; d--) {
            e = b.items[d];
            if (!e.isHidden()) {
                e.addCls(h);
                break
            }
        }
    },
    applyPressedButtons: function(a) {
        var f = this,
        g = [],
        d,
        e,
        b;
        if (f.getAllowToggle()) {
            if (Ext.isArray(a)) {
                e = a.length;
                for (b = 0; b < e; b++) {
                    d = f.getComponent(a[b]);
                    if (d && g.indexOf(d) === -1) {
                        g.push(d)
                    }
                }
            } else {
                d = f.getComponent(a);
                if (d && g.indexOf(d) === -1) {
                    g.push(d)
                }
            }
        }
        return g
    },
    updatePressedButtons: function(k, d) {
        var j = this,
        h = j.getItems(),
        m = j.getPressedCls(),
        o = [],
        n,
        b,
        g,
        a,
        f;
        g = h.length;
        if (d && d.length) {
            for (a = 0; a < g; a++) {
                n = h.items[a];
                if (d.indexOf(n) != -1 && k.indexOf(n) == -1) {
                    n.removeCls([m, n.getPressedCls()]);
                    o.push({
                        item: n,
                        toggle: false
                    })
                }
            }
        }
        g = k.length;
        for (a = 0; a < g; a++) {
            b = k[a];
            if (!d || d.indexOf(b) == -1) {
                b.addCls(m);
                o.push({
                    item: b,
                    toggle: true
                })
            }
        }
        g = o.length;
        if (g && d !== undefined) {
            Ext.defer(function() {
                for (a = 0; a < g; a++) {
                    f = o[a];
                    j.fireEvent("toggle", j, f.item, f.toggle)
                }
            },
            50)
        }
    },
    isPressed: function(a) {
        var b = this.getPressedButtons();
        return b.indexOf(a) != -1
    },
    doSetDisabled: function(a) {
        var b = this;
        b.items.each(function(d) {
            d.setDisabled(a)
        },
        b);
        b.callParent(arguments)
    }
},
function() {});
Ext.define("Ext.TitleBar", {
    extend: Ext.Container,
    xtype: "titlebar",
    isToolbar: true,
    config: {
        baseCls: Ext.baseCSSPrefix + "toolbar",
        cls: Ext.baseCSSPrefix + "navigation-bar",
        ui: "dark",
        title: null,
        titleAlign: "center",
        defaultType: "button",
        minHeight: null,
        layout: {
            type: "hbox"
        },
        items: [],
        maxButtonWidth: "40%"
    },
    platformConfig: [{
        theme: ["Blackberry", "Tizen"],
        titleAlign: "left"
    },
    {
        theme: ["Cupertino"],
        maxButtonWidth: "80%"
    }],
    hasCSSMinHeight: true,
    beforeInitialize: function() {
        this.applyItems = this.applyInitialItems
    },
    initialize: function() {
        delete this.applyItems;
        this.add(this.initialItems);
        delete this.initialItems;
        this.on({
            painted: "refreshTitlePosition",
            single: true
        })
    },
    applyInitialItems: function(a) {
        var d = this,
        b = d.getTitleAlign(),
        e = d.getDefaults() || {};
        d.initialItems = a;
        d.leftBox = d.add({
            xtype: "container",
            style: "position: relative",
            layout: {
                type: "hbox",
                align: "center"
            },
            listeners: {
                resize: "refreshTitlePosition",
                scope: d
            }
        });
        d.spacer = d.add({
            xtype: "component",
            style: "position: relative",
            flex: 1,
            listeners: {
                resize: "refreshTitlePosition",
                scope: d
            }
        });
        d.rightBox = d.add({
            xtype: "container",
            style: "position: relative",
            layout: {
                type: "hbox",
                align: "center"
            },
            listeners: {
                resize: "refreshTitlePosition",
                scope: d
            }
        });
        switch (b) {
        case "left":
            d.titleComponent = d.leftBox.add({
                xtype: "title",
                cls: Ext.baseCSSPrefix + "title-align-left",
                hidden: e.hidden
            });
            d.refreshTitlePosition = Ext.emptyFn;
            break;
        case "right":
            d.titleComponent = d.rightBox.add({
                xtype: "title",
                cls: Ext.baseCSSPrefix + "title-align-right",
                hidden: e.hidden
            });
            d.refreshTitlePosition = Ext.emptyFn;
            break;
        default:
            d.titleComponent = d.add({
                xtype: "title",
                hidden: e.hidden,
                centered: true
            });
            break
        }
        d.doAdd = d.doBoxAdd;
        d.remove = d.doBoxRemove;
        d.doInsert = d.doBoxInsert
    },
    doBoxAdd: function(a) {
        if (a.config.align == "right") {
            this.rightBox.add(a)
        } else {
            this.leftBox.add(a)
        }
    },
    doBoxRemove: function(b, a) {
        if (b.config.align == "right") {
            this.rightBox.remove(b, a)
        } else {
            this.leftBox.remove(b, a)
        }
    },
    doBoxInsert: function(a, b) {
        if (b.config.align == "right") {
            this.rightBox.insert(a, b)
        } else {
            this.leftBox.insert(a, b)
        }
    },
    calculateMaxButtonWidth: function() {
        var a = this.getMaxButtonWidth();
        if (Ext.isString(a)) {
            a = parseInt(a.replace("%", ""), 10)
        }
        a = Math.round((this.element.getWidth() / 100) * a);
        return a
    },
    refreshTitlePosition: function() {
        if (this.isDestroyed) {
            return
        }
        var h = this.titleComponent.renderElement;
        h.setWidth(null);
        h.setLeft(null);
        var b = this.leftBox,
        e = b.down("button"),
        a = b.getItems().getCount() == 1,
        j,
        p;
        if (e && a) {
            if (e.getWidth() == null) {
                e.renderElement.setWidth("auto")
            }
            j = b.renderElement.getWidth();
            p = this.calculateMaxButtonWidth();
            if (j > p) {
                e.renderElement.setWidth(p)
            }
        }
        var m = this.spacer.renderElement.getPageBox();
        if (Ext.browser.is.IE) {
            h.setWidth(m.width)
        }
        var n = h.getPageBox(),
        i = n.width - m.width,
        f = n.left,
        k = n.right,
        d,
        o,
        g;
        if (i > 0) {
            d = i / 2;
            f += d;
            k -= d;
            h.setWidth(m.width)
        }
        o = m.left - f;
        g = k - m.right;
        if (o > 0) {
            h.setLeft(o)
        } else {
            if (g > 0) {
                h.setLeft( - g)
            }
        }
        h.repaint()
    },
    updateTitle: function(a) {
        this.titleComponent.setTitle(a);
        if (this.isPainted()) {
            this.refreshTitlePosition()
        }
    }
});
Ext.define("Ext.app.Action", {
    config: {
        scope: null,
        application: null,
        controller: null,
        action: null,
        args: [],
        url: undefined,
        data: {},
        title: null,
        beforeFilters: [],
        currentFilterIndex: -1
    },
    constructor: function(a) {
        this.initConfig(a);
        this.getUrl()
    },
    applyBeforeFilters: function(a) {
        return a || []
    },
    execute: function() {
        this.resume()
    },
    resume: function() {
        var b = this.getCurrentFilterIndex() + 1,
        d = this.getBeforeFilters(),
        a = this.getController(),
        e = d[b];
        if (e) {
            this.setCurrentFilterIndex(b);
            e.call(a, this)
        } else {
            a[this.getAction()].apply(a, this.getArgs())
        }
    },
    applyUrl: function(a) {
        if (a === null || a === undefined) {
            a = this.urlEncode()
        }
        return a
    },
    applyController: function(a) {
        var d = this.getApplication(),
        b = d.getCurrentProfile();
        if (Ext.isString(a)) {
            a = d.getController(a, b ? b.getNamespace() : null)
        }
        return a
    },
    urlEncode: function() {
        var a = this.getController(),
        b;
        if (a instanceof Ext.app.Controller) {
            b = a.$className.split(".");
            a = b[b.length - 1]
        }
        return a + "/" + this.getAction()
    }
});
Ext.define("Ext.app.Controller", {
    mixins: {
        observable: Ext.mixin.Observable
    },
    config: {
        refs: {},
        routes: {},
        control: {},
        before: {},
        application: {},
        stores: [],
        models: [],
        views: []
    },
    constructor: function(a) {
        this.initConfig(a);
        this.mixins.observable.constructor.call(this, a)
    },
    init: Ext.emptyFn,
    launch: Ext.emptyFn,
    redirectTo: function(a) {
        return this.getApplication().redirectTo(a)
    },
    execute: function(b, a) {
        b.setBeforeFilters(this.getBefore()[b.getAction()]);
        b.execute()
    },
    applyBefore: function(f) {
        var e, a, d, b;
        for (a in f) {
            e = Ext.Array.from(f[a]);
            d = e.length;
            for (b = 0; b < d; b++) {
                e[b] = this[e[b]]
            }
            f[a] = e
        }
        return f
    },
    applyControl: function(a) {
        this.control(a, this);
        return a
    },
    applyRefs: function(a) {
        this.ref(a);
        return a
    },
    applyRoutes: function(a) {
        var g = this instanceof Ext.app.Application ? this: this.getApplication(),
        d = g.getRouter(),
        b,
        f,
        e;
        for (f in a) {
            b = a[f];
            e = {
                controller: this.$className
            };
            if (Ext.isString(b)) {
                e.action = b
            } else {
                Ext.apply(e, b)
            }
            d.connect(f, e)
        }
        return a
    },
    applyStores: function(a) {
        return this.getFullyQualified(a, "store")
    },
    applyModels: function(a) {
        return this.getFullyQualified(a, "model")
    },
    applyViews: function(a) {
        return this.getFullyQualified(a, "view")
    },
    getFullyQualified: function(b, f) {
        var g = b.length,
        a = this.getApplication().getName(),
        d,
        e;
        for (e = 0; e < g; e++) {
            d = b[e];
            if (Ext.isString(d) && (Ext.Loader.getPrefix(d) === "" || d === a)) {
                b[e] = a + "." + f + "." + d
            }
        }
        return b
    },
    control: function(a) {
        this.getApplication().control(a, this)
    },
    ref: function(b) {
        var e = this,
        g, d, a, f;
        for (g in b) {
            a = b[g];
            d = "get" + Ext.String.capitalize(g);
            if (!this[d]) {
                if (Ext.isString(b[g])) {
                    f = {
                        ref: g,
                        selector: a
                    }
                } else {
                    f = b[g]
                }
                this[d] = function(j, i) {
                    var h = [j, i];
                    return function() {
                        return e.getRef.apply(e, h.concat.apply(h, arguments))
                    }
                } (g, f)
            }
            this.references = this.references || [];
            this.references.push(g.toLowerCase())
        }
    },
    getRef: function(e, f, a) {
        this.refCache = this.refCache || {};
        f = f || {};
        a = a || {};
        Ext.apply(f, a);
        if (f.forceCreate) {
            return Ext.ComponentManager.create(f, "component")
        }
        var d = this,
        b = d.refCache[e];
        if (!b) {
            d.refCache[e] = b = Ext.ComponentQuery.query(f.selector)[0];
            if (!b && f.autoCreate) {
                d.refCache[e] = b = Ext.ComponentManager.create(f, "component")
            }
            if (b) {
                b.on("destroy",
                function() {
                    d.refCache[e] = null
                })
            }
        }
        return b
    },
    hasRef: function(a) {
        return this.references && this.references.indexOf(a.toLowerCase()) !== -1
    }
},
function() {});
Ext.define("Ext.app.History", {
    mixins: [Ext.mixin.Observable],
    config: {
        actions: [],
        updateUrl: true,
        token: ""
    },
    constructor: function(a) {
        if (Ext.feature.has.History) {
            window.addEventListener("hashchange", Ext.bind(this.detectStateChange, this))
        } else {
            setInterval(Ext.bind(this.detectStateChange, this), 100)
        }
        this.initConfig(a);
        if (a && Ext.isEmpty(a.token)) {
            this.setToken(window.location.hash.substr(1))
        }
    },
    add: function(d, a) {
        d = Ext.factory(d, Ext.app.Action);
        this.getActions().push(d);
        var b = d.getUrl();
        if (this.getUpdateUrl()) {
            this.setToken(b);
            window.location.hash = b
        }
        if (a !== true) {
            this.fireEvent("change", b)
        }
        this.setToken(b)
    },
    back: function() {
        var b = this.getActions(),
        a = b[b.length - 2];
        if (a) {
            b.pop();
            a.getController().getApplication().redirectTo(a.getUrl())
        } else {
            b[b.length - 1].getController().getApplication().redirectTo("")
        }
    },
    applyToken: function(a) {
        return a[0] == "#" ? a.substr(1) : a
    },
    detectStateChange: function() {
        var b = this.applyToken(window.location.hash),
        a = this.getToken();
        if (b != a) {
            this.onStateChange();
            this.setToken(b)
        }
    },
    onStateChange: function() {
        this.fireEvent("change", window.location.hash.substr(1))
    }
});
Ext.define("Ext.app.Profile", {
    mixins: {
        observable: Ext.mixin.Observable
    },
    config: {
        namespace: "auto",
        name: "auto",
        controllers: [],
        models: [],
        views: [],
        stores: [],
        application: null
    },
    constructor: function(a) {
        this.initConfig(a);
        this.mixins.observable.constructor.apply(this, arguments)
    },
    isActive: function() {
        return false
    },
    launch: Ext.emptyFn,
    applyNamespace: function(a) {
        if (a == "auto") {
            a = this.getName()
        }
        return a.toLowerCase()
    },
    applyName: function(a) {
        if (a == "auto") {
            var b = this.$className.split(".");
            a = b[b.length - 1]
        }
        return a
    },
    getDependencies: function() {
        var d = [],
        h = Ext.String.format,
        b = this.getApplication().getName(),
        e = this.getNamespace(),
        g = {
            model: this.getModels(),
            view: this.getViews(),
            controller: this.getControllers(),
            store: this.getStores()
        },
        f,
        i,
        a;
        for (f in g) {
            i = [];
            Ext.each(g[f],
            function(j) {
                if (Ext.isString(j)) {
                    if (Ext.isString(j) && (Ext.Loader.getPrefix(j) === "" || j === b)) {
                        j = b + "." + f + "." + e + "." + j
                    }
                    i.push(j);
                    d.push(j)
                }
            },
            this);
            g[f] = i
        }
        g.all = d;
        return g
    }
});
Ext.define("Ext.app.Route", {
    config: {
        conditions: {},
        url: null,
        controller: null,
        action: null,
        initialized: false
    },
    constructor: function(a) {
        this.initConfig(a)
    },
    recognize: function(b) {
        if (!this.getInitialized()) {
            this.initialize()
        }
        if (this.recognizes(b)) {
            var d = this.matchesFor(b),
            a = b.match(this.matcherRegex);
            a.shift();
            return Ext.applyIf(d, {
                controller: this.getController(),
                action: this.getAction(),
                url: b,
                args: a,
                historyUrl: b
            })
        }
    },
    initialize: function() {
        this.paramMatchingRegex = new RegExp(/:([0-9A-Za-z\_]*)/g);
        this.paramsInMatchString = this.getUrl().match(this.paramMatchingRegex) || [];
        this.matcherRegex = this.createMatcherRegex(this.getUrl());
        this.setInitialized(true)
    },
    recognizes: function(a) {
        return this.matcherRegex.test(a)
    },
    matchesFor: function(b) {
        var g = {},
        f = this.paramsInMatchString,
        a = b.match(this.matcherRegex),
        e = f.length,
        d;
        a.shift();
        for (d = 0; d < e; d++) {
            g[f[d].replace(":", "")] = a[d]
        }
        return g
    },
    argsFor: function(d) {
        var b = [],
        g = this.paramsInMatchString,
        a = d.match(this.matcherRegex),
        f = g.length,
        e;
        a.shift();
        for (e = 0; e < f; e++) {
            b.push(g[e].replace(":", ""));
            params[g[e].replace(":", "")] = a[e]
        }
        return params
    },
    urlFor: function(b) {
        var a = this.getUrl();
        for (var d in b) {
            a = a.replace(":" + d, b[d])
        }
        return a
    },
    createMatcherRegex: function(a) {
        var f = this.paramsInMatchString,
        e = f.length,
        b, d, g;
        for (b = 0; b < e; b++) {
            d = this.getConditions()[f[b]];
            g = Ext.util.Format.format("({0})", d || "[%a-zA-Z0-9\\-\\_\\s,]+");
            a = a.replace(new RegExp(f[b]), g)
        }
        return new RegExp("^" + a + "$")
    }
});
Ext.define("Ext.app.Router", {
    config: {
        routes: [],
        defaults: {
            action: "index"
        }
    },
    constructor: function(a) {
        this.initConfig(a)
    },
    connect: function(b, d) {
        d = Ext.apply({
            url: b
        },
        d || {},
        this.getDefaults());
        var a = Ext.create("Ext.app.Route", d);
        this.getRoutes().push(a);
        return a
    },
    recognize: function(d) {
        var b = this.getRoutes(),
        f = b.length,
        e,
        a;
        for (e = 0; e < f; e++) {
            a = b[e].recognize(d);
            if (a !== undefined) {
                return a
            }
        }
        return undefined
    },
    draw: function(a) {
        a.call(this, this)
    },
    clear: function() {
        this.setRoutes([])
    }
},
function() {});
Ext.define("Ext.app.Application", {
    extend: Ext.app.Controller,
    config: {
        profiles: [],
        controllers: [],
        history: {},
        name: null,
        appFolder: "app",
        router: {},
        controllerInstances: [],
        profileInstances: [],
        currentProfile: null,
        launch: Ext.emptyFn,
        enableLoader: true,
        requires: [],
        themeVariationPrefix: Ext.baseCSSPrefix + "theme-variation-",
        themeVariationTransitionCls: null,
        themeVariation: null
    },
    constructor: function(a) {
        a = a || {};
        Ext.applyIf(a, {
            application: this
        });
        this.initConfig(a);
        for (var b in a) {
            this[b] = a[b]
        }
        Ext.require(this.getRequires(),
        function() {
            if (this.getEnableLoader() !== false) {
                Ext.require(this.getProfiles(), this.onProfilesLoaded, this)
            }
        },
        this)
    },
    dispatch: function(f, e) {
        f = f || {};
        Ext.applyIf(f, {
            application: this
        });
        f = Ext.factory(f, Ext.app.Action);
        if (f) {
            var d = this.getCurrentProfile(),
            b = d ? d.getNamespace() : undefined,
            a = this.getController(f.getController(), b);
            if (a) {
                if (e !== false) {
                    this.getHistory().add(f, true)
                }
                a.execute(f)
            }
        }
    },
    redirectTo: function(d) {
        if (Ext.data && Ext.data.Model && d instanceof Ext.data.Model) {
            var a = d;
            d = a.toUrl()
        }
        var b = this.getRouter().recognize(d);
        if (b) {
            b.url = d;
            if (a) {
                b.data = {};
                b.data.record = a
            }
            return this.dispatch(b)
        }
    },
    control: function(i, e) {
        e = e || this;
        var j = this.getEventDispatcher(),
        h = (e) ? e.getRefs() : {},
        d,
        f,
        b,
        g,
        a;
        for (d in i) {
            if (i.hasOwnProperty(d)) {
                g = i[d];
                a = h[d];
                if (a) {
                    d = a.selector || a
                }
                for (f in g) {
                    b = g[f];
                    if (Ext.isString(b)) {
                        b = e[b]
                    }
                    j.addListener("component", d, f, b, e)
                }
            }
        }
    },
    getController: function(b, e) {
        var g = this.getControllerInstances(),
        a = this.getName(),
        f = Ext.String.format,
        d;
        if (b instanceof Ext.app.Controller) {
            return b
        }
        if (g[b]) {
            return g[b]
        } else {
            d = f("{0}.controller.{1}", a, b);
            e = f("{0}.controller.{1}.{2}", a, e, b);
            return g[e] || g[d]
        }
    },
    onProfilesLoaded: function() {
        var b = this.getProfiles(),
        f = b.length,
        h = [],
        e = this.gatherDependencies(),
        g,
        d,
        a;
        for (d = 0; d < f; d++) {
            h[d] = Ext.create(b[d], {
                application: this
            });
            a = h[d].getDependencies();
            e = e.concat(a.all);
            if (h[d].isActive() && !g) {
                g = h[d];
                this.setCurrentProfile(g);
                this.setControllers(this.getControllers().concat(a.controller));
                this.setModels(this.getModels().concat(a.model));
                this.setViews(this.getViews().concat(a.view));
                this.setStores(this.getStores().concat(a.store))
            }
        }
        this.setProfileInstances(h);
        Ext.require(e, this.loadControllerDependencies, this)
    },
    loadControllerDependencies: function() {
        this.instantiateControllers();
        var h = this.getControllerInstances(),
        g = [],
        d = [],
        f,
        b,
        a,
        e;
        for (e in h) {
            b = h[e];
            a = b.getStores();
            d = d.concat(a);
            g = g.concat(b.getModels().concat(b.getViews()).concat(a))
        }
        this.setStores(this.getStores().concat(d));
        Ext.require(g, this.onDependenciesLoaded, this)
    },
    onDependenciesLoaded: function() {
        var d = this,
        b = this.getCurrentProfile(),
        f = this.getLaunch(),
        e,
        a;
        this.instantiateStores();
        e = this.getControllerInstances();
        for (a in e) {
            e[a].init(this)
        }
        if (b) {
            b.launch()
        }
        f.call(d);
        for (a in e) {
            e[a].launch(this)
        }
        d.redirectTo(window.location.hash.substr(1))
    },
    gatherDependencies: function() {
        var a = this.getModels().concat(this.getViews()).concat(this.getControllers());
        Ext.each(this.getStores(),
        function(b) {
            if (Ext.isString(b)) {
                a.push(b)
            }
        },
        this);
        return a
    },
    instantiateStores: function() {
        var b = this.getStores(),
        g = b.length,
        d,
        a,
        e,
        h,
        f;
        for (f = 0; f < g; f++) {
            d = b[f];
            if (Ext.data && Ext.data.Store && !(d instanceof Ext.data.Store)) {
                if (Ext.isString(d)) {
                    e = d;
                    a = Ext.ClassManager.classes[d];
                    d = {
                        xclass: d
                    };
                    if (a.prototype.defaultConfig.storeId === undefined) {
                        h = e.split(".");
                        d.id = h[h.length - 1]
                    }
                }
                b[f] = Ext.factory(d, Ext.data.Store)
            }
        }
        this.setStores(b)
    },
    instantiateControllers: function() {
        var f = this.getControllers(),
        e = {},
        d = f.length,
        a,
        b;
        for (b = 0; b < d; b++) {
            a = f[b];
            e[a] = Ext.create(a, {
                application: this
            })
        }
        return this.setControllerInstances(e)
    },
    applyControllers: function(a) {
        return this.getFullyQualified(a, "controller")
    },
    applyProfiles: function(a) {
        return this.getFullyQualified(a, "profile")
    },
    applyName: function(a) {
        var b;
        if (a && a.match(/ /g)) {
            b = a;
            a = a.replace(/ /g, "")
        }
        return a
    },
    updateName: function(a) {
        Ext.ClassManager.setNamespace(a + ".app", this);
        if (!Ext.Loader.config.paths[a]) {
            Ext.Loader.setPath(a, this.getAppFolder())
        }
    },
    applyRouter: function(a) {
        return Ext.factory(a, Ext.app.Router, this.getRouter())
    },
    applyHistory: function(a) {
        var b = Ext.factory(a, Ext.app.History, this.getHistory());
        b.on("change", this.onHistoryChange, this);
        return b
    },
    onHistoryChange: function(a) {
        this.dispatch(this.getRouter().recognize(a), false)
    },
    updateThemeVariation: function(j, n) {
        var g = Ext.getBody().getParent(),
        e = this.getThemeVariationPrefix() || "",
        m = this.getThemeVariationTransitionCls();
        if (Ext.isFunction(j)) {
            j = j.call(this)
        }
        if (!Ext.isString(j)) {
            Ext.Error.raise("Theme variation must be a String.'")
        }
        if (m) {
            var h = "",
            d = 0,
            o = document.styleSheets[0].cssRules,
            f,
            k,
            a,
            b;
            g.addCls(m);
            for (f in o) {
                k = o[f];
                if (k.selectorText && k.selectorText.indexOf("." + m) >= 1) {
                    h += k.cssText
                }
            }
            a = h.match(/[0-9]+s/g);
            for (f in a) {
                b = parseInt(a[f]);
                if (b > d) {
                    d = b
                }
            }
            if (this.$themeVariationChangeTimeout) {
                clearTimeout(this.$themeVariationChangeTimeout);
                this.$themeVariationChangeTimeout = null
            }
            this.$themeVariationChangeTimeout = Ext.defer(function() {
                g.removeCls(m)
            },
            b * 1000)
        }
        g.removeCls(e + n);
        g.addCls(e + j)
    }
},
function() {}); (function() {
    if (!Ext.global.Float32Array) {
        var a = function(e) {
            if (typeof e === "number") {
                this.length = e
            } else {
                if ("length" in e) {
                    this.length = e.length;
                    for (var d = 0,
                    b = e.length; d < b; d++) {
                        this[d] = +e[d]
                    }
                }
            }
        };
        a.prototype = [];
        Ext.global.Float32Array = a
    }
})();
Ext.define("Ext.draw.Draw", {
    singleton: true,
    radian: Math.PI / 180,
    pi2: Math.PI * 2,
    reflectFn: function(b) {
        return b
    },
    rad: function(a) {
        return a % 360 * Math.PI / 180
    },
    degrees: function(a) {
        return a * 180 / Math.PI % 360
    },
    isBBoxIntersect: function(b, a, d) {
        d = d || 0;
        return (Math.max(b.x, a.x) - d > Math.min(b.x + b.width, a.x + a.width)) || (Math.max(b.y, a.y) - d > Math.min(b.y + b.height, a.y + a.height))
    },
    spline: function(o) {
        var f, e, m = o.length,
        b, k, n, g, a = 0,
        h = new Float32Array(o.length),
        p = new Float32Array(o.length * 3 - 2);
        h[0] = 0;
        h[m - 1] = 0;
        for (f = 1; f < m - 1; f++) {
            h[f] = (o[f + 1] + o[f - 1] - 2 * o[f]) - h[f - 1];
            a = 1 / (4 - a);
            h[f] *= a
        }
        for (f = m - 2; f > 0; f--) {
            a = 3.732050807568877 + 48.248711305964385 / ( - 13.928203230275537 + Math.pow(0.07179676972449123, f));
            h[f] -= h[f + 1] * a
        }
        g = o[0];
        b = g - h[0];
        for (f = 0, e = 0; f < m - 1; e += 3) {
            n = g;
            k = b;
            f++;
            g = o[f];
            b = g - h[f];
            p[e] = n;
            p[e + 1] = (b + 2 * k) / 3;
            p[e + 2] = (b * 2 + k) / 3
        }
        p[e] = g;
        return p
    },
    getAnchors: function(f, e, j, i, v, u, q) {
        q = q || 4;
        var p = Math.PI,
        r = p / 2,
        m = Math.abs,
        a = Math.sin,
        b = Math.cos,
        g = Math.atan,
        t, s, h, k, o, n, z, y, d;
        t = (j - f) / q;
        s = (v - j) / q;
        if ((i >= e && i >= u) || (i <= e && i <= u)) {
            h = k = r
        } else {
            h = g((j - f) / m(i - e));
            if (e < i) {
                h = p - h
            }
            k = g((v - j) / m(i - u));
            if (u < i) {
                k = p - k
            }
        }
        d = r - ((h + k) % (p * 2)) / 2;
        if (d > r) {
            d -= p
        }
        h += d;
        k += d;
        o = j - t * a(h);
        n = i + t * b(h);
        z = j + s * a(k);
        y = i + s * b(k);
        if ((i > e && n < e) || (i < e && n > e)) {
            o += m(e - n) * (o - j) / (n - i);
            n = e
        }
        if ((i > u && y < u) || (i < u && y > u)) {
            z -= m(u - y) * (z - j) / (y - i);
            y = u
        }
        return {
            x1: o,
            y1: n,
            x2: z,
            y2: y
        }
    },
    smooth: function(n, k, q) {
        var m = n.length,
        j, h, d, b, s, r, p, o, g = [],
        f = [],
        e,
        a;
        for (e = 0; e < m - 1; e++) {
            j = n[e];
            h = k[e];
            if (e === 0) {
                p = j;
                o = h;
                g.push(p);
                f.push(o);
                if (m === 1) {
                    break
                }
            }
            d = n[e + 1];
            b = k[e + 1];
            s = n[e + 2];
            r = k[e + 2];
            if (isNaN(s) || isNaN(r)) {
                g.push(p, d, d);
                f.push(o, b, b);
                break
            }
            a = this.getAnchors(j, h, d, b, s, r, q);
            g.push(p, a.x1, d);
            f.push(o, a.y1, b);
            p = a.x2;
            o = a.y2
        }
        return {
            smoothX: g,
            smoothY: f
        }
    },
    updateIOS: Ext.os.is.iOS ?
    function() {
        Ext.getBody().createChild({
            id: "frame-workaround",
            style: "position: absolute; top: 0px; bottom: 0px; left: 0px; right: 0px; background: rgba(0,0,0,0.001); z-index: 100000"
        });
        Ext.draw.Animator.schedule(function() {
            Ext.get("frame-workaround").destroy()
        })
    }: Ext.emptyFn
});
Ext.define("Ext.draw.LimitedCache", {
    config: {
        limit: 40,
        feeder: function() {
            return 0
        },
        scope: null
    },
    cache: null,
    constructor: function(a) {
        this.cache = {};
        this.cache.list = [];
        this.cache.tail = 0;
        this.initConfig(a)
    },
    get: function(f) {
        var d = this.cache,
        b = this.getLimit(),
        a = this.getFeeder(),
        e = this.getScope() || this;
        if (d[f]) {
            return d[f].value
        }
        if (d.list[d.tail]) {
            delete d[d.list[d.tail].cacheId]
        }
        d[f] = d.list[d.tail] = {
            value: a.apply(e, Array.prototype.slice.call(arguments, 1)),
            cacheId: f
        };
        d.tail++;
        if (d.tail === b) {
            d.tail = 0
        }
        return d[f].value
    },
    clear: function() {
        this.cache = {};
        this.cache.list = [];
        this.cache.tail = 0
    }
});
Ext.define("Ext.draw.gradient.Gradient", {
    mixins: {
        identifiable: Ext.mixin.Identifiable
    },
    identifiablePrefix: "ext-gradient-",
    isGradient: true,
    statics: {
        gradientCache: null
    },
    config: {
        stops: []
    },
    applyStops: function(g) {
        var f = [],
        e = g.length,
        d,
        b,
        a;
        for (d = 0; d < e; d++) {
            b = g[d];
            a = Ext.draw.Color.fly(b.color || "none");
            f.push({
                offset: Math.min(1, Math.max(0, "offset" in b ? b.offset: b.position || 0)),
                color: a.toString()
            })
        }
        f.sort(function(i, h) {
            return i.offset - h.offset
        });
        return f
    },
    onClassExtended: function(a, b) {
        if (!b.alias && b.type) {
            b.alias = "gradient." + b.type
        }
    },
    constructor: function(a) {
        a = a || {};
        this.gradientCache = new Ext.draw.LimitedCache({
            feeder: function(d, b, e) {
                return d.generateGradient(b, e)
            },
            scope: this
        });
        this.initConfig(a);
        this.id = a.id;
        this.getId()
    },
    generateGradient: Ext.emptyFn,
    getGradient: function(a, b) {
        return this.gradientCache.get(this.id + "," + b.x + "," + b.y + "," + b.width + "," + b.height, this, a, b)
    },
    clearCache: function() {
        this.gradientCache.clear()
    }
}); (function() {
    Ext.define("Ext.draw.Color", {
        statics: {
            colorToHexRe: /(.*?)rgb\((\d+),\s*(\d+),\s*(\d+)\)/,
            rgbToHexRe: /\s*rgb\((\d+),\s*(\d+),\s*(\d+)\)/,
            rgbaToHexRe: /\s*rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\.\d]+)\)/,
            hexRe: /\s*#([0-9a-fA-F][0-9a-fA-F]?)([0-9a-fA-F][0-9a-fA-F]?)([0-9a-fA-F][0-9a-fA-F]?)\s*/
        },
        isColor: true,
        lightnessFactor: 0.2,
        constructor: function(e, b, a, d) {
            this.setRGB(e, b, a, d)
        },
        setRGB: function(f, d, a, e) {
            var b = this;
            b.r = Math.min(255, Math.max(0, f));
            b.g = Math.min(255, Math.max(0, d));
            b.b = Math.min(255, Math.max(0, a));
            if (e === undefined) {
                b.a = 1
            } else {
                b.a = Math.min(1, Math.max(0, e))
            }
        },
        getGrayscale: function() {
            return this.r * 0.3 + this.g * 0.59 + this.b * 0.11
        },
        getHSL: function(j) {
            var k = this,
            a = k.r / 255,
            i = k.g / 255,
            m = k.b / 255,
            n = Math.max(a, i, m),
            e = Math.min(a, i, m),
            o = n - e,
            f,
            p = 0,
            d = 0.5 * (n + e);
            if (e !== n) {
                p = (d < 0.5) ? o / (n + e) : o / (2 - n - e);
                if (a === n) {
                    f = 60 * (i - m) / o
                } else {
                    if (i === n) {
                        f = 120 + 60 * (m - a) / o
                    } else {
                        f = 240 + 60 * (a - i) / o
                    }
                }
                if (f < 0) {
                    f += 360
                }
                if (f >= 360) {
                    f -= 360
                }
            }
            if (j) {
                j[0] = f;
                j[1] = p;
                j[2] = d
            } else {
                j = [f, p, d]
            }
            return j
        },
        setHSL: function(g, f, e) {
            var j, d, b, a = Math.abs,
            i = Math.floor;
            g = (g % 360 + 360) % 360;
            f = f > 1 ? 1 : f < 0 ? 0 : f;
            e = e > 1 ? 1 : e < 0 ? 0 : e;
            if (f === 0 || g === null) {
                e *= 255;
                this.setRGB(e, e, e)
            } else {
                g /= 60;
                j = f * (1 - a(2 * e - 1));
                d = j * (1 - a(g - 2 * i(g / 2) - 1));
                b = e - j / 2;
                b *= 255;
                j *= 255;
                d *= 255;
                switch (i(g)) {
                case 0:
                    this.setRGB(j + b, d + b, b);
                    break;
                case 1:
                    this.setRGB(d + b, j + b, b);
                    break;
                case 2:
                    this.setRGB(b, j + b, d + b);
                    break;
                case 3:
                    this.setRGB(b, d + b, j + b);
                    break;
                case 4:
                    this.setRGB(d + b, b, j + b);
                    break;
                case 5:
                    this.setRGB(j + b, b, d + b);
                    break
                }
            }
            return this
        },
        createLighter: function(b) {
            var a = this.getHSL();
            b = b || this.lightnessFactor;
            a[2] = a[2] + b;
            if (a[2] > 1) {
                a[2] = 1
            } else {
                if (a[2] < 0) {
                    a[2] = 0
                }
            }
            return Ext.draw.Color.fromHSL(a[0], a[1], a[2])
        },
        createDarker: function(a) {
            a = a || this.lightnessFactor;
            return this.createLighter( - a)
        },
        toString: function() {
            if (this.a === 1) {
                var h = this,
                d = Math.round,
                f = d(h.r).toString(16),
                e = d(h.g).toString(16),
                a = d(h.b).toString(16);
                f = (f.length === 1) ? "0" + f: f;
                e = (e.length === 1) ? "0" + e: e;
                a = (a.length === 1) ? "0" + a: a;
                return ["#", f, e, a].join("")
            } else {
                return "rgba(" + [Math.round(this.r), Math.round(this.g), Math.round(this.b), this.a.toFixed(15)].join(",") + ")"
            }
        },
        toHex: function(b) {
            if (Ext.isArray(b)) {
                b = b[0]
            }
            if (!Ext.isString(b)) {
                return ""
            }
            if (b.substr(0, 1) === "#") {
                return b
            }
            var f = Ext.draw.Color.colorToHexRe.exec(b);
            if (Ext.isArray(f)) {
                var g = parseInt(f[2], 10),
                e = parseInt(f[3], 10),
                a = parseInt(f[4], 10),
                d = a | (e << 8) | (g << 16);
                return f[1] + "#" + ("000000" + d.toString(16)).slice( - 6)
            } else {
                return ""
            }
        },
        setFromString: function(k) {
            var f, i, h, d, e = 1,
            j = parseInt;
            if (k === "none") {
                this.r = this.g = this.b = this.a = 0;
                return this
            }
            if ((k.length === 4 || k.length === 7) && k.substr(0, 1) === "#") {
                f = k.match(Ext.draw.Color.hexRe);
                if (f) {
                    i = j(f[1], 16) >> 0;
                    h = j(f[2], 16) >> 0;
                    d = j(f[3], 16) >> 0;
                    if (k.length === 4) {
                        i += (i * 16);
                        h += (h * 16);
                        d += (d * 16)
                    }
                }
            } else {
                if ((f = k.match(Ext.draw.Color.rgbToHexRe))) {
                    i = +f[1];
                    h = +f[2];
                    d = +f[3]
                } else {
                    if ((f = k.match(Ext.draw.Color.rgbaToHexRe))) {
                        i = +f[1];
                        h = +f[2];
                        d = +f[3];
                        e = +f[4]
                    } else {
                        if (Ext.draw.Color.ColorList.hasOwnProperty(k.toLowerCase())) {
                            return this.setFromString(Ext.draw.Color.ColorList[k.toLowerCase()])
                        }
                    }
                }
            }
            if (typeof i === "undefined") {
                return this
            }
            this.r = i;
            this.g = h;
            this.b = d;
            this.a = e;
            return this
        }
    },
    function() {
        var a = new this();
        this.addStatics({
            fly: function(h, f, d, e) {
                switch (arguments.length) {
                case 1:
                    a.setFromString(h);
                    break;
                case 3:
                case 4:
                    a.setRGB(h, f, d, e);
                    break;
                default:
                    return null
                }
                return a
            },
            ColorList: {
                aliceblue: "#f0f8ff",
                antiquewhite: "#faebd7",
                aqua: "#00ffff",
                aquamarine: "#7fffd4",
                azure: "#f0ffff",
                beige: "#f5f5dc",
                bisque: "#ffe4c4",
                black: "#000000",
                blanchedalmond: "#ffebcd",
                blue: "#0000ff",
                blueviolet: "#8a2be2",
                brown: "#a52a2a",
                burlywood: "#deb887",
                cadetblue: "#5f9ea0",
                chartreuse: "#7fff00",
                chocolate: "#d2691e",
                coral: "#ff7f50",
                cornflowerblue: "#6495ed",
                cornsilk: "#fff8dc",
                crimson: "#dc143c",
                cyan: "#00ffff",
                darkblue: "#00008b",
                darkcyan: "#008b8b",
                darkgoldenrod: "#b8860b",
                darkgray: "#a9a9a9",
                darkgreen: "#006400",
                darkkhaki: "#bdb76b",
                darkmagenta: "#8b008b",
                darkolivegreen: "#556b2f",
                darkorange: "#ff8c00",
                darkorchid: "#9932cc",
                darkred: "#8b0000",
                darksalmon: "#e9967a",
                darkseagreen: "#8fbc8f",
                darkslateblue: "#483d8b",
                darkslategray: "#2f4f4f",
                darkturquoise: "#00ced1",
                darkviolet: "#9400d3",
                deeppink: "#ff1493",
                deepskyblue: "#00bfff",
                dimgray: "#696969",
                dodgerblue: "#1e90ff",
                firebrick: "#b22222",
                floralwhite: "#fffaf0",
                forestgreen: "#228b22",
                fuchsia: "#ff00ff",
                gainsboro: "#dcdcdc",
                ghostwhite: "#f8f8ff",
                gold: "#ffd700",
                goldenrod: "#daa520",
                gray: "#808080",
                green: "#008000",
                greenyellow: "#adff2f",
                honeydew: "#f0fff0",
                hotpink: "#ff69b4",
                "indianred ": "#cd5c5c",
                "indigo ": "#4b0082",
                ivory: "#fffff0",
                khaki: "#f0e68c",
                lavender: "#e6e6fa",
                lavenderblush: "#fff0f5",
                lawngreen: "#7cfc00",
                lemonchiffon: "#fffacd",
                lightblue: "#add8e6",
                lightcoral: "#f08080",
                lightcyan: "#e0ffff",
                lightgoldenrodyellow: "#fafad2",
                lightgray: "#d3d3d3",
                lightgrey: "#d3d3d3",
                lightgreen: "#90ee90",
                lightpink: "#ffb6c1",
                lightsalmon: "#ffa07a",
                lightseagreen: "#20b2aa",
                lightskyblue: "#87cefa",
                lightslategray: "#778899",
                lightsteelblue: "#b0c4de",
                lightyellow: "#ffffe0",
                lime: "#00ff00",
                limegreen: "#32cd32",
                linen: "#faf0e6",
                magenta: "#ff00ff",
                maroon: "#800000",
                mediumaquamarine: "#66cdaa",
                mediumblue: "#0000cd",
                mediumorchid: "#ba55d3",
                mediumpurple: "#9370d8",
                mediumseagreen: "#3cb371",
                mediumslateblue: "#7b68ee",
                mediumspringgreen: "#00fa9a",
                mediumturquoise: "#48d1cc",
                mediumvioletred: "#c71585",
                midnightblue: "#191970",
                mintcream: "#f5fffa",
                mistyrose: "#ffe4e1",
                moccasin: "#ffe4b5",
                navajowhite: "#ffdead",
                navy: "#000080",
                oldlace: "#fdf5e6",
                olive: "#808000",
                olivedrab: "#6b8e23",
                orange: "#ffa500",
                orangered: "#ff4500",
                orchid: "#da70d6",
                palegoldenrod: "#eee8aa",
                palegreen: "#98fb98",
                paleturquoise: "#afeeee",
                palevioletred: "#d87093",
                papayawhip: "#ffefd5",
                peachpuff: "#ffdab9",
                peru: "#cd853f",
                pink: "#ffc0cb",
                plum: "#dda0dd",
                powderblue: "#b0e0e6",
                purple: "#800080",
                red: "#ff0000",
                rosybrown: "#bc8f8f",
                royalblue: "#4169e1",
                saddlebrown: "#8b4513",
                salmon: "#fa8072",
                sandybrown: "#f4a460",
                seagreen: "#2e8b57",
                seashell: "#fff5ee",
                sienna: "#a0522d",
                silver: "#c0c0c0",
                skyblue: "#87ceeb",
                slateblue: "#6a5acd",
                slategray: "#708090",
                snow: "#fffafa",
                springgreen: "#00ff7f",
                steelblue: "#4682b4",
                tan: "#d2b48c",
                teal: "#008080",
                thistle: "#d8bfd8",
                tomato: "#ff6347",
                turquoise: "#40e0d0",
                violet: "#ee82ee",
                wheat: "#f5deb3",
                white: "#ffffff",
                whitesmoke: "#f5f5f5",
                yellow: "#ffff00",
                yellowgreen: "#9acd32"
            },
            fromHSL: function(e, d, b) {
                return (new this(0, 0, 0, 0)).setHSL(e, d, b)
            },
            fromString: function(b) {
                return (new this(0, 0, 0, 0)).setFromString(b)
            },
            create: function(b) {
                if (b instanceof this) {
                    return b
                } else {
                    if (Ext.isArray(b)) {
                        return new Ext.draw.Color(b[0], b[1], b[2], b[3])
                    } else {
                        if (Ext.isString(b)) {
                            return Ext.draw.Color.fromString(b)
                        } else {
                            if (arguments.length > 2) {
                                return new Ext.draw.Color(arguments[0], arguments[1], arguments[2], arguments[3])
                            } else {
                                return new Ext.draw.Color(0, 0, 0, 0)
                            }
                        }
                    }
                }
            }
        })
    })
})();
Ext.define("Ext.draw.sprite.GradientDefinition", {
    singleton: true,
    urlStringRe: /^url\(#([\w\-]+)\)$/,
    gradients: {},
    add: function(a) {
        var b = this.gradients,
        d, f, e;
        for (d = 0, f = a.length; d < f; d++) {
            e = a[d];
            if (Ext.isString(e.id)) {
                b[e.id] = e
            }
        }
    },
    get: function(e) {
        var a = this.gradients,
        b = e.match(this.urlStringRe),
        d;
        if (b && b[1] && (d = a[b[1]])) {
            return d || e
        }
        return e
    }
});
Ext.define("Ext.draw.sprite.AttributeParser", {
    singleton: true,
    attributeRe: /^url\(#([a-zA-Z\-]+)\)$/,
    "default": function(a) {
        return a
    },
    string: function(a) {
        return String(a)
    },
    number: function(a) {
        if (!isNaN(a)) {
            return a
        }
    },
    angle: function(a) {
        if (!isNaN(a)) {
            a %= Math.PI * 2;
            if (a < -Math.PI) {
                a += Math.PI * 2
            }
            if (a > Math.PI) {
                a -= Math.PI * 2
            }
            return a
        }
    },
    data: function(a) {
        if (Ext.isArray(a)) {
            return a.slice()
        } else {
            if (a instanceof Float32Array) {
                return new Float32Array(a)
            }
        }
    },
    bool: function(a) {
        return !! a
    },
    color: function(a) {
        if (a instanceof Ext.draw.Color) {
            return a.toString()
        } else {
            if (a instanceof Ext.draw.gradient.Gradient) {
                return a
            } else {
                if (!a) {
                    return "none"
                } else {
                    if (Ext.isString(a)) {
                        a = Ext.draw.sprite.GradientDefinition.get(a);
                        if (Ext.isString(a)) {
                            return a
                        }
                    }
                }
            }
        }
        if (a.type === "linear") {
            return Ext.create("Ext.draw.gradient.Linear", a)
        } else {
            if (a.type === "radial") {
                return Ext.create("Ext.draw.gradient.Radial", a)
            } else {
                if (a.type === "pattern") {
                    return Ext.create("Ext.draw.gradient.Pattern", a)
                }
            }
        }
    },
    limited: function(a, b) {
        return (function(d) {
            return isNaN(d) ? undefined: Math.min(Math.max( + d, a), b)
        })
    },
    limited01: function(a) {
        return isNaN(a) ? undefined: Math.min(Math.max( + a, 0), 1)
    },
    enums: function() {
        var e = {},
        a = Array.prototype.slice.call(arguments, 0),
        b,
        d;
        for (b = 0, d = a.length; b < d; b++) {
            e[a[b]] = true
        }
        return (function(f) {
            return f in e ? f: undefined
        })
    }
}); (function() {
    function a(e, d, b) {
        return e + (d - e) * b
    }
    Ext.define("Ext.draw.sprite.AnimationParser", {
        singleton: true,
        attributeRe: /^url\(#([a-zA-Z\-]+)\)$/,
        color: {
            parseInitial: function(d, b) {
                if (Ext.isString(d)) {
                    d = Ext.draw.Color.create(d)
                }
                if (Ext.isString(b)) {
                    b = Ext.draw.Color.create(b)
                }
                if ((d instanceof Ext.draw.Color) && (b instanceof Ext.draw.Color)) {
                    return [[d.r, d.g, d.b, d.a], [b.r, b.g, b.b, b.a]]
                } else {
                    return [d || b, b || d]
                }
            },
            compute: function(e, d, b) {
                if (!Ext.isArray(e) || !Ext.isArray(d)) {
                    return d || e
                } else {
                    return [a(e[0], d[0], b), a(e[1], d[1], b), a(e[2], d[2], b), a(e[3], d[3], b)]
                }
            },
            serve: function(d) {
                var b = Ext.draw.Color.fly(d[0], d[1], d[2], d[3]);
                return b.toString()
            }
        },
        number: {
            parse: function(b) {
                return b === null ? null: +b
            },
            compute: function(e, d, b) {
                if (!Ext.isNumber(e) || !Ext.isNumber(d)) {
                    return d || e
                } else {
                    return a(e, d, b)
                }
            }
        },
        angle: {
            parseInitial: function(d, b) {
                if (b - d > Math.PI) {
                    b -= Math.PI * 2
                } else {
                    if (b - d < -Math.PI) {
                        b += Math.PI * 2
                    }
                }
                return [d, b]
            },
            compute: function(e, d, b) {
                if (!Ext.isNumber(e) || !Ext.isNumber(d)) {
                    return d || e
                } else {
                    return a(e, d, b)
                }
            }
        },
        path: {
            parseInitial: function(o, p) {
                var d = o.toStripes(),
                q = p.toStripes(),
                f,
                e,
                m = d.length,
                r = q.length,
                k,
                g,
                b,
                h = q[r - 1],
                n = [h[h.length - 2], h[h.length - 1]];
                for (f = m; f < r; f++) {
                    d.push(d[m - 1].slice(0))
                }
                for (f = r; f < m; f++) {
                    q.push(n.slice(0))
                }
                b = d.length;
                q.path = p;
                q.temp = new Ext.draw.Path();
                for (f = 0; f < b; f++) {
                    k = d[f];
                    g = q[f];
                    m = k.length;
                    r = g.length;
                    q.temp.types.push("M");
                    for (e = r; e < m; e += 6) {
                        g.push(n[0], n[1], n[0], n[1], n[0], n[1])
                    }
                    h = q[q.length - 1];
                    n = [h[h.length - 2], h[h.length - 1]];
                    for (e = m; e < r; e += 6) {
                        k.push(n[0], n[1], n[0], n[1], n[0], n[1])
                    }
                    for (f = 0; f < g.length; f++) {
                        g[f] -= k[f]
                    }
                    for (f = 2; f < g.length; f += 6) {
                        q.temp.types.push("C")
                    }
                }
                return [d, q]
            },
            compute: function(d, n, o) {
                if (o >= 1) {
                    return n.path
                }
                var f = 0,
                g = d.length,
                e = 0,
                b, m, k, p = n.temp.coords,
                h = 0;
                for (; f < g; f++) {
                    m = d[f];
                    k = n[f];
                    b = m.length;
                    for (e = 0; e < b; e++) {
                        p[h++] = k[e] * o + m[e]
                    }
                }
                return n.temp
            }
        },
        data: {
            compute: function(j, k, m, h) {
                var o = j.length - 1,
                b = k.length - 1,
                g = Math.max(o, b),
                e,
                n,
                d;
                if (!h || h === j) {
                    h = []
                }
                h.length = g + 1;
                for (d = 0; d <= g; d++) {
                    e = j[Math.min(d, o)];
                    n = k[Math.min(d, b)];
                    if (isNaN(e)) {
                        h[d] = n
                    } else {
                        h[d] = (n - e) * m + e
                    }
                }
                return h
            }
        },
        text: {
            compute: function(e, d, b) {
                return e.substr(0, Math.round(e.length * (1 - b))) + d.substr(Math.round(d.length * (1 - b)))
            }
        },
        limited: "number",
        limited01: "number"
    })
})();
Ext.define("Ext.draw.sprite.AttributeDefinition", {
    config: {
        defaults: {},
        aliases: {},
        animationProcessors: {},
        processors: {},
        dirtyTriggers: {},
        updaters: {}
    },
    inheritableStatics: {
        processorRe: /^(\w+)\(([\w\-,]*)\)$/
    },
    constructor: function(a) {
        var b = this;
        b.initConfig(a)
    },
    applyDefaults: function(b, a) {
        a = Ext.apply(a || {},
        this.normalize(b));
        return a
    },
    applyAliases: function(b, a) {
        return Ext.apply(a || {},
        b)
    },
    applyProcessors: function(e, j) {
        this.getAnimationProcessors();
        var a, k = j || {},
        h = Ext.draw.sprite.AttributeParser,
        i = this.self.processorRe,
        g = {},
        d, b, f;
        for (a in e) {
            f = e[a];
            if (!Ext.isFunction(f)) {
                if (Ext.isString(f)) {
                    b = f.match(i);
                    if (b) {
                        f = h[b[1]].apply(h, b[2].split(","))
                    } else {
                        g[a] = f;
                        d = true;
                        f = h[f]
                    }
                } else {
                    continue
                }
            }
            k[a] = f
        }
        if (d) {
            this.setAnimationProcessors(g)
        }
        return k
    },
    applyAnimationProcessors: function(d, a) {
        var f = Ext.draw.sprite.AnimationParser,
        e;
        if (!a) {
            a = {}
        }
        for (var b in d) {
            e = d[b];
            if (e === "none") {
                a[b] = null
            } else {
                if (Ext.isString(e) && !(b in a)) {
                    if (e in f) {
                        while (Ext.isString(f[e])) {
                            e = f[e]
                        }
                        a[b] = f[e]
                    }
                } else {
                    if (Ext.isObject(e)) {
                        a[b] = e
                    }
                }
            }
        }
        return a
    },
    applyDirtyTriggers: function(d, b) {
        if (!b) {
            b = {}
        }
        for (var a in d) {
            b[a] = d[a].split(",")
        }
        return b
    },
    applyUpdaters: function(b, a) {
        return Ext.apply(a || {},
        b)
    },
    batchedNormalize: function(h, b) {
        if (!h) {
            return {}
        }
        var j = this,
        o = j.getProcessors(),
        f = j.getAliases(),
        s = {},
        m,
        n,
        k,
        d,
        g,
        a,
        t,
        e,
        r,
        q,
        p;
        if ("rotation" in h) {
            t = h.rotation
        } else {
            t = ("rotate" in h) ? h.rotate: k
        }
        if ("scaling" in h) {
            e = h.scaling
        } else {
            e = ("scale" in h) ? h.scale: k
        }
        if ("translation" in h) {
            a = h.translation
        } else {
            a = ("translate" in h) ? h.translate: k
        }
        if (typeof e !== "undefined") {
            if (Ext.isNumber(e)) {
                s.scalingX = e;
                s.scalingY = e
            } else {
                if ("x" in e) {
                    s.scalingX = e.x
                }
                if ("y" in e) {
                    s.scalingY = e.y
                }
                if ("centerX" in e) {
                    s.scalingCenterX = e.centerX
                }
                if ("centerY" in e) {
                    s.scalingCenterY = e.centerY
                }
            }
        }
        if (typeof t !== "undefined") {
            if (Ext.isNumber(t)) {
                t = Ext.draw.Draw.rad(t);
                s.rotationRads = t
            } else {
                if ("rads" in t) {
                    s.rotationRads = t.rads
                } else {
                    if ("degrees" in t) {
                        if (Ext.isArray(t.degrees)) {
                            s.rotationRads = t.degrees.map(function(i) {
                                return Ext.draw.Draw.rad(i)
                            })
                        } else {
                            s.rotationRads = Ext.draw.Draw.rad(t.degrees)
                        }
                    }
                }
                if ("centerX" in t) {
                    s.rotationCenterX = t.centerX
                }
                if ("centerY" in t) {
                    s.rotationCenterY = t.centerY
                }
            }
        }
        if (typeof a !== "undefined") {
            if ("x" in a) {
                s.translationX = a.x
            }
            if ("y" in a) {
                s.translationY = a.y
            }
        }
        if ("matrix" in h) {
            r = Ext.draw.Matrix.create(h.matrix);
            p = r.split();
            s.matrix = r;
            s.rotationRads = p.rotation;
            s.rotationCenterX = 0;
            s.rotationCenterY = 0;
            s.scalingX = p.scaleX;
            s.scalingY = p.scaleY;
            s.scalingCenterX = 0;
            s.scalingCenterY = 0;
            s.translationX = p.translateX;
            s.translationY = p.translateY
        }
        for (d in h) {
            g = h[d];
            if (typeof g === "undefined") {
                continue
            } else {
                if (Ext.isArray(g)) {
                    if (d in f) {
                        d = f[d]
                    }
                    if (d in o) {
                        s[d] = [];
                        for (m = 0, n = g.length; m < n; m++) {
                            q = o[d].call(this, g[m]);
                            if (typeof q !== "undefined") {
                                s[d][m] = q
                            }
                        }
                    } else {
                        if (b) {
                            s[d] = g
                        }
                    }
                } else {
                    if (d in f) {
                        d = f[d]
                    }
                    if (d in o) {
                        g = o[d].call(this, g);
                        if (typeof g !== "undefined") {
                            s[d] = g
                        }
                    } else {
                        if (b) {
                            s[d] = g
                        }
                    }
                }
            }
        }
        return s
    },
    normalize: function(m, b) {
        if (!m) {
            return {}
        }
        var h = this,
        i = h.getProcessors(),
        f = h.getAliases(),
        a = m.translation || m.translate,
        n = {},
        d,
        g,
        o,
        e,
        k,
        j;
        if ("rotation" in m) {
            o = m.rotation
        } else {
            o = ("rotate" in m) ? m.rotate: undefined
        }
        if ("scaling" in m) {
            e = m.scaling
        } else {
            e = ("scale" in m) ? m.scale: undefined
        }
        if (a) {
            if ("x" in a) {
                n.translationX = a.x
            }
            if ("y" in a) {
                n.translationY = a.y
            }
        }
        if (typeof e !== "undefined") {
            if (Ext.isNumber(e)) {
                n.scalingX = e;
                n.scalingY = e
            } else {
                if ("x" in e) {
                    n.scalingX = e.x
                }
                if ("y" in e) {
                    n.scalingY = e.y
                }
                if ("centerX" in e) {
                    n.scalingCenterX = e.centerX
                }
                if ("centerY" in e) {
                    n.scalingCenterY = e.centerY
                }
            }
        }
        if (typeof o !== "undefined") {
            if (Ext.isNumber(o)) {
                o = Ext.draw.Draw.rad(o);
                n.rotationRads = o
            } else {
                if ("rads" in o) {
                    n.rotationRads = o.rads
                } else {
                    if ("degrees" in o) {
                        n.rotationRads = Ext.draw.Draw.rad(o.degrees)
                    }
                }
                if ("centerX" in o) {
                    n.rotationCenterX = o.centerX
                }
                if ("centerY" in o) {
                    n.rotationCenterY = o.centerY
                }
            }
        }
        if ("matrix" in m) {
            k = Ext.draw.Matrix.create(m.matrix);
            j = k.split();
            n.matrix = k;
            n.rotationRads = j.rotation;
            n.rotationCenterX = 0;
            n.rotationCenterY = 0;
            n.scalingX = j.scaleX;
            n.scalingY = j.scaleY;
            n.scalingCenterX = 0;
            n.scalingCenterY = 0;
            n.translationX = j.translateX;
            n.translationY = j.translateY
        }
        for (d in m) {
            g = m[d];
            if (typeof g === "undefined") {
                continue
            }
            if (d in f) {
                d = f[d]
            }
            if (d in i) {
                g = i[d].call(this, g);
                if (typeof g !== "undefined") {
                    n[d] = g
                }
            } else {
                if (b) {
                    n[d] = g
                }
            }
        }
        return n
    },
    setBypassingNormalization: function(a, d, b) {
        return d.pushDown(a, b)
    },
    set: function(a, d, b) {
        b = this.normalize(b);
        return this.setBypassingNormalization(a, d, b)
    }
});
Ext.define("Ext.draw.modifier.Modifier", {
    config: {
        previous: null,
        next: null,
        sprite: null
    },
    constructor: function(a) {
        this.initConfig(a)
    },
    updateNext: function(a) {
        if (a) {
            a.setPrevious(this)
        }
    },
    updatePrev: function(a) {
        if (a) {
            a.setNext(this)
        }
    },
    prepareAttributes: function(a) {
        if (this._previous) {
            this._previous.prepareAttributes(a)
        }
    },
    popUp: function(a, b) {
        if (this._next) {
            this._next.popUp(a, b)
        } else {
            Ext.apply(a, b)
        }
    },
    pushDown: function(a, d) {
        if (this._previous) {
            return this._previous.pushDown(a, d)
        } else {
            for (var b in d) {
                if (d[b] === a[b]) {
                    delete d[b]
                }
            }
            return d
        }
    }
});
Ext.define("Ext.draw.modifier.Target", {
    extend: Ext.draw.modifier.Modifier,
    alias: "modifier.target",
    statics: {
        uniqueId: 0
    },
    prepareAttributes: function(a) {
        if (this._previous) {
            this._previous.prepareAttributes(a)
        }
        a.attributeId = "attribute-" + Ext.draw.modifier.Target.uniqueId++;
        if (!a.hasOwnProperty("canvasAttributes")) {
            a.bbox = {
                plain: {
                    dirty: true
                },
                transform: {
                    dirty: true
                }
            };
            a.dirty = true;
            a.dirtyFlags = {};
            a.canvasAttributes = {};
            a.matrix = new Ext.draw.Matrix();
            a.inverseMatrix = new Ext.draw.Matrix()
        }
    },
    setDirtyFlags: function(h, m) {
        Ext.apply(h, m);
        var p = this._sprite,
        o = p.self.def._dirtyTriggers,
        b, a = h.dirtyFlags,
        e, g = false,
        k, d, f, j, n;
        for (b in m) {
            if ((k = o[b])) {
                f = 0;
                while ((d = k[f++])) {
                    if (! (e = a[d])) {
                        e = a[d] = []
                    }
                    e.push(b)
                }
            }
        }
        for (b in m) {
            g = true;
            break
        }
        if (!g) {
            return
        }
        if (a.canvas) {
            n = a.canvas;
            delete a.canvas;
            for (f = 0, j = n.length; f < j; f++) {
                b = n[f];
                h.canvasAttributes[b] = h[b]
            }
        }
        if (h.hasOwnProperty("children")) {
            for (f = 0, j = h.children.length; f < j; f++) {
                Ext.apply(h.children[f].dirtyFlags, a);
                p.updateDirtyFlags(h.children[f])
            }
        }
        p.setDirty(true)
    },
    popUp: function(a, b) {
        this.setDirtyFlags(a, b);
        this._sprite.updateDirtyFlags(a)
    },
    pushDown: function(a, b) {
        if (this._previous) {
            b = this._previous.pushDown(a, b)
        }
        this.setDirtyFlags(a, b);
        this._sprite.updateDirtyFlags(a);
        return b
    }
}); (function() {
    var g = Math.pow,
    k = Math.sin,
    n = Math.cos,
    m = Math.sqrt,
    f = Math.PI,
    d, o, a, j, h, e, b;
    a = ["quad", "cubic", "quart", "quint"];
    d = {
        pow: function(q, i) {
            return g(q, i[0] || 6)
        },
        expo: function(i) {
            return g(2, 8 * (i - 1))
        },
        circ: function(i) {
            return 1 - m(1 - i * i)
        },
        sine: function(i) {
            return 1 - k((1 - i) * f / 2)
        },
        back: function(i, q) {
            q = q || 1.616;
            return i * i * ((q + 1) * i - q)
        },
        bounce: function(s) {
            var r;
            for (var q = 0,
            i = 1; 1; q += i, i /= 2) {
                if (s >= (7 - 4 * q) / 11) {
                    r = i * i - g((11 - 6 * q - 11 * s) / 4, 2);
                    break
                }
            }
            return r
        },
        elastic: function(q, i) {
            return g(2, 10 * --q) * n(20 * q * f * (i || 1) / 3)
        }
    };
    o = function(p, i) {
        i = i && i.length ? i: [i];
        return Ext.apply(p, {
            easeIn: function(q) {
                return p(q, i)
            },
            easeOut: function(q) {
                return 1 - p(1 - q, i)
            },
            easeInOut: function(q) {
                return (q <= 0.5) ? p(2 * q, i) / 2 : (2 - p(2 * (1 - q), i)) / 2
            }
        })
    };
    j = function(i) {
        return function(q) {
            return g(q, i)
        }
    };
    for (e = 0, b = a.length; e < b; ++e) {
        d[a[e]] = j(e + 2)
    }
    d.linear = function(i) {
        return i
    };
    for (h in d) {
        if (d.hasOwnProperty(h)) {
            o(d[h])
        }
    }
    Ext.define("Ext.draw.TimingFunctions", {
        singleton: true,
        easingMap: {
            linear: d.linear,
            easeIn: d.quad.easeIn,
            easeOut: d.quad.easeOut,
            easeInOut: d.quad.easeInOut,
            backIn: d.back,
            backOut: function(i, p) {
                return 1 - d.back(1 - i, p)
            },
            backInOut: function(i, p) {
                if (i < 0.5) {
                    return d.back(i * 2, p) * 0.5
                } else {
                    return 1 - d.back((1 - i) * 2, p) * 0.5
                }
            },
            elasticIn: function(i, p) {
                return 1 - d.elastic(1 - i, p)
            },
            elasticOut: d.elastic,
            bounceIn: d.bounce,
            bounceOut: function(i) {
                return 1 - d.bounce(1 - i)
            }
        }
    },
    function() {
        Ext.apply(this, d)
    })
})();
Ext.define("Ext.draw.Animator", {
    singleton: true,
    frameCallbacks: {},
    frameCallbackId: 0,
    scheduled: 0,
    frameStartTimeOffset: Date.now(),
    animations: [],
    running: false,
    animationTime: function() {
        return Ext.AnimationQueue.frameStartTime - this.frameStartTimeOffset
    },
    add: function(a) {
        if (!this.contains(a)) {
            this.animations.push(a);
            Ext.draw.Animator.ignite();
            if ("fireEvent" in a) {
                a.fireEvent("animationstart", a)
            }
        }
    },
    remove: function(e) {
        var d = this,
        f = d.animations,
        b = 0,
        a = f.length;
        for (; b < a; ++b) {
            if (f[b] === e) {
                f.splice(b, 1);
                if ("fireEvent" in e) {
                    e.fireEvent("animationend", e)
                }
                return
            }
        }
    },
    contains: function(a) {
        return this.animations.indexOf(a) > -1
    },
    empty: function() {
        return this.animations.length === 0
    },
    step: function(e) {
        var d = this,
        g = d.animations,
        f, a = 0,
        b = g.length;
        for (; a < b; a++) {
            f = g[a];
            f.step(e);
            if (!f.animating) {
                g.splice(a, 1);
                a--;
                b--;
                if (f.fireEvent) {
                    f.fireEvent("animationend")
                }
            }
        }
    },
    schedule: function(d, a) {
        a = a || this;
        var b = "frameCallback" + (this.frameCallbackId++);
        if (Ext.isString(d)) {
            d = a[d]
        }
        Ext.draw.Animator.frameCallbacks[b] = {
            fn: d,
            scope: a,
            once: true
        };
        this.scheduled++;
        Ext.draw.Animator.ignite();
        return b
    },
    cancel: function(a) {
        if (Ext.draw.Animator.frameCallbacks[a] && Ext.draw.Animator.frameCallbacks[a].once) {
            this.scheduled--;
            delete Ext.draw.Animator.frameCallbacks[a]
        }
    },
    addFrameCallback: function(d, a) {
        a = a || this;
        if (Ext.isString(d)) {
            d = a[d]
        }
        var b = "frameCallback" + (this.frameCallbackId++);
        Ext.draw.Animator.frameCallbacks[b] = {
            fn: d,
            scope: a
        };
        return b
    },
    removeFrameCallback: function(a) {
        delete Ext.draw.Animator.frameCallbacks[a]
    },
    fireFrameCallbacks: function() {
        var d = this.frameCallbacks,
        e, b, a;
        for (e in d) {
            a = d[e];
            b = a.fn;
            if (Ext.isString(b)) {
                b = a.scope[b]
            }
            b.call(a.scope);
            if (d[e] && a.once) {
                this.scheduled--;
                delete d[e]
            }
        }
    },
    handleFrame: function() {
        this.step(this.animationTime());
        this.fireFrameCallbacks();
        if (!this.scheduled && this.empty()) {
            Ext.AnimationQueue.stop(this.handleFrame, this);
            this.running = false
        }
    },
    ignite: function() {
        if (!this.running) {
            this.running = true;
            Ext.AnimationQueue.start(this.handleFrame, this);
            Ext.draw.Draw.updateIOS()
        }
    }
});
Ext.define("Ext.draw.modifier.Animation", {
    mixins: {
        observable: Ext.mixin.Observable
    },
    extend: Ext.draw.modifier.Modifier,
    alias: "modifier.animation",
    config: {
        easing: function(a) {
            return a
        },
        duration: 0,
        customEasings: {},
        customDuration: {}
    },
    constructor: function() {
        this.anyAnimation = false;
        this.anySpecialAnimations = false;
        this.animating = 0;
        this.animatingPool = [];
        this.callSuper(arguments)
    },
    prepareAttributes: function(a) {
        if (!a.hasOwnProperty("timers")) {
            a.animating = false;
            a.timers = {};
            a.animationOriginal = Ext.Object.chain(a);
            a.animationOriginal.upperLevel = a
        }
        if (this._previous) {
            this._previous.prepareAttributes(a.animationOriginal)
        }
    },
    updateSprite: function(a) {
        this.setConfig(a.config.fx)
    },
    updateDuration: function(a) {
        this.anyAnimation = a > 0
    },
    applyEasing: function(a) {
        if (typeof a === "string") {
            return Ext.draw.TimingFunctions.easingMap[a]
        } else {
            return a
        }
    },
    applyCustomEasings: function(d, h) {
        h = h || {};
        var a, b, g, e, f;
        for (a in d) {
            g = d[a];
            b = a.split(",");
            if (typeof g === "string") {
                g = Ext.draw.TimingFunctions.easingMap[g]
            }
            for (e = 0, f = b.length; e < f; e++) {
                h[b[e]] = g
            }
        }
        return h
    },
    setEasingOn: function(a, f) {
        a = Ext.Array.from(a).slice();
        var d = {},
        b = 0,
        e = a.length;
        for (; b < e; b++) {
            d[a[b]] = f
        }
        this.setCustomEasings(d)
    },
    clearEasingOn: function(a) {
        a = Ext.Array.from(a, true);
        var b = 0,
        d = a.length;
        for (; b < d; b++) {
            delete this._customEasings[a[b]]
        }
    },
    applyCustomDuration: function(e, d) {
        d = d || {};
        var a, j, b, f, h, g = this.anySpecialAnimations;
        for (a in e) {
            j = e[a];
            b = a.split(",");
            g = true;
            for (f = 0, h = b.length; f < h; f++) {
                d[b[f]] = j
            }
        }
        this.anySpecialAnimations = g;
        return d
    },
    setDurationOn: function(b, f) {
        b = Ext.Array.from(b).slice();
        var a = {},
        d = 0,
        e = b.length;
        for (; d < e; d++) {
            a[b[d]] = f
        }
        this.setCustomDuration(a)
    },
    clearDurationOn: function(a) {
        a = Ext.Array.from(a, true);
        var b = 0,
        d = a.length;
        for (; b < d; b++) {
            delete this._customDuration[a[b]]
        }
    },
    setAnimating: function(b, a) {
        var f = this,
        e, d;
        if (b.animating !== a) {
            b.animating = a;
            if (a) {
                f.animatingPool.push(b);
                if (f.animating === 0) {
                    Ext.draw.Animator.add(f)
                }
                f.animating++
            } else {
                for (e = 0, d = 0; e < f.animatingPool.length; e++) {
                    if (f.animatingPool[e] !== b) {
                        f.animatingPool[d++] = f.animatingPool[e]
                    }
                }
                f.animating = f.animatingPool.length = d
            }
        }
    },
    setAttrs: function(s, u) {
        var o = s.timers,
        j = this._sprite.self.def._animationProcessors,
        g = this._easing,
        f = this._duration,
        i = this._customDuration,
        k = this._customEasings,
        h = this.anySpecialAnimations,
        p = this.anyAnimation || h,
        t = s.animationOriginal,
        e = false,
        m, v, n, q, d, r, a;
        if (!p) {
            for (v in u) {
                if (s[v] === u[v]) {
                    delete u[v]
                } else {
                    s[v] = u[v]
                }
                delete t[v];
                delete o[v]
            }
            return u
        } else {
            for (v in u) {
                n = u[v];
                q = s[v];
                if (n !== q && p && q !== undefined && q !== null && (d = j[v])) {
                    r = g;
                    a = f;
                    if (h) {
                        if (v in k) {
                            r = k[v]
                        }
                        if (v in i) {
                            a = i[v]
                        }
                    }
                    if (a) {
                        if (!o[v]) {
                            o[v] = {}
                        }
                        m = o[v];
                        m.start = 0;
                        m.easing = r;
                        m.duration = a;
                        m.compute = d.compute;
                        m.serve = d.serve || Ext.draw.Draw.reflectFn;
                        if (d.parseInitial) {
                            var b = d.parseInitial(q, n);
                            m.source = b[0];
                            m.target = b[1]
                        } else {
                            if (d.parse) {
                                m.source = d.parse(q);
                                m.target = d.parse(n)
                            } else {
                                m.source = q;
                                m.target = n
                            }
                        }
                        o[v] = m;
                        t[v] = n;
                        delete u[v];
                        e = true;
                        continue
                    } else {
                        delete t[v]
                    }
                } else {
                    delete t[v]
                }
                delete o[v]
            }
        }
        if (e && !s.animating) {
            this.setAnimating(s, true)
        }
        return u
    },
    updateAttributes: function(h) {
        if (!h.animating) {
            return {}
        }
        var j = {},
        i, g = false,
        e = h.animationOriginal,
        f = h.timers,
        d = Ext.draw.Animator.animationTime(),
        a,
        b,
        k;
        if (h.lastUpdate === d) {
            return {}
        }
        for (a in f) {
            b = f[a];
            if (!b.start) {
                b.start = d;
                k = 0
            } else {
                k = (d - b.start) / b.duration
            }
            if (k >= 1) {
                j[a] = e[a];
                delete e[a];
                delete f[a]
            } else {
                j[a] = b.serve(b.compute(b.source, b.target, b.easing(k), h[a]));
                g = true
            }
        }
        h.lastUpdate = d;
        this.setAnimating(h, g);
        return j
    },
    pushDown: function(a, b) {
        b = Ext.draw.modifier.Modifier.prototype.pushDown.call(this, a.animationOriginal, b);
        return this.setAttrs(a, b)
    },
    popUp: function(a, b) {
        a = a.upperLevel;
        b = this.setAttrs(a, b);
        if (this._next) {
            return this._next.popUp(a, b)
        } else {
            return Ext.apply(a, b)
        }
    },
    step: function() {
        var h = this,
        e = h.animatingPool.slice(),
        a,
        d,
        g;
        for (d = 0, g = e.length; d < g; d++) {
            a = e[d];
            var f = this.updateAttributes(a),
            b;
            for (b in f) {
                if (this._next) {
                    this._next.popUp(a, f)
                }
                break
            }
        }
    },
    stop: function() {
        this.step();
        var e = this,
        b = e.animatingPool,
        a, d;
        for (a = 0, d = b.length; a < d; a++) {
            b[a].animating = false
        }
        e.animatingPool.length = 0;
        e.animating = 0;
        Ext.draw.Animator.remove(e)
    },
    destroy: function() {
        var a = this;
        a.animatingPool.length = 0;
        a.animating = 0
    }
});
Ext.define("Ext.draw.modifier.Highlight", {
    extend: Ext.draw.modifier.Modifier,
    alias: "modifier.highlight",
    config: {
        enabled: false,
        highlightStyle: null
    },
    preFx: true,
    applyHighlightStyle: function(b, a) {
        a = a || {};
        if (this.getSprite()) {
            Ext.apply(a, this.getSprite().self.def.normalize(b))
        } else {
            Ext.apply(a, b)
        }
        return a
    },
    prepareAttributes: function(a) {
        if (!a.hasOwnProperty("highlightOriginal")) {
            a.highlighted = false;
            a.highlightOriginal = Ext.Object.chain(a)
        }
        if (this._previous) {
            this._previous.prepareAttributes(a.highlightOriginal)
        }
    },
    updateSprite: function(b, a) {
        if (b) {
            if (this.getHighlightStyle()) {
                this._highlightStyle = b.self.def.normalize(this.getHighlightStyle())
            }
            this.setHighlightStyle(b.config.highlightCfg)
        }
        var d = b.self.def;
        this.setSprite(b);
        d.setConfig({
            defaults: {
                highlighted: false
            },
            processors: {
                highlighted: "bool"
            },
            aliases: {
                highlight: "highlighted",
                highlighting: "highlighted"
            },
            dirtyFlags: {},
            updaters: {}
        })
    },
    filterChanges: function(a, f) {
        var g = this,
        b, d = a.highlightOriginal,
        e = g.getHighlightStyle();
        if (a.highlighted) {
            for (b in f) {
                if (e.hasOwnProperty(b)) {
                    d[b] = f[b];
                    delete f[b]
                }
            }
        }
        for (b in f) {
            if (b !== "highlighted" && d[b] === f[b]) {
                delete f[b]
            }
        }
        return f
    },
    pushDown: function(a, f) {
        var e = this.getHighlightStyle(),
        d = a.highlightOriginal,
        g,
        b;
        if (f.hasOwnProperty("highlighted")) {
            g = f.highlighted;
            delete f.highlighted;
            if (this._previous) {
                f = this._previous.pushDown(d, f)
            }
            f = this.filterChanges(a, f);
            if (g !== a.highlighted) {
                if (g) {
                    for (b in e) {
                        if (b in f) {
                            d[b] = f[b]
                        } else {
                            d[b] = a[b]
                        }
                        if (d[b] !== e[b]) {
                            f[b] = e[b]
                        }
                    }
                } else {
                    for (b in e) {
                        if (! (b in f)) {
                            f[b] = d[b]
                        }
                        delete d[b]
                    }
                }
                f.highlighted = g
            }
        } else {
            if (this._previous) {
                f = this._previous.pushDown(d, f)
            }
            f = this.filterChanges(a, f)
        }
        return f
    },
    popUp: function(a, b) {
        b = this.filterChanges(a, b);
        Ext.draw.modifier.Modifier.prototype.popUp.call(this, a, b)
    }
});
Ext.define("Ext.draw.sprite.Sprite", {
    alias: "sprite.sprite",
    mixins: {
        observable: Ext.mixin.Observable
    },
    isSprite: true,
    inheritableStatics: {
        def: {
            processors: {
                strokeStyle: "color",
                fillStyle: "color",
                strokeOpacity: "limited01",
                fillOpacity: "limited01",
                lineWidth: "number",
                lineCap: "enums(butt,round,square)",
                lineJoin: "enums(round,bevel,miter)",
                lineDash: "data",
                lineDashOffset: "number",
                miterLimit: "number",
                shadowColor: "color",
                shadowOffsetX: "number",
                shadowOffsetY: "number",
                shadowBlur: "number",
                globalAlpha: "limited01",
                globalCompositeOperation: "enums(source-over,destination-over,source-in,destination-in,source-out,destination-out,source-atop,destination-atop,lighter,xor,copy)",
                hidden: "bool",
                transformFillStroke: "bool",
                zIndex: "number",
                translationX: "number",
                translationY: "number",
                rotationRads: "number",
                rotationCenterX: "number",
                rotationCenterY: "number",
                scalingX: "number",
                scalingY: "number",
                scalingCenterX: "number",
                scalingCenterY: "number",
                constrainGradients: "bool"
            },
            aliases: {
                stroke: "strokeStyle",
                fill: "fillStyle",
                color: "fillStyle",
                "stroke-width": "lineWidth",
                "stroke-linecap": "lineCap",
                "stroke-linejoin": "lineJoin",
                "stroke-miterlimit": "miterLimit",
                "text-anchor": "textAlign",
                opacity: "globalAlpha",
                translateX: "translationX",
                translateY: "translationY",
                rotateRads: "rotationRads",
                rotateCenterX: "rotationCenterX",
                rotateCenterY: "rotationCenterY",
                scaleX: "scalingX",
                scaleY: "scalingY",
                scaleCenterX: "scalingCenterX",
                scaleCenterY: "scalingCenterY"
            },
            defaults: {
                hidden: false,
                zIndex: 0,
                strokeStyle: "none",
                fillStyle: "none",
                lineWidth: 1,
                lineDash: [],
                lineDashOffset: 0,
                lineCap: "butt",
                lineJoin: "miter",
                miterLimit: 1,
                shadowColor: "none",
                shadowOffsetX: 0,
                shadowOffsetY: 0,
                shadowBlur: 0,
                globalAlpha: 1,
                strokeOpacity: 1,
                fillOpacity: 1,
                transformFillStroke: false,
                translationX: 0,
                translationY: 0,
                rotationRads: 0,
                rotationCenterX: null,
                rotationCenterY: null,
                scalingX: 1,
                scalingY: 1,
                scalingCenterX: null,
                scalingCenterY: null,
                constrainGradients: false
            },
            dirtyTriggers: {
                hidden: "canvas",
                zIndex: "zIndex",
                globalAlpha: "canvas",
                globalCompositeOperation: "canvas",
                transformFillStroke: "canvas",
                strokeStyle: "canvas",
                fillStyle: "canvas",
                strokeOpacity: "canvas",
                fillOpacity: "canvas",
                lineWidth: "canvas",
                lineCap: "canvas",
                lineJoin: "canvas",
                lineDash: "canvas",
                lineDashOffset: "canvas",
                miterLimit: "canvas",
                shadowColor: "canvas",
                shadowOffsetX: "canvas",
                shadowOffsetY: "canvas",
                shadowBlur: "canvas",
                translationX: "transform",
                translationY: "transform",
                rotationRads: "transform",
                rotationCenterX: "transform",
                rotationCenterY: "transform",
                scalingX: "transform",
                scalingY: "transform",
                scalingCenterX: "transform",
                scalingCenterY: "transform",
                constrainGradients: "canvas"
            },
            updaters: {
                bbox: function(a) {
                    a.bbox.plain.dirty = true;
                    a.bbox.transform.dirty = true;
                    if (a.rotationRads !== 0 && (a.rotationCenterX === null || a.rotationCenterY === null) || ((a.scalingX !== 1 || a.scalingY !== 1) && (a.scalingCenterX === null || a.scalingCenterY === null))) {
                        if (!a.dirtyFlags.transform) {
                            a.dirtyFlags.transform = []
                        }
                    }
                },
                zIndex: function(a) {
                    a.dirtyZIndex = true
                },
                transform: function(a) {
                    a.dirtyTransform = true;
                    a.bbox.transform.dirty = true
                }
            }
        }
    },
    attr: {},
    config: {
        parent: null
    },
    onClassExtended: function(b, e) {
        var d = b.superclass.self.def.initialConfig,
        a;
        if (e.inheritableStatics && e.inheritableStatics.def) {
            a = Ext.merge({},
            d, e.inheritableStatics.def);
            b.def = Ext.create("Ext.draw.sprite.AttributeDefinition", a);
            delete e.inheritableStatics.def
        } else {
            b.def = Ext.create("Ext.draw.sprite.AttributeDefinition", d)
        }
    },
    constructor: function(d) {
        if (this.$className === "Ext.draw.sprite.Sprite") {
            throw "Ext.draw.sprite.Sprite is an abstract class"
        }
        d = d || {};
        var g = this,
        a = [].concat(d.group || []),
        e,
        f;
        g.id = d.id || Ext.id(null, "ext-sprite-");
        g.group = new Array(a.length);
        for (e = 0, f = a.length; e < f; e++) {
            g.group[e] = a[e].id || a[e].toString()
        }
        g.attr = {};
        g.initConfig(d);
        var b = Ext.Array.from(d.modifiers, true);
        g.prepareModifiers(b);
        g.initializeAttributes();
        g.setAttributes(g.self.def.getDefaults(), true);
        g.setAttributes(d)
    },
    getDirty: function() {
        return this.attr.dirty
    },
    setDirty: function(a) {
        if ((this.attr.dirty = a)) {
            if (this._parent) {
                this._parent.setDirty(true)
            }
        }
    },
    addModifier: function(a, b) {
        var d = this;
        if (! (a instanceof Ext.draw.modifier.Modifier)) {
            a = Ext.factory(a, null, null, "modifier")
        }
        a.setSprite(this);
        if (a.preFx || a.config && a.config.preFx) {
            if (d.fx.getPrevious()) {
                d.fx.getPrevious().setNext(a)
            }
            a.setNext(d.fx)
        } else {
            d.topModifier.getPrevious().setNext(a);
            a.setNext(d.topModifier)
        }
        if (b) {
            d.initializeAttributes()
        }
        return a
    },
    prepareModifiers: function(f) {
        var e = this,
        a, b, d;
        e.topModifier = new Ext.draw.modifier.Target({
            sprite: e
        });
        e.fx = new Ext.draw.modifier.Animation({
            sprite: e
        });
        e.fx.setNext(e.topModifier);
        for (b = 0, d = f.length; b < d; b++) {
            e.addModifier(f[b], false)
        }
    },
    initializeAttributes: function() {
        var a = this;
        a.topModifier.prepareAttributes(a.attr)
    },
    updateDirtyFlags: function(d) {
        var g = this,
        i = d.dirtyFlags,
        b, f = g.self.def._updaters,
        h = false,
        e = false,
        a;
        do {
            h = false;
            for (a in i) {
                g.updateDirtyFlags = Ext.emptyFn;
                b = i[a];
                delete i[a];
                if (f[a]) {
                    f[a].call(g, d, b)
                }
                h = true;
                delete g.updateDirtyFlags
            }
            e = e || h
        } while ( h );
        if (e) {
            g.setDirty(true)
        }
    },
    setAttributes: function(d, e, b) {
        var a = this.attr;
        if (e) {
            if (b) {
                this.topModifier.pushDown(a, d)
            } else {
                this.topModifier.pushDown(a, Ext.apply({},
                d))
            }
        } else {
            this.topModifier.pushDown(a, this.self.def.normalize(d))
        }
    },
    setAttributesBypassingNormalization: function(b, a) {
        return this.setAttributes(b, true, a)
    },
    getBBox: function(e) {
        var f = this,
        a = f.attr,
        g = a.bbox,
        d = g.plain,
        b = g.transform;
        if (d.dirty) {
            f.updatePlainBBox(d);
            d.dirty = false
        }
        if (e) {
            return d
        } else {
            f.applyTransformations();
            if (b.dirty) {
                f.updateTransformedBBox(b, d);
                b.dirty = false
            }
            return b
        }
    },
    updatePlainBBox: Ext.emptyFn,
    updateTransformedBBox: function(a, b) {
        this.attr.matrix.transformBBox(b, 0, a)
    },
    getBBoxCenter: function(a) {
        var b = this.getBBox(a);
        if (b) {
            return [b.x + b.width * 0.5, b.y + b.height * 0.5]
        } else {
            return [0, 0]
        }
    },
    hide: function() {
        this.attr.hidden = true;
        this.setDirty(true);
        return this
    },
    show: function() {
        this.attr.hidden = false;
        this.setDirty(true);
        return this
    },
    useAttributes: function(j, f) {
        this.applyTransformations();
        var g = this.attr,
        i = g.canvasAttributes,
        e = i.strokeStyle,
        h = i.fillStyle,
        b = i.lineDash,
        d = i.lineDashOffset,
        a;
        if (e) {
            if (e.isGradient) {
                j.strokeStyle = "black";
                j.strokeGradient = e
            } else {
                j.strokeGradient = false
            }
        }
        if (h) {
            if (h.isGradient) {
                j.fillStyle = "black";
                j.fillGradient = h
            } else {
                j.fillGradient = false
            }
        }
        if (b && j.setLineDash) {
            j.setLineDash(b)
        }
        if (d && typeof j.lineDashOffset === "number") {
            j.lineDashOffset = d
        }
        for (a in i) {
            if (i[a] !== undefined && i[a] !== j[a]) {
                j[a] = i[a]
            }
        }
        if (g.constrainGradients) {
            j.setGradientBBox({
                x: f[0],
                y: f[1],
                width: f[2],
                height: f[3]
            })
        } else {
            j.setGradientBBox(this.getBBox(g.transformFillStroke))
        }
    },
    applyTransformations: function(e) {
        if (!e && !this.attr.dirtyTransform) {
            return
        }
        var n = this,
        j = n.attr,
        a = n.getBBoxCenter(true),
        i = a[0],
        h = a[1],
        r = j.translationX,
        p = j.translationY,
        q = j.scalingX,
        o = j.scalingY === null ? j.scalingX: j.scalingY,
        g = j.scalingCenterX === null ? i: j.scalingCenterX,
        f = j.scalingCenterY === null ? h: j.scalingCenterY,
        m = j.rotationRads,
        d = j.rotationCenterX === null ? i: j.rotationCenterX,
        b = j.rotationCenterY === null ? h: j.rotationCenterY,
        s = Math.cos(m),
        k = Math.sin(m);
        if (q === 1 && o === 1) {
            g = 0;
            f = 0
        }
        if (m === 0) {
            d = 0;
            b = 0
        }
        j.matrix.elements = [s * q, k * o, -k * q, s * o, g + (d - s * d - g + b * k) * q + r, f + (b - s * b - f + d * -k) * o + p];
        j.matrix.inverse(j.inverseMatrix);
        j.dirtyTransform = false;
        j.bbox.transform.dirty = true
    },
    preRender: Ext.emptyFn,
    render: Ext.emptyFn,
    repaint: function() {
        var a = this.getParent();
        while (a && !(a instanceof Ext.draw.Surface)) {
            a = a.getParent()
        }
        if (a) {
            a.renderFrame()
        }
    },
    destroy: function() {
        var b = this,
        a = b.topModifier,
        d;
        while (a) {
            d = a;
            a = a.getPrevious();
            d.destroy()
        }
        delete b.attr;
        b.destroy = Ext.emptyFn;
        if (b.fireEvent("beforedestroy", b) !== false) {
            b.fireEvent("destroy", b)
        }
        this.callSuper()
    }
},
function() {
    this.def = Ext.create("Ext.draw.sprite.AttributeDefinition", this.def)
}); (function() {
    var b = 2.0943951023931953,
    a = Math.abs,
    e = Math.cos,
    h = Math.cos,
    d = Math.acos,
    g = Math.sqrt,
    i = Math.exp,
    f = Math.log;
    Ext.define("Ext.draw.Solver", {
        singleton: true,
        cubicRoot: function(j) {
            if (j > 0) {
                return i(f(j) / 3)
            } else {
                if (j < 0) {
                    return - i(f( - j) / 3)
                } else {
                    return 0
                }
            }
        },
        linearFunction: function(m, k) {
            var j;
            if (m === 0) {
                j = function(n) {
                    return k
                };
                j.solve = function(n) {
                    return []
                }
            } else {
                j = function(n) {
                    return m * n + k
                };
                j.solve = function(n) {
                    return [(n - k) / m]
                }
            }
            return j
        },
        quadraticFunction: function(m, k, r) {
            var j;
            if (m === 0) {
                return this.linearFunction(k, r)
            } else {
                j = function(s) {
                    return (m * s + k) * s + r
                };
                var q = k * k - 4 * m * r,
                p = function(s) {
                    return q + 4 * m * s
                },
                o = 1 / m * 0.5,
                n = -o * k;
                o = a(o);
                j.solve = function(t) {
                    var s = p(t);
                    if (s < 0) {
                        return []
                    }
                    s = g(s);
                    return [n - s * o, n + s * o]
                }
            }
            return j
        },
        cubicFunction: function(u, t, r, q) {
            var z;
            if (u === 0) {
                return this.quadraticFunction(t, r, q)
            } else {
                z = function(A) {
                    return ((u * A + t) * A + r) * A + q
                };
                var o = t / u / 3,
                j = r / u,
                n = q / u,
                s = o * o,
                y = (o * j - n) * 0.5 - o * s,
                v = s - j / 3,
                m = v * v * v;
                if (v === 0) {
                    z.solve = function(A) {
                        return [ - o + this.cubicRoot(y * 2 + A / u)]
                    }
                } else {
                    if (v > 0) {
                        var k = g(v),
                        p = k * k * k;
                        k += k
                    }
                    z.solve = function(H) {
                        H /= u;
                        var D = y + H * 0.5,
                        F = D * D - m;
                        if (F > 0) {
                            F = g(F);
                            return [ - o + this.cubicRoot(D + F) + this.cubicRoot(D - F)]
                        } else {
                            if (F === 0) {
                                var G = this.cubicRoot(D),
                                I = -o - G;
                                if (D >= 0) {
                                    return [I, I, -o + 2 * G]
                                } else {
                                    return [ - o + 2 * G, I, I]
                                }
                            } else {
                                var E = d(D / p) / 3,
                                C = k * h(E) - o,
                                B = k * h(E + b) - o,
                                A = k * h(E - b) - o;
                                if (C < B) {
                                    if (B < A) {
                                        return [C, B, A]
                                    } else {
                                        if (C < A) {
                                            return [C, A, B]
                                        } else {
                                            return [A, C, B]
                                        }
                                    }
                                } else {
                                    if (C < A) {
                                        return [B, C, A]
                                    } else {
                                        if (B < A) {
                                            return [B, A, C]
                                        } else {
                                            return [A, B, C]
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return z
        },
        createBezierSolver: function(k, j, n, m) {
            return this.cubicFunction(3 * (j - n) + m - k, 3 * (k - 2 * j + n), 3 * (j - k), k)
        }
    })
})();
Ext.define("Ext.draw.Path", {
    statics: {
        pathRe: /,?([achlmqrstvxz]),?/gi,
        pathRe2: /-/gi,
        pathSplitRe: /\s|,/g
    },
    svgString: "",
    constructor: function(a) {
        var b = this;
        b.coords = [];
        b.types = [];
        b.cursor = null;
        b.startX = 0;
        b.startY = 0;
        b.solvers = {};
        if (a) {
            b.fromSvgString(a)
        }
    },
    clear: function() {
        var a = this;
        a.coords.length = 0;
        a.types.length = 0;
        a.cursor = null;
        a.startX = 0;
        a.startY = 0;
        a.solvers = {};
        a.dirt()
    },
    dirt: function() {
        this.svgString = ""
    },
    moveTo: function(a, d) {
        var b = this;
        if (!b.cursor) {
            b.cursor = [a, d]
        }
        b.coords.push(a, d);
        b.types.push("M");
        b.startX = a;
        b.startY = d;
        b.cursor[0] = a;
        b.cursor[1] = d;
        b.dirt()
    },
    lineTo: function(a, d) {
        var b = this;
        if (!b.cursor) {
            b.cursor = [a, d];
            b.coords.push(a, d);
            b.types.push("M")
        } else {
            b.coords.push(a, d);
            b.types.push("L")
        }
        b.cursor[0] = a;
        b.cursor[1] = d;
        b.dirt()
    },
    bezierCurveTo: function(d, f, b, e, a, h) {
        var g = this;
        if (!g.cursor) {
            g.moveTo(d, f)
        }
        g.coords.push(d, f, b, e, a, h);
        g.types.push("C");
        g.cursor[0] = a;
        g.cursor[1] = h;
        g.dirt()
    },
    quadraticCurveTo: function(b, f, a, e) {
        var d = this;
        if (!d.cursor) {
            d.moveTo(b, f)
        }
        d.bezierCurveTo((d.cursor[0] * 2 + b) / 3, (d.cursor[1] * 2 + f) / 3, (a * 2 + b) / 3, (e * 2 + f) / 3, a, e)
    },
    closePath: function() {
        var a = this;
        if (a.cursor) {
            a.types.push("Z");
            a.dirt()
        }
    },
    arcTo: function(E, g, D, e, k, j, z) {
        var I = this;
        if (j === undefined) {
            j = k
        }
        if (z === undefined) {
            z = 0
        }
        if (!I.cursor) {
            I.moveTo(E, g);
            return
        }
        if (k === 0 || j === 0) {
            I.lineTo(E, g);
            return
        }
        D -= E;
        e -= g;
        var F = I.cursor[0] - E,
        h = I.cursor[1] - g,
        G = D * h - e * F,
        b,
        a,
        n,
        t,
        m,
        s,
        B = Math.sqrt(F * F + h * h),
        y = Math.sqrt(D * D + e * e),
        v,
        f,
        d;
        if (G === 0) {
            I.lineTo(E, g);
            return
        }
        if (j !== k) {
            b = Math.cos(z);
            a = Math.sin(z);
            n = b / k;
            t = a / j;
            m = -a / k;
            s = b / j;
            var H = n * F + t * h;
            h = m * F + s * h;
            F = H;
            H = n * D + t * e;
            e = m * D + s * e;
            D = H
        } else {
            F /= k;
            h /= j;
            D /= k;
            e /= j
        }
        f = F * y + D * B;
        d = h * y + e * B;
        v = 1 / (Math.sin(Math.asin(Math.abs(G) / (B * y)) * 0.5) * Math.sqrt(f * f + d * d));
        f *= v;
        d *= v;
        var q = (f * F + d * h) / (F * F + h * h),
        o = (f * D + d * e) / (D * D + e * e);
        var p = F * q - f,
        r = h * q - d,
        i = D * o - f,
        C = e * o - d,
        A = Math.atan2(r, p),
        u = Math.atan2(C, i);
        if (G > 0) {
            if (u < A) {
                u += Math.PI * 2
            }
        } else {
            if (A < u) {
                A += Math.PI * 2
            }
        }
        if (j !== k) {
            f = b * f * k - a * d * j + E;
            d = a * d * j + b * d * j + g;
            I.lineTo(b * k * p - a * j * r + f, a * k * p + b * j * r + d);
            I.ellipse(f, d, k, j, z, A, u, G < 0)
        } else {
            f = f * k + E;
            d = d * j + g;
            I.lineTo(k * p + f, j * r + d);
            I.ellipse(f, d, k, j, z, A, u, G < 0)
        }
    },
    ellipse: function(h, g, d, a, s, o, e, f) {
        var p = this,
        q = p.coords,
        b = q.length,
        n, m, k;
        if (e - o >= Math.PI * 2) {
            p.ellipse(h, g, d, a, s, o, o + Math.PI, f);
            p.ellipse(h, g, d, a, s, o + Math.PI, e, f);
            return
        }
        if (!f) {
            if (e < o) {
                e += Math.PI * 2
            }
            n = p.approximateArc(q, h, g, d, a, s, o, e)
        } else {
            if (o < e) {
                o += Math.PI * 2
            }
            n = p.approximateArc(q, h, g, d, a, s, e, o);
            for (m = b, k = q.length - 2; m < k; m += 2, k -= 2) {
                var r = q[m];
                q[m] = q[k];
                q[k] = r;
                r = q[m + 1];
                q[m + 1] = q[k + 1];
                q[k + 1] = r
            }
        }
        if (!p.cursor) {
            p.cursor = [q[q.length - 2], q[q.length - 1]];
            p.types.push("M")
        } else {
            p.cursor[0] = q[q.length - 2];
            p.cursor[1] = q[q.length - 1];
            p.types.push("L")
        }
        for (m = 2; m < n; m += 6) {
            p.types.push("C")
        }
        p.dirt()
    },
    arc: function(b, g, a, e, d, f) {
        this.ellipse(b, g, a, a, 0, e, d, f)
    },
    rect: function(b, f, d, a) {
        if (d == 0 || a == 0) {
            return
        }
        var e = this;
        e.moveTo(b, f);
        e.lineTo(b + d, f);
        e.lineTo(b + d, f + a);
        e.lineTo(b, f + a);
        e.closePath()
    },
    approximateArc: function(u, j, g, q, p, e, B, z) {
        var f = Math.cos(e),
        D = Math.sin(e),
        m = Math.cos(B),
        n = Math.sin(B),
        s = f * m * q - D * n * p,
        C = -f * n * q - D * m * p,
        r = D * m * q + f * n * p,
        A = -D * n * q + f * m * p,
        o = Math.PI / 2,
        t = 2,
        k = s,
        y = C,
        i = r,
        v = A,
        b = 0.547443256150549,
        G,
        h,
        E,
        a,
        F,
        d;
        z -= B;
        if (z < 0) {
            z += Math.PI * 2
        }
        u.push(s + j, r + g);
        while (z >= o) {
            u.push(k + y * b + j, i + v * b + g, k * b + y + j, i * b + v + g, y + j, v + g);
            t += 6;
            z -= o;
            G = k;
            k = y;
            y = -G;
            G = i;
            i = v;
            v = -G
        }
        if (z) {
            h = (0.3294738052815987 + 0.012120855841304373 * z) * z;
            E = Math.cos(z);
            a = Math.sin(z);
            F = E + h * a;
            d = a - h * E;
            u.push(k + y * h + j, i + v * h + g, k * F + y * d + j, i * F + v * d + g, k * E + y * a + j, i * E + v * a + g);
            t += 6
        }
        return t
    },
    arcSvg: function(k, i, t, o, A, v, d) {
        if (k < 0) {
            k = -k
        }
        if (i < 0) {
            i = -i
        }
        var B = this,
        y = B.cursor[0],
        g = B.cursor[1],
        a = (y - v) / 2,
        C = (g - d) / 2,
        e = Math.cos(t),
        u = Math.sin(t),
        q = a * e + C * u,
        z = -a * u + C * e,
        j = q / k,
        h = z / i,
        r = j * j + h * h,
        f = (y + v) * 0.5,
        b = (g + d) * 0.5,
        n = 0,
        m = 0;
        if (r >= 1) {
            r = Math.sqrt(r);
            k *= r;
            i *= r
        } else {
            r = Math.sqrt(1 / r - 1);
            if (o === A) {
                r = -r
            }
            n = r * k * h;
            m = -r * i * j;
            f += e * n - u * m;
            b += u * n + e * m
        }
        var s = Math.atan2((z - m) / i, (q - n) / k),
        p = Math.atan2(( - z - m) / i, ( - q - n) / k) - s;
        if (A) {
            if (p <= 0) {
                p += Math.PI * 2
            }
        } else {
            if (p >= 0) {
                p -= Math.PI * 2
            }
        }
        B.ellipse(f, b, k, i, t, s, s + p, 1 - A)
    },
    fromSvgString: function(f) {
        if (!f) {
            return
        }
        var o = this,
        j, n = {
            a: 7,
            c: 6,
            h: 1,
            l: 2,
            m: 2,
            q: 4,
            s: 4,
            t: 2,
            v: 1,
            z: 0,
            A: 7,
            C: 6,
            H: 1,
            L: 2,
            M: 2,
            Q: 4,
            S: 4,
            T: 2,
            V: 1,
            Z: 0
        },
        m = "",
        h,
        g,
        d = 0,
        b = 0,
        e = false,
        k,
        p,
        a;
        if (Ext.isString(f)) {
            j = f.replace(Ext.draw.Path.pathRe, " $1 ").replace(Ext.draw.Path.pathRe2, " -").split(Ext.draw.Path.pathSplitRe)
        } else {
            if (Ext.isArray(f)) {
                j = f.join(",").split(Ext.draw.Path.pathSplitRe)
            }
        }
        for (k = 0, p = 0; k < j.length; k++) {
            if (j[k] !== "") {
                j[p++] = j[k]
            }
        }
        j.length = p;
        o.clear();
        for (k = 0; k < j.length;) {
            m = e;
            e = j[k];
            a = (e.toUpperCase() !== e);
            k++;
            switch (e) {
            case "M":
                o.moveTo(d = +j[k], b = +j[k + 1]);
                k += 2;
                while (k < p && !n.hasOwnProperty(j[k])) {
                    o.lineTo(d = +j[k], b = +j[k + 1]);
                    k += 2
                }
                break;
            case "L":
                o.lineTo(d = +j[k], b = +j[k + 1]);
                k += 2;
                while (k < p && !n.hasOwnProperty(j[k])) {
                    o.lineTo(d = +j[k], b = +j[k + 1]);
                    k += 2
                }
                break;
            case "A":
                while (k < p && !n.hasOwnProperty(j[k])) {
                    o.arcSvg( + j[k], +j[k + 1], +j[k + 2] * Math.PI / 180, +j[k + 3], +j[k + 4], d = +j[k + 5], b = +j[k + 6]);
                    k += 7
                }
                break;
            case "C":
                while (k < p && !n.hasOwnProperty(j[k])) {
                    o.bezierCurveTo( + j[k], +j[k + 1], h = +j[k + 2], g = +j[k + 3], d = +j[k + 4], b = +j[k + 5]);
                    k += 6
                }
                break;
            case "Z":
                o.closePath();
                break;
            case "m":
                o.moveTo(d += +j[k], b += +j[k + 1]);
                k += 2;
                while (k < p && !n.hasOwnProperty(j[k])) {
                    o.lineTo(d += +j[k], b += +j[k + 1]);
                    k += 2
                }
                break;
            case "l":
                o.lineTo(d += +j[k], b += +j[k + 1]);
                k += 2;
                while (k < p && !n.hasOwnProperty(j[k])) {
                    o.lineTo(d += +j[k], b += +j[k + 1]);
                    k += 2
                }
                break;
            case "a":
                while (k < p && !n.hasOwnProperty(j[k])) {
                    o.arcSvg( + j[k], +j[k + 1], +j[k + 2] * Math.PI / 180, +j[k + 3], +j[k + 4], d += +j[k + 5], b += +j[k + 6]);
                    k += 7
                }
                break;
            case "c":
                while (k < p && !n.hasOwnProperty(j[k])) {
                    o.bezierCurveTo(d + ( + j[k]), b + ( + j[k + 1]), h = d + ( + j[k + 2]), g = b + ( + j[k + 3]), d += +j[k + 4], b += +j[k + 5]);
                    k += 6
                }
                break;
            case "z":
                o.closePath();
                break;
            case "s":
                if (! (m === "c" || m === "C" || m === "s" || m === "S")) {
                    h = d;
                    g = b
                }
                while (k < p && !n.hasOwnProperty(j[k])) {
                    o.bezierCurveTo(d + d - h, b + b - g, h = d + ( + j[k]), g = b + ( + j[k + 1]), d += +j[k + 2], b += +j[k + 3]);
                    k += 4
                }
                break;
            case "S":
                if (! (m === "c" || m === "C" || m === "s" || m === "S")) {
                    h = d;
                    g = b
                }
                while (k < p && !n.hasOwnProperty(j[k])) {
                    o.bezierCurveTo(d + d - h, b + b - g, h = +j[k], g = +j[k + 1], d = ( + j[k + 2]), b = ( + j[k + 3]));
                    k += 4
                }
                break;
            case "q":
                while (k < p && !n.hasOwnProperty(j[k])) {
                    o.quadraticCurveTo(h = d + ( + j[k]), g = b + ( + j[k + 1]), d += +j[k + 2], b += +j[k + 3]);
                    k += 4
                }
                break;
            case "Q":
                while (k < p && !n.hasOwnProperty(j[k])) {
                    o.quadraticCurveTo(h = +j[k], g = +j[k + 1], d = +j[k + 2], b = +j[k + 3]);
                    k += 4
                }
                break;
            case "t":
                if (! (m === "q" || m === "Q" || m === "t" || m === "T")) {
                    h = d;
                    g = b
                }
                while (k < p && !n.hasOwnProperty(j[k])) {
                    o.quadraticCurveTo(h = d + d - h, g = b + b - g, d += +j[k + 1], b += +j[k + 2]);
                    k += 2
                }
                break;
            case "T":
                if (! (m === "q" || m === "Q" || m === "t" || m === "T")) {
                    h = d;
                    g = b
                }
                while (k < p && !n.hasOwnProperty(j[k])) {
                    o.quadraticCurveTo(h = d + d - h, g = b + b - g, d = ( + j[k + 1]), b = ( + j[k + 2]));
                    k += 2
                }
                break;
            case "h":
                while (k < p && !n.hasOwnProperty(j[k])) {
                    o.lineTo(d += +j[k], b);
                    k++
                }
                break;
            case "H":
                while (k < p && !n.hasOwnProperty(j[k])) {
                    o.lineTo(d = +j[k], b);
                    k++
                }
                break;
            case "v":
                while (k < p && !n.hasOwnProperty(j[k])) {
                    o.lineTo(d, b += +j[k]);
                    k++
                }
                break;
            case "V":
                while (k < p && !n.hasOwnProperty(j[k])) {
                    o.lineTo(d, b = +j[k]);
                    k++
                }
                break
            }
        }
    },
    rayTestLine: function(e, g, d, f, b, h) {
        var a;
        if (g === f) {
            if (h === g) {
                if (Math.min(e, d) <= b && b <= Math.max(e, d)) {
                    return - 1
                }
            } else {
                return 0
            }
        }
        if (g < h && h < f || f < h && h < g) {
            a = (h - g) * (d - e) / (f - g) + e;
            if (a === b) {
                return - 1
            } else {
                if (a < b) {
                    return 0
                } else {
                    return 1
                }
            }
        } else {
            return 0
        }
    },
    rayTestCubicBezier: function(d, k, b, i, a, g, p, e, j, h, m) {
        if (Math.min(d, b, a, p) <= j && j <= Math.max(d, b, a, p)) {
            if (Math.min(k, i, g, e) <= h && h <= Math.max(k, i, g, e)) {
                var f = this,
                o = f.solvers[m] || (f.solvers[m] = Ext.draw.Solver.createBezierSolver(d, b, a, p)),
                n = o.solve(h);
                return ( + (j <= n[0] && 0 <= n[0] && n[0] <= 1)) + ( + (j <= n[1] && 0 <= n[1] && n[1] <= 1)) + ( + (j <= n[2] && 0 <= n[2] && n[2] <= 1))
            }
        }
        return 0
    },
    isPointInPath: function(r, p) {
        var o = this,
        g, f, h = 0,
        n = 0,
        k = o.types,
        q = o.coords,
        m = k.length,
        e = null,
        d = null,
        b = 0,
        a = 0;
        for (g = 0, f = 0; g < m; g++) {
            switch (k[g]) {
            case "M":
                if (e !== null) {
                    n = o.rayTestLine(e, d, b, a, r, p);
                    if (n < 0) {
                        h += 1
                    } else {
                        h += n
                    }
                }
                e = b = q[f];
                d = a = q[f + 1];
                f += 2;
                break;
            case "L":
                n = o.rayTestLine(b, a, q[f], q[f + 1], r, p);
                if (n < 0) {
                    return true
                }
                h += n;
                b = q[f];
                a = q[f + 1];
                f += 2;
                break;
            case "C":
                n = o.rayTestCubicBezier(b, a, q[f], q[f + 1], q[f + 2], q[f + 3], q[f + 4], q[f + 5], r, p, g);
                if (n < 0) {
                    return true
                }
                h += n;
                b = q[f + 4];
                a = q[f + 5];
                f += 6;
                break;
            case "Z":
                break
            }
        }
        return h % 2 === 1
    },
    clone: function() {
        var a = this,
        b = new Ext.draw.Path();
        b.coords = a.coords.slice(0);
        b.types = a.types.slice(0);
        b.cursor = a.cursor ? a.cursor.slice(0) : null;
        b.startX = a.startX;
        b.startY = a.startY;
        b.svgString = a.svgString;
        return b
    },
    transform: function(k) {
        if (k.isIdentity()) {
            return
        }
        var a = k.getXX(),
        f = k.getYX(),
        o = k.getDX(),
        n = k.getXY(),
        e = k.getYY(),
        m = k.getDY(),
        j = this.coords,
        b = 0,
        d = j.length,
        h,
        g;
        for (; b < d; b += 2) {
            h = j[b];
            g = j[b + 1];
            j[b] = h * a + g * f + o;
            j[b + 1] = h * n + g * e + m
        }
        this.dirt()
    },
    getDimension: function(h) {
        if (!h) {
            h = {}
        }
        if (!this.types || !this.types.length) {
            h.x = 0;
            h.y = 0;
            h.width = 0;
            h.height = 0;
            return h
        }
        h.left = Infinity;
        h.top = Infinity;
        h.right = -Infinity;
        h.bottom = -Infinity;
        var e = 0,
        b = 0,
        d = this.types,
        g = this.coords,
        f = d.length,
        a, k;
        for (; e < f; e++) {
            switch (d[e]) {
            case "M":
            case "L":
                a = g[b];
                k = g[b + 1];
                h.left = Math.min(a, h.left);
                h.top = Math.min(k, h.top);
                h.right = Math.max(a, h.right);
                h.bottom = Math.max(k, h.bottom);
                b += 2;
                break;
            case "C":
                this.expandDimension(h, a, k, g[b], g[b + 1], g[b + 2], g[b + 3], a = g[b + 4], k = g[b + 5]);
                b += 6;
                break
            }
        }
        h.x = h.left;
        h.y = h.top;
        h.width = h.right - h.left;
        h.height = h.bottom - h.top;
        return h
    },
    getDimensionWithTransform: function(p, f) {
        if (!this.types || !this.types.length) {
            if (!f) {
                f = {}
            }
            f.x = 0;
            f.y = 0;
            f.width = 0;
            f.height = 0;
            return f
        }
        f.left = Infinity;
        f.top = Infinity;
        f.right = -Infinity;
        f.bottom = -Infinity;
        var a = p.getXX(),
        k = p.getYX(),
        s = p.getDX(),
        r = p.getXY(),
        h = p.getYY(),
        q = p.getDY(),
        d = 0,
        b = 0,
        e = this.types,
        o = this.coords,
        g = e.length,
        n,
        m;
        for (; d < g; d++) {
            switch (e[d]) {
            case "M":
            case "L":
                n = o[b] * a + o[b + 1] * k + s;
                m = o[b] * r + o[b + 1] * h + q;
                f.left = Math.min(n, f.left);
                f.top = Math.min(m, f.top);
                f.right = Math.max(n, f.right);
                f.bottom = Math.max(m, f.bottom);
                b += 2;
                break;
            case "C":
                this.expandDimension(f, n, m, o[b] * a + o[b + 1] * k + s, o[b] * r + o[b + 1] * h + q, o[b + 2] * a + o[b + 3] * k + s, o[b + 2] * r + o[b + 3] * h + q, n = o[b + 4] * a + o[b + 5] * k + s, m = o[b + 4] * r + o[b + 5] * h + q);
                b += 6;
                break
            }
        }
        if (!f) {
            f = {}
        }
        f.x = f.left;
        f.y = f.top;
        f.width = f.right - f.left;
        f.height = f.bottom - f.top;
        return f
    },
    expandDimension: function(j, e, q, m, h, k, f, d, p) {
        var n = this,
        g = j.left,
        a = j.right,
        s = j.top,
        o = j.bottom,
        i = n.dim || (n.dim = []);
        n.curveDimension(e, m, k, d, i);
        g = Math.min(g, i[0]);
        a = Math.max(a, i[1]);
        n.curveDimension(q, h, f, p, i);
        s = Math.min(s, i[0]);
        o = Math.max(o, i[1]);
        j.left = g;
        j.right = a;
        j.top = s;
        j.bottom = o
    },
    curveDimension: function(q, o, k, j, h) {
        var i = 3 * ( - q + 3 * (o - k) + j),
        g = 6 * (q - 2 * o + k),
        f = -3 * (q - o),
        p,
        n,
        e = Math.min(q, j),
        m = Math.max(q, j),
        r;
        if (i === 0) {
            if (g === 0) {
                h[0] = e;
                h[1] = m;
                return
            } else {
                p = -f / g;
                if (0 < p && p < 1) {
                    n = this.interpolate(q, o, k, j, p);
                    e = Math.min(e, n);
                    m = Math.max(m, n)
                }
            }
        } else {
            r = g * g - 4 * i * f;
            if (r >= 0) {
                r = Math.sqrt(r);
                p = (r - g) / 2 / i;
                if (0 < p && p < 1) {
                    n = this.interpolate(q, o, k, j, p);
                    e = Math.min(e, n);
                    m = Math.max(m, n)
                }
                if (r > 0) {
                    p -= r / i;
                    if (0 < p && p < 1) {
                        n = this.interpolate(q, o, k, j, p);
                        e = Math.min(e, n);
                        m = Math.max(m, n)
                    }
                }
            }
        }
        h[0] = e;
        h[1] = m
    },
    interpolate: function(f, e, j, i, g) {
        if (g === 0) {
            return f
        }
        if (g === 1) {
            return i
        }
        var h = (1 - g) / g;
        return g * g * g * (i + h * (3 * j + h * (3 * e + h * f)))
    },
    fromStripes: function(h) {
        var f = this,
        d = 0,
        e = h.length,
        b, a, g;
        f.clear();
        for (; d < e; d++) {
            g = h[d];
            f.coords.push.apply(f.coords, g);
            f.types.push("M");
            for (b = 2, a = g.length; b < a; b += 6) {
                f.types.push("C")
            }
        }
        if (!f.cursor) {
            f.cursor = []
        }
        f.cursor[0] = f.coords[f.coords.length - 2];
        f.cursor[1] = f.coords[f.coords.length - 1];
        f.dirt()
    },
    toStripes: function(k) {
        var q = k || [],
        r,
        p,
        n,
        b,
        a,
        g,
        f,
        e,
        d,
        h = this.types,
        o = this.coords,
        m = h.length;
        for (e = 0, d = 0; e < m; e++) {
            switch (h[e]) {
            case "M":
                r = [g = b = o[d++], f = a = o[d++]];
                q.push(r);
                break;
            case "L":
                p = o[d++];
                n = o[d++];
                r.push((b + b + p) / 3, (a + a + n) / 3, (b + p + p) / 3, (a + n + n) / 3, b = p, a = n);
                break;
            case "C":
                r.push(o[d++], o[d++], o[d++], o[d++], b = o[d++], a = o[d++]);
                break;
            case "Z":
                p = g;
                n = f;
                r.push((b + b + p) / 3, (a + a + n) / 3, (b + p + p) / 3, (a + n + n) / 3, b = p, a = n);
                break
            }
        }
        return q
    },
    updateSvgString: function() {
        var a = [],
        e = this.types,
        g = this.coords,
        f = e.length,
        d = 0,
        b = 0;
        for (; d < f; d++) {
            switch (e[d]) {
            case "M":
                a.push("M" + g[b] + "," + g[b + 1]);
                b += 2;
                break;
            case "L":
                a.push("L" + g[b] + "," + g[b + 1]);
                b += 2;
                break;
            case "C":
                a.push("C" + g[b] + "," + g[b + 1] + " " + g[b + 2] + "," + g[b + 3] + " " + g[b + 4] + "," + g[b + 5]);
                b += 6;
                break;
            case "Z":
                a.push("Z");
                break
            }
        }
        this.svgString = a.join("")
    },
    toString: function() {
        if (!this.svgString) {
            this.updateSvgString()
        }
        return this.svgString
    }
});
Ext.define("Ext.draw.sprite.Path", {
    extend: Ext.draw.sprite.Sprite,
    alias: "sprite.path",
    type: "path",
    inheritableStatics: {
        def: {
            processors: {
                path: function(b, a) {
                    if (! (b instanceof Ext.draw.Path)) {
                        b = new Ext.draw.Path(b)
                    }
                    return b
                }
            },
            aliases: {
                d: "path"
            },
            dirtyTriggers: {
                path: "bbox"
            },
            updaters: {
                path: function(a) {
                    var b = a.path;
                    if (!b || b.bindAttr !== a) {
                        b = new Ext.draw.Path();
                        b.bindAttr = a;
                        a.path = b
                    }
                    b.clear();
                    this.updatePath(b, a);
                    a.dirtyFlags.bbox = ["path"]
                }
            }
        }
    },
    updatePlainBBox: function(a) {
        if (this.attr.path) {
            this.attr.path.getDimension(a)
        }
    },
    updateTransformedBBox: function(a) {
        if (this.attr.path) {
            this.attr.path.getDimensionWithTransform(this.attr.matrix, a)
        }
    },
    render: function(b, d) {
        var e = this.attr.matrix,
        a = this.attr;
        if (!a.path || a.path.coords.length === 0) {
            return
        }
        e.toContext(d);
        d.appendPath(a.path);
        d.fillStroke(a)
    },
    updatePath: function(b, a) {}
});
Ext.define("Ext.draw.sprite.Ellipse", {
    extend: Ext.draw.sprite.Path,
    alias: "sprite.ellipse",
    type: "circle",
    inheritableStatics: {
        def: {
            processors: {
                cx: "number",
                cy: "number",
                rx: "number",
                ry: "number",
                axisRotation: "number"
            },
            aliases: {
                radius: "r",
                x: "cx",
                y: "cy",
                centerX: "cx",
                centerY: "cy",
                radiusX: "rx",
                radiusY: "ry"
            },
            defaults: {
                cx: 0,
                cy: 0,
                rx: 1,
                ry: 1,
                axisRotation: 0
            },
            dirtyTriggers: {
                cx: "path",
                cy: "path",
                rx: "path",
                ry: "path",
                axisRotation: "path"
            }
        }
    },
    updatePlainBBox: function(d) {
        var b = this.attr,
        a = b.cx,
        g = b.cy,
        f = b.rx,
        e = b.ry;
        d.x = a - f;
        d.y = g - e;
        d.width = f + f;
        d.height = e + e
    },
    updateTransformedBBox: function(e) {
        var j = this.attr,
        g = j.cx,
        f = j.cy,
        d = j.rx,
        b = j.ry,
        n = b / d,
        o = j.matrix.clone(),
        a,
        s,
        m,
        k,
        r,
        q,
        p,
        i;
        o.append(1, 0, 0, n, 0, f * (1 - n));
        a = o.getXX();
        m = o.getYX();
        r = o.getDX();
        s = o.getXY();
        k = o.getYY();
        q = o.getDY();
        p = Math.sqrt(a * a + m * m) * d;
        i = Math.sqrt(s * s + k * k) * d;
        e.x = g * a + f * m + r - p;
        e.y = g * s + f * k + q - i;
        e.width = p + p;
        e.height = i + i
    },
    updatePath: function(b, a) {
        b.ellipse(a.cx, a.cy, a.rx, a.ry, a.axisRotation, 0, Math.PI * 2, false)
    }
});
Ext.define("Ext.draw.sprite.EllipticalArc", {
    extend: Ext.draw.sprite.Ellipse,
    alias: "sprite.ellipticalArc",
    type: "ellipticalArc",
    inheritableStatics: {
        def: {
            processors: {
                startAngle: "number",
                endAngle: "number",
                anticlockwise: "bool"
            },
            aliases: {
                from: "startAngle",
                to: "endAngle",
                start: "startAngle",
                end: "endAngle"
            },
            defaults: {
                startAngle: 0,
                endAngle: Math.PI * 2,
                anticlockwise: false
            },
            dirtyTriggers: {
                startAngle: "path",
                endAngle: "path",
                anticlockwise: "path"
            }
        }
    },
    updatePath: function(b, a) {
        b.ellipse(a.cx, a.cy, a.rx, a.ry, a.axisRotation, a.startAngle, a.endAngle, a.anticlockwise)
    }
});
Ext.define("Ext.draw.sprite.Circle", {
    extend: Ext.draw.sprite.Path,
    alias: "sprite.circle",
    type: "circle",
    inheritableStatics: {
        def: {
            processors: {
                cx: "number",
                cy: "number",
                r: "number"
            },
            aliases: {
                radius: "r",
                x: "cx",
                y: "cy",
                centerX: "cx",
                centerY: "cy"
            },
            defaults: {
                cx: 0,
                cy: 0,
                r: 0
            },
            dirtyTriggers: {
                cx: "path",
                cy: "path",
                r: "path"
            }
        }
    },
    updatePlainBBox: function(d) {
        var b = this.attr,
        a = b.cx,
        f = b.cy,
        e = b.r;
        d.x = a - e;
        d.y = f - e;
        d.width = e + e;
        d.height = e + e
    },
    updateTransformedBBox: function(e) {
        var j = this.attr,
        g = j.cx,
        f = j.cy,
        a = j.r,
        k = j.matrix,
        d = k.getScaleX(),
        b = k.getScaleY(),
        m,
        i;
        m = d * a;
        i = b * a;
        e.x = k.x(g, f) - m;
        e.y = k.y(g, f) - i;
        e.width = m + m;
        e.height = i + i
    },
    updatePath: function(b, a) {
        b.arc(a.cx, a.cy, a.r, 0, Math.PI * 2, false)
    }
});
Ext.define("Ext.draw.TextMeasurer", {
    singleton: true,
    measureDiv: null,
    measureCache: {},
    actualMeasureText: function(h, b) {
        var f = Ext.draw.TextMeasurer,
        g = f.measureDiv,
        a = 100000,
        d;
        if (!g) {
            var e = Ext.Element.create({
                style: {
                    overflow: "hidden",
                    position: "relative",
                    "float": "left",
                    width: 0,
                    height: 0
                }
            });
            f.measureDiv = g = Ext.Element.create({});
            g.setStyle({
                position: "absolute",
                x: a,
                y: a,
                "z-index": -a,
                "white-space": "nowrap",
                display: "block",
                padding: 0,
                margin: 0
            });
            Ext.getBody().appendChild(e);
            e.appendChild(g)
        }
        if (b) {
            g.setStyle({
                font: b,
                lineHeight: "normal"
            })
        }
        g.setText("(" + h + ")");
        d = g.getSize();
        g.setText("()");
        d.width -= g.getSize().width;
        return d
    },
    measureTextSingleLine: function(j, e) {
        j = j.toString();
        var a = this.measureCache,
        h = j.split(""),
        d = 0,
        k = 0,
        n,
        b,
        f,
        g,
        m;
        if (!a[e]) {
            a[e] = {}
        }
        a = a[e];
        if (a[j]) {
            return a[j]
        }
        for (f = 0, g = h.length; f < g; f++) {
            b = h[f];
            if (! (n = a[b])) {
                m = this.actualMeasureText(b, e);
                n = a[b] = m
            }
            d += n.width;
            k = Math.max(k, n.height)
        }
        return a[j] = {
            width: d,
            height: k
        }
    },
    measureText: function(f, b) {
        var j = f.split("\n"),
        e = j.length,
        g = 0,
        a = 0,
        k,
        d,
        h;
        if (e === 1) {
            return this.measureTextSingleLine(f, b)
        }
        h = [];
        for (d = 0; d < e; d++) {
            k = this.measureTextSingleLine(j[d], b);
            h.push(k);
            g += k.height;
            a = Math.max(a, k.width)
        }
        return {
            width: a,
            height: g,
            sizes: h
        }
    }
});
Ext.define("Ext.draw.sprite.Text", {
    extend: Ext.draw.sprite.Sprite,
    alias: "sprite.text",
    type: "text",
    lineBreakRe: /\n/g,
    inheritableStatics: {
        shortHand1Re: /'(.*)'/g,
        shortHand2Re: / /g,
        shortHand3Re: /\s*,\s*/g,
        shortHand4Re: /\$\$\$\$/g,
        def: {
            processors: {
                x: "number",
                y: "number",
                text: "string",
                fontSize: function(a) {
                    if (!isNaN(a)) {
                        return + a + "px"
                    } else {
                        if (a.match(Ext.dom.Element.unitRe)) {
                            return a
                        }
                    }
                },
                fontStyle: "enums(,italic,oblique)",
                fontVariant: "enums(,small-caps)",
                fontWeight: (function(a) {
                    return function(b) {
                        if (!b) {
                            return ""
                        } else {
                            if (b === "normal") {
                                return ""
                            } else {
                                if (!isNaN(b)) {
                                    b = +b;
                                    if (100 <= b && b <= 900) {
                                        return b
                                    }
                                } else {
                                    if (b in a) {
                                        return b
                                    }
                                }
                            }
                        }
                    }
                })({
                    normal: true,
                    bold: true,
                    bolder: true,
                    lighter: true
                }),
                fontFamily: "string",
                textAlign: (function(a) {
                    return function(b) {
                        if (b === "middle") {
                            return "center"
                        } else {
                            if (!b) {
                                return "center"
                            } else {
                                if (!Ext.isString(b)) {
                                    return undefined
                                } else {
                                    if (b in a) {
                                        return b
                                    }
                                }
                            }
                        }
                    }
                })({
                    left: true,
                    right: true,
                    center: true,
                    start: true,
                    end: true
                }),
                textBaseline: (function(a) {
                    return function(b) {
                        if (b === false) {
                            return "alphabetic"
                        } else {
                            if (b in a) {
                                return b
                            } else {
                                if (b === "center") {
                                    return "middle"
                                }
                            }
                        }
                    }
                })({
                    top: true,
                    hanging: true,
                    middle: true,
                    alphabetic: true,
                    ideographic: true,
                    bottom: true
                }),
                font: "string"
            },
            aliases: {
                "font-size": "fontSize",
                "font-family": "fontFamily",
                "font-weight": "fontWeight",
                "font-variant": "fontVariant",
                "text-anchor": "textAlign"
            },
            defaults: {
                fontStyle: "",
                fontVariant: "",
                fontWeight: "",
                fontSize: "10px",
                fontFamily: "sans-serif",
                font: "10px sans-serif",
                textBaseline: "alphabetic",
                textAlign: "start",
                strokeStyle: "rgba(0, 0, 0, 0)",
                divBased: true,
                fillStyle: "#000",
                x: 0,
                y: 0,
                text: ""
            },
            dirtyTriggers: {
                fontStyle: "font,bbox",
                fontVariant: "font,bbox",
                fontWeight: "font,bbox",
                fontSize: "font,bbox",
                fontFamily: "font,bbox",
                font: "font-short-hand,bbox,canvas",
                textBaseline: "bbox",
                textAlign: "bbox",
                x: "bbox",
                y: "bbox",
                text: "bbox"
            },
            updaters: {
                "font-short-hand": (function(a) {
                    return function(d) {
                        var h = d.font,
                        j, b, e, g, f;
                        h = h.replace(Ext.draw.sprite.Text.shortHand1Re,
                        function(i, k) {
                            return k.replace(Ext.draw.sprite.Text.shortHand2Re, "$$$$")
                        });
                        h = h.replace(Ext.draw.sprite.Text.shortHand3Re, ",");
                        j = h.split(" ");
                        d = {};
                        for (e = 0, g = j.length; e < g; e++) {
                            b = j[e];
                            f = a[b];
                            if (f) {
                                d[f] = b
                            } else {
                                if (b.match(Ext.dom.Element.unitRe)) {
                                    d.fontSize = b
                                } else {
                                    d.fontFamily = b.replace(Ext.draw.sprite.Text.shortHand4Re, " ")
                                }
                            }
                        }
                        this.setAttributes(d, true)
                    }
                })({
                    italic: "fontStyles",
                    oblique: "fontStyles",
                    bold: "fontWeights",
                    bolder: "fontWeights",
                    lighter: "fontWeights",
                    "100": "fontWeights",
                    "200": "fontWeights",
                    "300": "fontWeights",
                    "400": "fontWeights",
                    "500": "fontWeights",
                    "600": "fontWeights",
                    "700": "fontWeights",
                    "800": "fontWeights",
                    "900": "fontWeights",
                    "small-caps": "fontVariant"
                }),
                font: function(b) {
                    var a = "";
                    if (b.fontWeight) {
                        a += b.fontWeight + " "
                    }
                    if (b.fontVariant) {
                        a += b.fontVariant + " "
                    }
                    if (b.fontSize) {
                        a += b.fontSize + " "
                    }
                    if (b.fontFamily) {
                        a += b.fontFamily + " "
                    }
                    this.setAttributes({
                        font: a.substr(0, a.length - 1)
                    },
                    true)
                }
            }
        }
    },
    constructor: function(a) {
        Ext.draw.sprite.Sprite.prototype.constructor.call(this, a)
    },
    updatePlainBBox: function(n) {
        var j = this,
        f = j.attr,
        m = f.x,
        k = f.y,
        s = [],
        b = f.font,
        p = f.text,
        e = f.textBaseline,
        h = f.textAlign,
        r = Ext.draw.TextMeasurer.measureText(p, b),
        q = r.sizes,
        o = r.height,
        a = r.width,
        g = q ? q.length: 0,
        d = 0;
        switch (e) {
        case "hanging":
        case "top":
            break;
        case "ideographic":
        case "bottom":
            k -= o;
            break;
        case "alphabetic":
            k -= o * 0.8;
            break;
        case "middle":
        case "center":
            k -= o * 0.5;
            break
        }
        switch (h) {
        case "end":
        case "right":
            m -= a;
            for (; d < g; d++) {
                s.push(a - q[d].width)
            }
            break;
        case "middle":
        case "center":
            m -= a * 0.5;
            for (; d < g; d++) {
                s.push((a - q[d].width) * 0.5)
            }
            break
        }
        f.textAlignOffsets = s;
        n.x = m;
        n.y = k;
        n.width = a;
        n.height = o
    },
    setText: function(a) {
        this.setAttributes({
            text: a
        },
        true)
    },
    setElementStyles: function(b, e) {
        var f = b.stylesCache || (b.stylesCache = {}),
        d = b.dom.style,
        a;
        for (a in e) {
            if (f[a] !== e[a]) {
                f[a] = d[a] = e[a]
            }
        }
    },
    render: function(a, j) {
        var d = this.attr,
        h = Ext.draw.Matrix.fly(d.matrix.elements.slice(0)),
        g = this.getBBox(true),
        m = d.textAlignOffsets,
        f,
        e,
        b,
        k;
        if (d.text.length === 0) {
            return
        }
        k = d.text.split("\n");
        f = d.bbox.plain.x;
        e = d.bbox.plain.y;
        h.toContext(j);
        for (b = 0; b < k.length; b++) {
            if (j.fillStyle !== "rgba(0, 0, 0, 0)") {
                j.fillText(k[b], f + (m[b] || 0), e + g.height / k.length * b)
            }
            if (j.strokeStyle !== "rgba(0, 0, 0, 0)") {
                j.strokeText(k[b], f + (m[b] || 0), e + g.height / k.length * b)
            }
        }
    }
});
Ext.define("Ext.draw.sprite.Sector", {
    extend: Ext.draw.sprite.Path,
    alias: "sprite.sector",
    type: "sector",
    inheritableStatics: {
        def: {
            processors: {
                centerX: "number",
                centerY: "number",
                startAngle: "number",
                endAngle: "number",
                startRho: "number",
                endRho: "number",
                margin: "number"
            },
            aliases: {
                rho: "endRho"
            },
            dirtyTriggers: {
                centerX: "path,bbox",
                centerY: "path,bbox",
                startAngle: "path,bbox",
                endAngle: "path,bbox",
                startRho: "path,bbox",
                endRho: "path,bbox",
                margin: "path,bbox"
            },
            defaults: {
                centerX: 0,
                centerY: 0,
                startAngle: 0,
                endAngle: 0,
                startRho: 0,
                endRho: 150,
                margin: 0,
                path: "M 0,0"
            }
        }
    },
    updatePath: function(k, i) {
        var h = Math.min(i.startAngle, i.endAngle),
        d = Math.max(i.startAngle, i.endAngle),
        b = (h + d) * 0.5,
        e = i.margin,
        g = i.centerX,
        f = i.centerY,
        j = Math.min(i.startRho, i.endRho),
        a = Math.max(i.startRho, i.endRho);
        if (e) {
            g += e * Math.cos(b);
            f += e * Math.sin(b)
        }
        k.moveTo(g + j * Math.cos(h), f + j * Math.sin(h));
        k.lineTo(g + a * Math.cos(h), f + a * Math.sin(h));
        k.arc(g, f, a, h, d, false);
        k.lineTo(g + j * Math.cos(d), f + j * Math.sin(d));
        k.arc(g, f, j, d, h, true)
    }
});
Ext.define("Ext.draw.sprite.Instancing", {
    extend: Ext.draw.sprite.Sprite,
    alias: "sprite.instancing",
    type: "instancing",
    config: {
        template: null
    },
    instances: null,
    constructor: function(a) {
        this.instances = [];
        this.callSuper([a]);
        if (a && a.template) {
            this.setTemplate(a.template)
        }
    },
    applyTemplate: function(a) {
        if (! (a instanceof Ext.draw.sprite.Sprite)) {
            a = Ext.create(a.xclass || "sprite." + a.type, a)
        }
        a.setParent(this);
        a.attr.children = [];
        this.instances = [];
        this.position = 0;
        return a
    },
    createInstance: function(e, g, h, d) {
        var f = this.getTemplate(),
        b = f.attr,
        a = Ext.Object.chain(b);
        f.topModifier.prepareAttributes(a);
        f.attr = a;
        f.setAttributes(e, h, d);
        a.data = g;
        this.instances.push(a);
        f.attr = b;
        this.position++;
        b.children.push(a);
        return a
    },
    getBBox: function() {
        return null
    },
    getBBoxFor: function(b, e) {
        var d = this.getTemplate(),
        a = d.attr,
        f;
        d.attr = this.instances[b];
        f = d.getBBox(e);
        d.attr = a;
        return f
    },
    render: function(b, n, e, j) {
        var h = this,
        m = h.attr.matrix,
        k = h.getTemplate(),
        d = k.attr,
        a = h.instances,
        f,
        g = h.position;
        m.toContext(n);
        k.preRender(b, n, e, j);
        k.useAttributes(n, j);
        for (f = 0; f < g; f++) {
            if (a[f].dirtyZIndex) {
                break
            }
        }
        for (f = 0; f < g; f++) {
            if (a[f].hidden) {
                continue
            }
            n.save();
            k.attr = a[f];
            k.applyTransformations();
            k.useAttributes(n, j);
            k.render(b, n, e, j);
            n.restore()
        }
        k.attr = d
    },
    setAttributesFor: function(d, f, g) {
        var e = this.getTemplate(),
        b = e.attr,
        a = this.instances[d];
        e.attr = a;
        try {
            if (g) {
                f = Ext.apply({},
                f)
            } else {
                f = e.self.def.normalize(f)
            }
            e.topModifier.pushDown(a, f);
            e.updateDirtyFlags(a)
        } finally {
            e.attr = b
        }
    },
    destroy: function() {
        this.callSuper();
        this.instances.length = 0;
        this.instances = null;
        if (this.getTemplate()) {
            this.getTemplate().destroy()
        }
    }
});
Ext.define("Ext.draw.sprite.Line", {
    extend: Ext.draw.sprite.Sprite,
    alias: "sprite.line",
    type: "line",
    inheritableStatics: {
        def: {
            processors: {
                fromX: "number",
                fromY: "number",
                toX: "number",
                toY: "number"
            },
            defaults: {
                fromX: 0,
                fromY: 0,
                toX: 1,
                toY: 1
            }
        }
    },
    render: function(b, d, f) {
        var a = this.attr,
        e = this.attr.matrix;
        e.toContext(d);
        d.beginPath();
        d.moveTo(a.fromX, a.fromY);
        d.lineTo(a.toX, a.toY);
        d.stroke()
    }
});
Ext.define("Ext.draw.sprite.Arc", {
    extend: Ext.draw.sprite.Circle,
    alias: "sprite.arc",
    type: "arc",
    inheritableStatics: {
        def: {
            processors: {
                startAngle: "number",
                endAngle: "number",
                anticlockwise: "bool"
            },
            aliases: {
                from: "startAngle",
                to: "endAngle",
                start: "startAngle",
                end: "endAngle"
            },
            defaults: {
                startAngle: 0,
                endAngle: Math.PI * 2,
                anticlockwise: false
            },
            dirtyTriggers: {
                startAngle: "path",
                endAngle: "path",
                anticlockwise: "path"
            }
        }
    },
    updatePath: function(b, a) {
        b.arc(a.cx, a.cy, a.r, a.startAngle, a.endAngle, a.anticlockwise)
    }
});
Ext.define("Ext.draw.sprite.Rect", {
    extend: Ext.draw.sprite.Path,
    alias: "sprite.rect",
    type: "rect",
    inheritableStatics: {
        def: {
            processors: {
                x: "number",
                y: "number",
                width: "number",
                height: "number",
                radius: "number"
            },
            aliases: {},
            dirtyTriggers: {
                x: "path",
                y: "path",
                width: "path",
                height: "path",
                radius: "path"
            },
            defaults: {
                x: 0,
                y: 0,
                width: 1,
                height: 1,
                radius: 0
            }
        }
    },
    updatePlainBBox: function(b) {
        var a = this.attr;
        b.x = a.x;
        b.y = a.y;
        b.width = a.width;
        b.height = a.height
    },
    updateTransformedBBox: function(a, b) {
        this.attr.matrix.transformBBox(b, this.attr.radius, a)
    },
    updatePath: function(g, e) {
        var d = e.x,
        h = e.y,
        f = e.width,
        b = e.height,
        a = Math.min(e.radius, Math.abs(e.height) * 0.5, Math.abs(e.width) * 0.5);
        if (a === 0) {
            g.rect(d, h, f, b)
        } else {
            g.moveTo(d + a, h);
            g.arcTo(d + f, h, d + f, h + b, a);
            g.arcTo(d + f, h + b, d, h + b, a);
            g.arcTo(d, h + b, d, h, a);
            g.arcTo(d, h, d + a, h, a)
        }
    }
});
Ext.define("Ext.draw.sprite.Image", {
    extend: Ext.draw.sprite.Rect,
    alias: "sprite.image",
    type: "image",
    statics: {
        imageLoaders: {}
    },
    inheritableStatics: {
        def: {
            processors: {
                src: "string"
            },
            defaults: {
                src: "",
                width: null,
                height: null
            }
        }
    },
    render: function(d, p) {
        var j = this,
        h = j.attr,
        o = h.matrix,
        a = h.src,
        m = h.x,
        k = h.y,
        b = h.width,
        n = h.height,
        g = Ext.draw.sprite.Image.imageLoaders[a],
        f,
        e;
        if (g && g.done) {
            o.toContext(p);
            p.drawImage(g.image, m, k, b || g.width, n || g.width)
        } else {
            if (!g) {
                f = new Image();
                g = Ext.draw.sprite.Image.imageLoaders[a] = {
                    image: f,
                    done: false,
                    pendingSprites: [j],
                    pendingSurfaces: [d]
                };
                f.width = b;
                f.height = n;
                f.onload = function() {
                    if (!g.done) {
                        g.done = true;
                        for (e = 0; e < g.pendingSprites.length; e++) {
                            g.pendingSprites[e].setDirty(true)
                        }
                        for (e in g.pendingSurfaces) {
                            g.pendingSurfaces[e].renderFrame()
                        }
                    }
                };
                f.src = a
            } else {
                Ext.Array.include(g.pendingSprites, j);
                Ext.Array.include(g.pendingSurfaces, d)
            }
        }
    }
});
Ext.define("Ext.draw.sprite.Composite", {
    extend: Ext.draw.sprite.Sprite,
    alias: "sprite.composite",
    type: "composite",
    constructor: function() {
        this.callSuper(arguments);
        this.sprites = [];
        this.sprites.map = {}
    },
    add: function(d) {
        if (! (d instanceof Ext.draw.sprite.Sprite)) {
            d = Ext.create("sprite." + d.type, d);
            d.setParent(this)
        }
        var b = d.applyTransformations,
        e = this,
        a = e.attr;
        d.applyTransformations = function() {
            if (d.attr.dirtyTransform) {
                a.dirtyTransform = true;
                a.bbox.plain.dirty = true;
                a.bbox.transform.dirty = true
            }
            b.call(d)
        };
        this.sprites.push(d);
        this.sprites.map[d.id] = d.getId();
        a.bbox.plain.dirty = true;
        a.bbox.transform.dirty = true;
        return d
    },
    updatePlainBBox: function(h) {
        var f = this,
        b = Infinity,
        j = -Infinity,
        g = Infinity,
        a = -Infinity,
        k, m, d, e;
        for (d = 0, e = f.sprites.length; d < e; d++) {
            k = f.sprites[d];
            k.applyTransformations();
            m = k.getBBox();
            if (b > m.x) {
                b = m.x
            }
            if (j < m.x + m.width) {
                j = m.x + m.width
            }
            if (g > m.y) {
                g = m.y
            }
            if (a < m.y + m.height) {
                a = m.y + m.height
            }
        }
        h.x = b;
        h.y = g;
        h.width = j - b;
        h.height = a - g
    },
    render: function(a, b, g) {
        var e = this.attr.matrix,
        d, f;
        e.toContext(b);
        for (d = 0, f = this.sprites.length; d < f; d++) {
            a.renderSprite(this.sprites[d], g)
        }
    }
});
Ext.define("Ext.draw.gradient.Radial", {
    extend: Ext.draw.gradient.Gradient,
    type: "radial",
    config: {
        start: {
            x: 0,
            y: 0,
            r: 0
        },
        end: {
            x: 0,
            y: 0,
            r: 1
        }
    },
    applyStart: function(a, b) {
        if (!b) {
            return a
        }
        var d = {
            x: b.x,
            y: b.y,
            r: b.r
        };
        if ("x" in a) {
            d.x = a.x
        } else {
            if ("centerX" in a) {
                d.x = a.centerX
            }
        }
        if ("y" in a) {
            d.y = a.y
        } else {
            if ("centerY" in a) {
                d.y = a.centerY
            }
        }
        if ("r" in a) {
            d.r = a.r
        } else {
            if ("radius" in a) {
                d.r = a.radius
            }
        }
        return d
    },
    applyEnd: function(b, a) {
        if (!a) {
            return b
        }
        var d = {
            x: a.x,
            y: a.y,
            r: a.r
        };
        if ("x" in b) {
            d.x = b.x
        } else {
            if ("centerX" in b) {
                d.x = b.centerX
            }
        }
        if ("y" in b) {
            d.y = b.y
        } else {
            if ("centerY" in b) {
                d.y = b.centerY
            }
        }
        if ("r" in b) {
            d.r = b.r
        } else {
            if ("radius" in b) {
                d.r = b.radius
            }
        }
        return d
    },
    generateGradient: function(p, o) {
        var a = this.getStart(),
        b = this.getEnd(),
        m = o.width * 0.5,
        e = o.height * 0.5,
        k = o.x + m,
        g = o.y + e,
        j = p.createRadialGradient(k + a.x * m, g + a.y * e, a.r * Math.max(m, e), k + b.x * m, g + b.y * e, b.r * Math.max(m, e)),
        n = this.getStops(),
        f = n.length,
        d;
        for (d = 0; d < f; d++) {
            j.addColorStop(n[d].offset, n[d].color)
        }
        return j
    }
});
Ext.define("Ext.draw.gradient.Linear", {
    extend: Ext.draw.gradient.Gradient,
    type: "linear",
    config: {
        degrees: 0
    },
    setAngle: function(a) {
        this.setDegrees(a)
    },
    updateDegrees: function() {
        this.clearCache()
    },
    updateStops: function() {
        this.clearCache()
    },
    generateGradient: function(r, p) {
        var d = Ext.draw.Draw.rad(this.getDegrees()),
        q = Math.cos(d),
        k = Math.sin(d),
        n = p.width,
        g = p.height,
        e = p.x + n * 0.5,
        b = p.y + g * 0.5,
        o = this.getStops(),
        j = o.length,
        m,
        a,
        f;
        if (!isNaN(e) && !isNaN(b) && g > 0 && n > 0) {
            a = (Math.sqrt(g * g + n * n) * Math.abs(Math.cos(d - Math.atan(g / n)))) / 2;
            m = r.createLinearGradient(e + q * a, b + k * a, e - q * a, b - k * a);
            for (f = 0; f < j; f++) {
                m.addColorStop(o[f].offset, o[f].color)
            }
            return m
        }
        return "none"
    }
});
Ext.define("Ext.draw.Matrix", {
    statics: {
        createAffineMatrixFromTwoPair: function(h, u, g, t, k, p, i, j) {
            var y = g - h,
            v = t - u,
            e = i - k,
            s = j - p,
            d = 1 / (y * y + v * v),
            q = y * e + v * s,
            o = e * v - y * s,
            n = -q * h - o * u,
            m = o * h - q * u;
            return new this(q * d, -o * d, o * d, q * d, n * d + k, m * d + p)
        },
        createPanZoomFromTwoPair: function(t, f, s, d, i, u, p, h) {
            if (arguments.length === 2) {
                return this.createPanZoomFromTwoPair.apply(this, t.concat(f))
            }
            var m = s - t,
            k = d - f,
            e = (t + s) * 0.5,
            b = (f + d) * 0.5,
            q = p - i,
            a = h - u,
            g = (i + p) * 0.5,
            n = (u + h) * 0.5,
            o = m * m + k * k,
            j = q * q + a * a,
            v = Math.sqrt(j / o);
            return new this(v, 0, 0, v, g - v * e, n - v * b)
        },
        fly: (function() {
            var a = null,
            b = function(d) {
                a.elements = d;
                return a
            };
            return function(d) {
                if (!a) {
                    a = new Ext.draw.Matrix()
                }
                a.elements = d;
                Ext.draw.Matrix.fly = b;
                return a
            }
        })(),
        create: function(a) {
            if (a instanceof this) {
                return a
            }
            return new this(a)
        }
    },
    constructor: function(f, e, a, g, d, b) {
        if (f && f.length === 6) {
            this.elements = f.slice()
        } else {
            if (f !== undefined) {
                this.elements = [f, e, a, g, d, b]
            } else {
                this.elements = [1, 0, 0, 1, 0, 0]
            }
        }
    },
    prepend: function(a, n, i, h, o, m) {
        var b = this.elements,
        e = b[0],
        k = b[1],
        f = b[2],
        d = b[3],
        j = b[4],
        g = b[5];
        b[0] = a * e + i * k;
        b[1] = n * e + h * k;
        b[2] = a * f + i * d;
        b[3] = n * f + h * d;
        b[4] = a * j + i * g + o;
        b[5] = n * j + h * g + m;
        return this
    },
    prependMatrix: function(a) {
        return this.prepend.apply(this, a.elements)
    },
    append: function(a, n, i, h, o, m) {
        var b = this.elements,
        e = b[0],
        k = b[1],
        f = b[2],
        d = b[3],
        j = b[4],
        g = b[5];
        b[0] = a * e + n * f;
        b[1] = a * k + n * d;
        b[2] = i * e + h * f;
        b[3] = i * k + h * d;
        b[4] = o * e + m * f + j;
        b[5] = o * k + m * d + g;
        return this
    },
    appendMatrix: function(a) {
        return this.append.apply(this, a.elements)
    },
    set: function(g, f, a, h, d, b) {
        var e = this.elements;
        e[0] = g;
        e[1] = f;
        e[2] = a;
        e[3] = h;
        e[4] = d;
        e[5] = b;
        return this
    },
    inverse: function(i) {
        var g = this.elements,
        p = g[0],
        n = g[1],
        m = g[2],
        k = g[3],
        j = g[4],
        h = g[5],
        o = 1 / (p * k - n * m);
        p *= o;
        n *= o;
        m *= o;
        k *= o;
        if (i) {
            i.set(k, -n, -m, p, m * h - k * j, n * j - p * h);
            return i
        } else {
            return new Ext.draw.Matrix(k, -n, -m, p, m * h - k * j, n * j - p * h)
        }
    },
    translate: function(a, d, b) {
        if (b) {
            return this.prepend(1, 0, 0, 1, a, d)
        } else {
            return this.append(1, 0, 0, 1, a, d)
        }
    },
    scale: function(g, f, d, a, b) {
        var e = this;
        if (f == null) {
            f = g
        }
        if (d === undefined) {
            d = 0
        }
        if (a === undefined) {
            a = 0
        }
        if (b) {
            return e.prepend(g, 0, 0, f, d - d * g, a - a * f)
        } else {
            return e.append(g, 0, 0, f, d - d * g, a - a * f)
        }
    },
    rotate: function(h, f, d, b) {
        var e = this,
        g = Math.cos(h),
        a = Math.sin(h);
        f = f || 0;
        d = d || 0;
        if (b) {
            return e.prepend(g, a, -a, g, f - g * f + d * a, d - g * d - f * a)
        } else {
            return e.append(g, a, -a, g, f - g * f + d * a, d - g * d - f * a)
        }
    },
    rotateFromVector: function(a, i, e) {
        var f = this,
        h = Math.sqrt(a * a + i * i),
        g = a / h,
        b = i / h;
        if (e) {
            return f.prepend(g, b, -b, g, 0, 0)
        } else {
            return f.append(g, b, -b, g, 0, 0)
        }
    },
    clone: function() {
        return new Ext.draw.Matrix(this.elements)
    },
    flipX: function() {
        return this.append( - 1, 0, 0, 1, 0, 0)
    },
    flipY: function() {
        return this.append(1, 0, 0, -1, 0, 0)
    },
    skewX: function(a) {
        return this.append(1, Math.tan(a), 0, -1, 0, 0)
    },
    skewY: function(a) {
        return this.append(1, 0, Math.tan(a), -1, 0, 0)
    },
    reset: function() {
        return this.set(1, 0, 0, 1, 0, 0)
    },
    precisionCompensate: function(k, h) {
        var d = this.elements,
        g = d[0],
        f = d[1],
        j = d[2],
        i = d[3],
        e = d[4],
        b = d[5],
        a = f * j - g * i;
        h.b = k * f / g;
        h.c = k * j / i;
        h.d = k;
        h.xx = g / k;
        h.yy = i / k;
        h.dx = (b * g * j - e * g * i) / a / k;
        h.dy = (e * f * i - b * g * i) / a / k
    },
    precisionCompensateRect: function(k, h) {
        var b = this.elements,
        g = b[0],
        f = b[1],
        j = b[2],
        i = b[3],
        d = b[4],
        a = b[5],
        e = j / g;
        h.b = k * f / g;
        h.c = k * e;
        h.d = k * i / g;
        h.xx = g / k;
        h.yy = g / k;
        h.dx = (a * j - d * i) / (f * e - i) / k;
        h.dy = -(a * g - d * f) / (f * e - i) / k
    },
    x: function(a, d) {
        var b = this.elements;
        return a * b[0] + d * b[2] + b[4]
    },
    y: function(a, d) {
        var b = this.elements;
        return a * b[1] + d * b[3] + b[5]
    },
    get: function(b, a) {
        return + this.elements[b + a * 2].toFixed(4)
    },
    transformPoint: function(a) {
        var b = this.elements;
        return [a[0] * b[0] + a[1] * b[2] + b[4], a[0] * b[1] + a[1] * b[3] + b[5]]
    },
    transformBBox: function(r, j, k) {
        var b = this.elements,
        e = r.x,
        s = r.y,
        i = r.width * 0.5,
        p = r.height * 0.5,
        a = b[0],
        u = b[1],
        o = b[2],
        m = b[3],
        f = e + i,
        d = s + p,
        q,
        g,
        n;
        if (j) {
            i -= j;
            p -= j;
            n = [Math.sqrt(b[0] * b[0] + b[2] * b[2]), Math.sqrt(b[1] * b[1] + b[3] * b[3])];
            q = Math.abs(i * a) + Math.abs(p * o) + Math.abs(n[0] * j);
            g = Math.abs(i * u) + Math.abs(p * m) + Math.abs(n[1] * j)
        } else {
            q = Math.abs(i * a) + Math.abs(p * o);
            g = Math.abs(i * u) + Math.abs(p * m)
        }
        if (!k) {
            k = {}
        }
        k.x = f * a + d * o + b[4] - q;
        k.y = f * u + d * m + b[5] - g;
        k.width = q + q;
        k.height = g + g;
        return k
    },
    transformList: function(f) {
        var b = this.elements,
        a = b[0],
        j = b[2],
        n = b[4],
        m = b[1],
        h = b[3],
        k = b[5],
        g = f.length,
        d,
        e;
        for (e = 0; e < g; e++) {
            d = f[e];
            f[e] = [d[0] * a + d[1] * j + n, d[0] * m + d[1] * h + k]
        }
        return f
    },
    isIdentity: function() {
        var a = this.elements;
        return a[0] === 1 && a[1] === 0 && a[2] === 0 && a[3] === 1 && a[4] === 0 && a[5] === 0
    },
    equals: function(a) {
        var d = this.elements,
        b = a.elements;
        return d[0] === b[0] && d[1] === b[1] && d[2] === b[2] && d[3] === b[3] && d[4] === b[4] && d[5] === b[5]
    },
    toArray: function() {
        var a = this.elements;
        return [a[0], a[2], a[4], a[1], a[3], a[5]]
    },
    toVerticalArray: function() {
        return this.elements.slice()
    },
    toString: function() {
        var a = this;
        return [a.get(0, 0), a.get(0, 1), a.get(1, 0), a.get(1, 1), a.get(2, 0), a.get(2, 1)].join(",")
    },
    toContext: function(a) {
        a.transform.apply(a, this.elements);
        return this
    },
    toSvg: function() {
        var a = this.elements;
        return "matrix(" + a[0].toFixed(9) + "," + a[1].toFixed(9) + "," + a[2].toFixed(9) + "," + a[3].toFixed(9) + "," + a[4].toFixed(9) + "," + a[5].toFixed(9) + ")"
    },
    getScaleX: function() {
        var a = this.elements;
        return Math.sqrt(a[0] * a[0] + a[2] * a[2])
    },
    getScaleY: function() {
        var a = this.elements;
        return Math.sqrt(a[1] * a[1] + a[3] * a[3])
    },
    getXX: function() {
        return this.elements[0]
    },
    getXY: function() {
        return this.elements[1]
    },
    getYX: function() {
        return this.elements[2]
    },
    getYY: function() {
        return this.elements[3]
    },
    getDX: function() {
        return this.elements[4]
    },
    getDY: function() {
        return this.elements[5]
    },
    split: function() {
        var d = this.elements,
        f = d[0],
        e = d[1],
        a = d[2],
        g = d[3],
        b = {
            translateX: d[4],
            translateY: d[5]
        };
        b.scaleX = Math.sqrt(f * f + a * a);
        b.shear = (f * e + a * g) / b.scaleX;
        e -= b.shear * f;
        g -= b.shear * a;
        b.scaleY = Math.sqrt(e * e + g * g);
        b.shear /= b.scaleY;
        b.rotation = -Math.atan2(a / b.scaleX, e / b.scaleY);
        b.isSimple = Math.abs(b.shear) < 1e-9 && (!b.rotation || Math.abs(b.scaleX - b.scaleY) < 1e-9);
        return b
    }
},
function() {
    function b(f, d, e) {
        f[d] = {
            get: function() {
                return this.elements[e]
            },
            set: function(g) {
                this.elements[e] = g
            }
        }
    }
    if (Object.defineProperties) {
        var a = {};
        b(a, "a", 0);
        b(a, "b", 1);
        b(a, "c", 2);
        b(a, "d", 3);
        b(a, "e", 4);
        b(a, "f", 5);
        Object.defineProperties(this.prototype, a)
    }
    this.prototype.multiply = this.prototype.appendMatrix
});
Ext.define("Ext.draw.Group", {
    mixins: {
        observable: Ext.mixin.Observable
    },
    config: {
        surface: null
    },
    statics: {
        createRelayEvent: function(a) {
            return (function(b) {
                this.fireEvent(a, b)
            })
        },
        createDispatcherMethod: function(a) {
            return function() {
                var d = Array.prototype.slice.call(arguments, 0),
                b = this.items,
                e = 0,
                g = b.length,
                f;
                while (e < g) {
                    f = b[e++];
                    f[a].apply(f, d)
                }
            }
        }
    },
    autoDestroy: false,
    constructor: function(a) {
        this.initConfig(a);
        this.map = {};
        this.items = [];
        this.length = 0
    },
    add: function(b) {
        var d = b.getId(),
        a = this.map[d];
        if (!a) {
            b.group.push(this.id);
            this.map[d] = b;
            this.items.push(b);
            this.length++
        } else {
            if (b !== a) {
                Ext.Logger.error("Sprite with duplicated id.")
            }
        }
    },
    remove: function(b, d) {
        var e = b.getId(),
        a = this.map[e];
        d = d || this.autoDestroy;
        if (a) {
            if (a === b) {
                delete this.map[e];
                this.length--;
                Ext.Array.remove(this.items, b);
                if (d) {
                    a.destroy()
                } else {
                    Ext.Array.remove(b.group, this)
                }
            } else {
                if (b !== a) {
                    Ext.Logger.error("Sprite with duplicated id.")
                }
            }
        }
    },
    addAll: function(b) {
        if (b.isSprite) {
            this.add(b)
        } else {
            if (Ext.isArray(b)) {
                var a = 0;
                while (a < b.length) {
                    this.add(b[a++])
                }
            }
        }
    },
    each: function(d) {
        var b = 0,
        a = this.items,
        e = a.length;
        while (b < e) {
            if (false === d(a[b])) {
                return
            }
        }
    },
    clear: function(f) {
        var d, e, b, a;
        if (f || this.autoDestroy) {
            a = this.items.slice(0);
            for (d = 0, e = a.length; d < e; d++) {
                a[d].destroy()
            }
        } else {
            a = this.items.slice(0);
            for (d = 0, e = a.length; d < e; d++) {
                b = a[d];
                Ext.Array.remove(b.group, this)
            }
        }
        this.length = 0;
        this.map = {};
        this.items.length = 0
    },
    getAt: function(a) {
        return this.items[a]
    },
    get: function(a) {
        return this.map[a] || this.items[a]
    },
    destroy: function() {
        this.clear();
        this.getSurface().getGroups().remove(this)
    }
},
function() {
    this.addMembers({
        setAttributes: this.createDispatcherMethod("setAttributes"),
        show: this.createDispatcherMethod("show"),
        hide: this.createDispatcherMethod("hide"),
        setDirty: this.createDispatcherMethod("setDirty"),
        getBBox: function(e) {
            if (this.length === 0) {
                return {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                }
            }
            var g, j, d = Infinity,
            h = -Infinity,
            f = Infinity,
            a = -Infinity,
            k;
            for (g = 0, j = this.items.length; g < j; g++) {
                k = this.items[g].getBBox(e);
                if (!k) {
                    continue
                }
                if (k.x + k.width > h) {
                    h = k.x + k.width
                }
                if (k.x < d) {
                    d = k.x
                }
                if (k.y + k.height > a) {
                    a = k.y + k.height
                }
                if (k.y < f) {
                    f = k.y
                }
            }
            return {
                x: d,
                y: f,
                height: a - f,
                width: h - d
            }
        }
    })
});
Ext.define("Ext.draw.Surface", {
    extend: Ext.Component,
    xtype: "surface",
    defaultIdPrefix: "ext-surface-",
    devicePixelRatio: window.devicePixelRatio || 1,
    statics: {
        stableSort: function(g) {
            if (g.length < 2) {
                return
            }
            var f = {},
            b, a = [],
            d,
            e,
            h;
            for (d = 0, e = g.length; d < e; d++) {
                h = g[d].attr.zIndex;
                if (!f[h]) {
                    f[h] = [g[d]]
                } else {
                    f[h].push(g[d])
                }
            }
            b = Ext.Object.getKeys(f).sort(function(j, i) {
                return j - i
            });
            for (d = 0, e = b.length; d < e; d++) {
                a.push.apply(a, f[b[d]])
            }
            for (d = 0, e = g.length; d < e; d++) {
                g[d] = a[d]
            }
        }
    },
    config: {
        region: null,
        background: null,
        items: [],
        groups: [],
        dirty: false
    },
    dirtyPredecessor: 0,
    constructor: function(a) {
        var b = this;
        b.predecessors = [];
        b.successors = [];
        b.pendingRenderFrame = false;
        b.callSuper([a]);
        b.matrix = new Ext.draw.Matrix();
        b.inverseMatrix = b.matrix.inverse(b.inverseMatrix);
        b.resetTransform()
    },
    roundPixel: function(a) {
        return Math.round(this.devicePixelRatio * a) / this.devicePixelRatio
    },
    waitFor: function(a) {
        var b = this,
        d = b.predecessors;
        if (!Ext.Array.contains(d, a)) {
            d.push(a);
            a.successors.push(b);
            if (a._dirty) {
                b.dirtyPredecessor++
            }
        }
    },
    setDirty: function(e) {
        if (this._dirty !== e) {
            var d = this.successors,
            a, b, f = d.length;
            for (b = 0; b < f; b++) {
                a = d[b];
                if (e) {
                    a.dirtyPredecessor++;
                    a.setDirty(true)
                } else {
                    a.dirtyPredecessor--;
                    if (a.dirtyPredecessor === 0 && a.pendingRenderFrame) {
                        a.renderFrame()
                    }
                }
            }
            this._dirty = e
        }
    },
    applyElement: function(b, a) {
        if (a) {
            a.set(b)
        } else {
            a = Ext.Element.create(b)
        }
        this.setDirty(true);
        return a
    },
    applyBackground: function(a, b) {
        this.setDirty(true);
        if (Ext.isString(a)) {
            a = {
                fillStyle: a
            }
        }
        return Ext.factory(a, Ext.draw.sprite.Rect, b)
    },
    applyRegion: function(b, a) {
        if (a && b[0] === a[0] && b[1] === a[1] && b[2] === a[2] && b[3] === a[3]) {
            return
        }
        if (Ext.isArray(b)) {
            return [b[0], b[1], b[2], b[3]]
        } else {
            if (Ext.isObject(b)) {
                return [b.x || b.left, b.y || b.top, b.width || (b.right - b.left), b.height || (b.bottom - b.top)]
            }
        }
    },
    updateRegion: function(j) {
        var i = this,
        d = j[0],
        g = j[1],
        h = d + j[2],
        a = g + j[3],
        f = this.getBackground(),
        e = i.element;
        e.setBox({
            top: Math.floor(g),
            left: Math.floor(d),
            width: Math.ceil(h - Math.floor(d)),
            height: Math.ceil(a - Math.floor(g))
        });
        if (f) {
            f.setAttributes({
                x: 0,
                y: 0,
                width: Math.ceil(h - Math.floor(d)),
                height: Math.ceil(a - Math.floor(g))
            })
        }
        i.setDirty(true)
    },
    resetTransform: function() {
        this.matrix.set(1, 0, 0, 1, 0, 0);
        this.inverseMatrix.set(1, 0, 0, 1, 0, 0);
        this.setDirty(true)
    },
    updateComponent: function(a, b) {
        if (a) {
            a.element.dom.appendChild(this.element.dom)
        }
    },
    add: function() {
        var j = this,
        g = Array.prototype.slice.call(arguments),
        n = Ext.isArray(g[0]),
        b = [],
        m,
        f,
        h,
        d,
        e,
        k,
        a;
        h = Ext.Array.clean(n ? g[0] : g);
        f = j.prepareItems(h);
        for (d = 0, e = f.length; d < e; d++) {
            m = f[d];
            a = m.group;
            if (a.length) {
                for (d = 0, e = a.length; d < e; d++) {
                    k = a[d];
                    j.getGroup(k).add(m)
                }
            }
            j.getItems().add(m);
            b.push(m);
            m.setParent(this);
            j.onAdd(m)
        }
        j.dirtyZIndex = true;
        j.setDirty(true);
        if (!n && b.length === 1) {
            return b[0]
        } else {
            return b
        }
    },
    onAdd: Ext.emptyFn,
    remove: function(a, b) {
        if (a) {
            if (b === true) {
                a.destroy()
            } else {
                this.getGroups().each(function(d) {
                    d.remove(a)
                });
                this.getItems().remove(a)
            }
            this.dirtyZIndex = true;
            this.setDirty(true)
        }
    },
    removeAll: function() {
        this.getItems().clear();
        this.dirtyZIndex = true
    },
    applyItems: function(b, d) {
        var a;
        if (b instanceof Ext.draw.Group) {
            a = b
        } else {
            a = new Ext.draw.Group({
                surface: this
            });
            a.autoDestroy = true;
            a.addAll(this.prepareItems(b))
        }
        this.setDirty(true);
        return a
    },
    prepareItems: function(a) {
        a = [].concat(a);
        var h = this,
        g, d, f, b, e = function(i) {
            this.remove(i, false)
        };
        for (d = 0, f = a.length; d < f; d++) {
            g = a[d];
            if (! (g instanceof Ext.draw.sprite.Sprite)) {
                g = a[d] = h.createItem(g)
            }
            for (b = 0; b < g.group.length; b++) {
                h.getGroup(g.group[b]).add(g)
            }
            g.on("beforedestroy", e, h)
        }
        return a
    },
    applyGroups: function(b, d) {
        var a;
        if (b instanceof Ext.util.MixedCollection) {
            a = b
        } else {
            a = new Ext.util.MixedCollection();
            a.addAll(b)
        }
        if (d) {
            d.each(function(e) {
                if (!a.contains()) {
                    e.destroy()
                }
            });
            d.destroy()
        }
        this.setDirty(true);
        return a
    },
    getGroup: function(b) {
        var a;
        if (typeof b === "string") {
            a = this.getGroups().get(b);
            if (!a) {
                a = this.createGroup(b)
            }
        } else {
            a = b
        }
        return a
    },
    createGroup: function(b) {
        var a = this.getGroups().get(b);
        if (!a) {
            a = new Ext.draw.Group({
                surface: this
            });
            a.id = b || Ext.id(null, "ext-surface-group-");
            this.getGroups().add(a)
        }
        this.setDirty(true);
        return a
    },
    removeGroup: function(a) {
        if (Ext.isString(a)) {
            a = this.getGroups().get(a)
        }
        if (a) {
            this.getGroups().remove(a);
            a.destroy()
        }
        this.setDirty(true)
    },
    createItem: function(a) {
        var b = Ext.create(a.xclass || "sprite." + a.type, a);
        return b
    },
    getBBox: function(a, b) {
        return a.getBBox(b)
    },
    clear: Ext.emptyFn,
    orderByZIndex: function() {
        var e = this,
        a = e.getItems().items,
        f = false,
        b,
        d;
        if (e.getDirty()) {
            for (b = 0, d = a.length; b < d; b++) {
                if (a[b].attr.dirtyZIndex) {
                    f = true;
                    break
                }
            }
            if (f) {
                Ext.draw.Surface.stableSort(a);
                this.setDirty(true)
            }
            for (b = 0, d = a.length; b < d; b++) {
                a[b].attr.dirtyZIndex = false
            }
        }
    },
    repaint: function() {
        var a = this;
        a.repaint = Ext.emptyFn;
        setTimeout(function() {
            delete a.repaint;
            a.element.repaint()
        },
        1)
    },
    renderFrame: function() {
        if (!this.element) {
            return
        }
        if (this.dirtyPredecessor > 0) {
            this.pendingRenderFrame = true
        }
        var g = this,
        h = this.getRegion(),
        d = g.getBackground(),
        a = g.getItems().items,
        f,
        b,
        e;
        if (!h) {
            return
        }
        g.orderByZIndex();
        if (g.getDirty()) {
            g.clear();
            g.clearTransform();
            if (d) {
                g.renderSprite(d)
            }
            for (b = 0, e = a.length; b < e; b++) {
                f = a[b];
                if (false === g.renderSprite(f)) {
                    return
                }
                f.attr.textPositionCount = g.textPosition
            }
            g.setDirty(false)
        }
    },
    renderSprite: Ext.emptyFn,
    clearTransform: Ext.emptyFn,
    getDirty: function() {
        return this._dirty
    },
    destroy: function() {
        var a = this;
        a.removeAll();
        a.setBackground(null);
        a.setGroups([]);
        a.getGroups().destroy();
        a.predecessors = null;
        a.successors = null;
        a.callSuper()
    }
});
Ext.define("Ext.draw.engine.Canvas", {
    extend: Ext.draw.Surface,
    config: {
        highPrecision: false
    },
    statics: {
        contextOverrides: {
            setGradientBBox: function(a) {
                this.bbox = a
            },
            fill: function() {
                var d = this.fillStyle,
                a = this.fillGradient,
                b = this.fillOpacity,
                e = "rgba(0, 0, 0, 0)",
                f = "rgba(0, 0, 0, 0.0)",
                h = this.bbox,
                g = this.globalAlpha;
                if (d !== e && d !== f && b !== 0) {
                    if (a && h) {
                        this.fillStyle = a.getGradient(this, h)
                    }
                    if (b !== 1) {
                        this.globalAlpha = g * b
                    }
                    this.$fill();
                    if (b !== 1) {
                        this.globalAlpha = g
                    }
                    if (a && h) {
                        this.fillStyle = d
                    }
                }
            },
            stroke: function() {
                var h = this.strokeStyle,
                f = this.strokeGradient,
                b = this.strokeOpacity,
                a = "rgba(0, 0, 0, 0)",
                d = "rgba(0, 0, 0, 0.0)",
                g = this.bbox,
                e = this.globalAlpha;
                if (h !== a && h !== d && b !== 0) {
                    if (f && g) {
                        this.strokeStyle = f.getGradient(this, g)
                    }
                    if (b !== 1) {
                        this.globalAlpha = e * b
                    }
                    this.$stroke();
                    if (b !== 1) {
                        this.globalAlpha = e
                    }
                    if (f && g) {
                        this.strokeStyle = h
                    }
                }
            },
            fillStroke: function(f, h) {
                var m = this,
                k = this.fillStyle,
                j = this.fillOpacity,
                i = this.strokeStyle,
                e = this.strokeOpacity,
                d = m.shadowColor,
                b = m.shadowBlur,
                a = "rgba(0, 0, 0, 0)",
                g = "rgba(0, 0, 0, 0.0)";
                if (h === undefined) {
                    h = f.transformFillStroke
                }
                if (!h) {
                    f.inverseMatrix.toContext(m)
                }
                if (k !== a && k !== g && j !== 0) {
                    m.fill();
                    m.shadowColor = "rgba(0,0,0,0)";
                    m.shadowBlur = 0
                }
                if (i !== a && i !== g && e !== 0) {
                    m.stroke()
                }
                m.shadowColor = d;
                m.shadowBlur = b
            },
            ellipse: function(h, f, d, a, k, b, g, e) {
                var j = Math.cos(k),
                i = Math.sin(k);
                this.transform(j * d, i * d, -i * a, j * a, h, f);
                this.arc(0, 0, 1, b, g, e);
                this.transform(j / d, -i / a, i / d, j / a, -(j * h + i * f) / d, (i * h - j * f) / a)
            },
            appendPath: function(h) {
                var f = this,
                d = 0,
                a = 0,
                b = h.types,
                g = h.coords,
                e = h.types.length;
                f.beginPath();
                for (; d < e; d++) {
                    switch (b[d]) {
                    case "M":
                        f.moveTo(g[a], g[a + 1]);
                        a += 2;
                        break;
                    case "L":
                        f.lineTo(g[a], g[a + 1]);
                        a += 2;
                        break;
                    case "C":
                        f.bezierCurveTo(g[a], g[a + 1], g[a + 2], g[a + 3], g[a + 4], g[a + 5]);
                        a += 6;
                        break;
                    case "Z":
                        f.closePath();
                        break
                    }
                }
            }
        }
    },
    splitThreshold: 1800,
    getElementConfig: function() {
        return {
            reference: "element",
            style: {
                position: "absolute"
            },
            children: [{
                reference: "innerElement",
                style: {
                    width: "100%",
                    height: "100%",
                    position: "relative"
                }
            }]
        }
    },
    createCanvas: function() {
        var d = Ext.Element.create({
            tag: "canvas",
            cls: "x-surface"
        }),
        f = Ext.draw.engine.Canvas.contextOverrides,
        a = d.dom.getContext("2d"),
        e = a.webkitBackingStorePixelRatio || a.mozBackingStorePixelRatio || a.msBackingStorePixelRatio || a.oBackingStorePixelRatio || a.backingStorePixelRatio || 1,
        b;
        this.devicePixelRatio /= (Ext.os.is.WindowsPhone) ? window.innerWidth / window.screen.width: e;
        if (a.ellipse) {
            delete f.ellipse
        }
        for (b in f) {
            a["$" + b] = a[b]
        }
        Ext.apply(a, f);
        if (this.getHighPrecision()) {
            this.enablePrecisionCompensation(a)
        } else {
            this.disablePrecisionCompensation(a)
        }
        this.innerElement.appendChild(d);
        this.canvases.push(d);
        this.contexts.push(a)
    },
    initElement: function() {
        this.callSuper();
        this.canvases = [];
        this.contexts = [];
        this.createCanvas();
        this.activeCanvases = 0
    },
    updateHighPrecision: function(a) {
        var f = this.contexts,
        e = f.length,
        d, b;
        for (d = 0; d < e; d++) {
            b = f[d];
            if (a) {
                this.enablePrecisionCompensation(b)
            } else {
                this.disablePrecisionCompensation(b)
            }
        }
    },
    precisionMethods: {
        rect: false,
        fillRect: false,
        strokeRect: false,
        clearRect: false,
        moveTo: false,
        lineTo: false,
        arc: false,
        arcTo: false,
        save: false,
        restore: false,
        updatePrecisionCompensate: false,
        setTransform: false,
        transform: false,
        scale: false,
        translate: false,
        rotate: false,
        quadraticCurveTo: false,
        bezierCurveTo: false,
        createLinearGradient: false,
        createRadialGradient: false,
        fillText: false,
        strokeText: false,
        drawImage: false
    },
    disablePrecisionCompensation: function(b) {
        var a = this.precisionMethods,
        d;
        for (d in a) {
            delete b[d]
        }
        this.setDirty(true)
    },
    enablePrecisionCompensation: function(j) {
        var e = this,
        a = 1,
        g = 1,
        m = 0,
        k = 0,
        i = new Ext.draw.Matrix(),
        d = [],
        f = {},
        h = j.constructor.prototype;
        var b = {
            rect: function(n, q, o, p) {
                return h.rect.call(this, n * a + m, q * g + k, o * a, p * g)
            },
            fillRect: function(n, q, o, p) {
                this.updatePrecisionCompensateRect();
                h.fillRect.call(this, n * a + m, q * g + k, o * a, p * g);
                this.updatePrecisionCompensate()
            },
            strokeRect: function(n, q, o, p) {
                this.updatePrecisionCompensateRect();
                h.strokeRect.call(this, n * a + m, q * g + k, o * a, p * g);
                this.updatePrecisionCompensate()
            },
            clearRect: function(n, q, o, p) {
                return h.clearRect.call(this, n * a + m, q * g + k, o * a, p * g)
            },
            moveTo: function(n, o) {
                return h.moveTo.call(this, n * a + m, o * g + k)
            },
            lineTo: function(n, o) {
                return h.lineTo.call(this, n * a + m, o * g + k)
            },
            arc: function(o, s, n, q, p, r) {
                this.updatePrecisionCompensateRect();
                h.arc.call(this, o * a + m, s * a + k, n * a, q, p, r);
                this.updatePrecisionCompensate()
            },
            arcTo: function(p, r, o, q, n) {
                this.updatePrecisionCompensateRect();
                h.arcTo.call(this, p * a + m, r * g + k, o * a + m, q * g + k, n * a);
                this.updatePrecisionCompensate()
            },
            save: function() {
                d.push(i);
                i = i.clone();
                return h.save.call(this)
            },
            restore: function() {
                i = d.pop();
                h.restore.call(this);
                this.updatePrecisionCompensate()
            },
            updatePrecisionCompensate: function() {
                i.precisionCompensate(e.devicePixelRatio, f);
                a = f.xx;
                g = f.yy;
                m = f.dx;
                k = f.dy;
                return h.setTransform.call(this, e.devicePixelRatio, f.b, f.c, f.d, 0, 0)
            },
            updatePrecisionCompensateRect: function() {
                i.precisionCompensateRect(e.devicePixelRatio, f);
                a = f.xx;
                g = f.yy;
                m = f.dx;
                k = f.dy;
                return h.setTransform.call(this, e.devicePixelRatio, f.b, f.c, f.d, 0, 0)
            },
            setTransform: function(r, p, o, n, s, q) {
                i.set(r, p, o, n, s, q);
                this.updatePrecisionCompensate()
            },
            transform: function(r, p, o, n, s, q) {
                i.append(r, p, o, n, s, q);
                this.updatePrecisionCompensate()
            },
            scale: function(o, n) {
                return this.transform(o, 0, 0, n, 0, 0)
            },
            translate: function(o, n) {
                return this.transform(1, 0, 0, 1, o, n)
            },
            rotate: function(p) {
                var o = Math.cos(p),
                n = Math.sin(p);
                return this.transform(o, n, -n, o, 0, 0)
            },
            quadraticCurveTo: function(o, q, n, p) {
                return h.quadraticCurveTo.call(this, o * a + m, q * g + k, n * a + m, p * g + k)
            },
            bezierCurveTo: function(s, q, p, o, n, r) {
                return h.bezierCurveTo.call(this, s * a + m, q * g + k, p * a + m, o * g + k, n * a + m, r * g + k)
            },
            createLinearGradient: function(o, q, n, p) {
                this.updatePrecisionCompensateRect();
                var r = h.createLinearGradient.call(this, o * a + m, q * g + k, n * a + m, p * g + k);
                this.updatePrecisionCompensate();
                return r
            },
            createRadialGradient: function(q, s, p, o, r, n) {
                this.updatePrecisionCompensateRect();
                var t = h.createLinearGradient.call(this, q * a + m, s * a + k, p * a, o * a + m, r * a + k, n * a);
                this.updatePrecisionCompensate();
                return t
            },
            fillText: function(p, n, q, o) {
                h.setTransform.apply(this, i.elements);
                if (typeof o === "undefined") {
                    h.fillText.call(this, p, n, q)
                } else {
                    h.fillText.call(this, p, n, q, o)
                }
                this.updatePrecisionCompensate()
            },
            strokeText: function(p, n, q, o) {
                h.setTransform.apply(this, i.elements);
                if (typeof o === "undefined") {
                    h.strokeText.call(this, p, n, q)
                } else {
                    h.strokeText.call(this, p, n, q, o)
                }
                this.updatePrecisionCompensate()
            },
            fill: function() {
                this.updatePrecisionCompensateRect();
                h.fill.call(this);
                this.updatePrecisionCompensate()
            },
            stroke: function() {
                this.updatePrecisionCompensateRect();
                h.stroke.call(this);
                this.updatePrecisionCompensate()
            },
            drawImage: function(v, t, s, r, q, p, o, n, u) {
                switch (arguments.length) {
                case 3:
                    return h.drawImage.call(this, v, t * a + m, s * g + k);
                case 5:
                    return h.drawImage.call(this, v, t * a + m, s * g + k, r * a, q * g);
                case 9:
                    return h.drawImage.call(this, v, t, s, r, q, p * a + m, o * g * k, n * a, u * g)
                }
            }
        };
        Ext.apply(j, b);
        this.setDirty(true)
    },
    updateRegion: function(o) {
        this.callSuper([o]);
        var n = this,
        d = Math.floor(o[0]),
        y = Math.floor(o[1]),
        a = Math.ceil(o[0] + o[2]),
        p = Math.ceil(o[1] + o[3]),
        v = n.devicePixelRatio,
        u = a - d,
        k = p - y,
        q = Math.round(n.splitThreshold / v),
        s = Math.ceil(u / q),
        m = n.activeCanvases,
        g,
        j,
        f,
        e;
        for (g = 0, j = 0; g < s; g++, j += q) {
            if (g >= n.canvases.length) {
                n.createCanvas()
            }
            f = n.canvases[g].dom;
            f.style.left = j + "px";
            if (k * v !== f.height) {
                f.height = k * v;
                f.style.height = k + "px"
            }
            e = Math.min(q, u - j);
            if (e * v !== f.width) {
                f.width = e * v;
                f.style.width = e + "px"
            }
            n.applyDefaults(n.contexts[g])
        }
        for (; g < m; g++) {
            f = n.canvases[g].dom;
            f.width = 0;
            f.height = 0
        }
        n.activeCanvases = s;
        n.clear()
    },
    clearTransform: function() {
        var d = this,
        e = d.activeCanvases,
        b, a;
        for (b = 0; b < e; b++) {
            a = d.contexts[b];
            a.translate( - d.splitThreshold * b, 0);
            a.scale(d.devicePixelRatio, d.devicePixelRatio);
            d.matrix.toContext(a)
        }
    },
    renderSprite: function(p) {
        var h = this,
        k = h._region,
        g = h.matrix,
        n = p._parent,
        m = Ext.draw.Matrix.fly([1, 0, 0, 1, 0, 0]),
        q,
        e,
        f,
        r,
        b,
        d = 0,
        j,
        o = k[2],
        a;
        while (n && (n !== h)) {
            m.prependMatrix(n.matrix || n.attr && n.attr.matrix);
            n = n.getParent()
        }
        m.prependMatrix(g);
        q = p.getBBox();
        if (q) {
            q = m.transformBBox(q)
        }
        p.preRender(h);
        if (p.attr.hidden || p.attr.globalAlpha === 0) {
            p.setDirty(false);
            return
        }
        j = 0;
        a = j + k[3];
        for (e = 0, f = 0; e < h.activeCanvases; e++, f += h.splitThreshold / h.devicePixelRatio) {
            r = h.contexts[e];
            b = Math.min(k[2] - f, h.splitThreshold / h.devicePixelRatio);
            d = f;
            o = d + b;
            if (q) {
                if (q.x > o || q.x + q.width < d || q.y > a || q.y + q.height < j) {
                    continue
                }
            }
            try {
                r.save();
                p.useAttributes(r, k);
                if (false === p.render(h, r, [d, j, b, a - j], k)) {
                    return false
                }
            } finally {
                r.restore()
            }
        }
        p.setDirty(false)
    },
    applyDefaults: function(a) {
        a.strokeStyle = "rgba(0,0,0,0)";
        a.fillStyle = "rgba(0,0,0,0)";
        a.textAlign = "start";
        a.textBaseline = "top";
        a.miterLimit = 1
    },
    clear: function() {
        var e = this,
        f = this.activeCanvases,
        d, b, a;
        for (d = 0; d < f; d++) {
            b = e.canvases[d].dom;
            a = e.contexts[d];
            a.setTransform(1, 0, 0, 1, 0, 0);
            a.clearRect(0, 0, b.width, b.height)
        }
        e.setDirty(true)
    },
    destroy: function() {
        var d = this,
        a, b = d.canvases.length;
        for (a = 0; a < b; a++) {
            d.contexts[a] = null;
            d.canvases[a].destroy();
            d.canvases[a] = null
        }
        delete d.contexts;
        delete d.canvases;
        d.callSuper(arguments)
    }
},
function() {
    if (Ext.os.is.Android4 && Ext.browser.is.Chrome) {
        this.prototype.splitThreshold = 3000
    } else {
        if (Ext.os.is.Android) {
            this.prototype.splitThreshold = 10000000000
        }
    }
});
Ext.define("Ext.mixin.Sortable", {
    extend: Ext.mixin.Mixin,
    mixinConfig: {
        id: "sortable"
    },
    config: {
        sorters: null,
        defaultSortDirection: "ASC",
        sortRoot: null
    },
    dirtySortFn: false,
    sortFn: null,
    sorted: false,
    applySorters: function(a, b) {
        if (!b) {
            b = this.createSortersCollection()
        }
        b.clear();
        this.sorted = false;
        if (a) {
            this.addSorters(a)
        }
        return b
    },
    createSortersCollection: function() {
        this._sorters = Ext.create("Ext.util.Collection",
        function(a) {
            return a.getId()
        });
        return this._sorters
    },
    addSorter: function(b, a) {
        this.addSorters([b], a)
    },
    addSorters: function(d, a) {
        var b = this.getSorters();
        return this.insertSorters(b ? b.length: 0, d, a)
    },
    insertSorter: function(a, d, b) {
        return this.insertSorters(a, [d], b)
    },
    insertSorters: function(f, j, a) {
        if (!Ext.isArray(j)) {
            j = [j]
        }
        var g = j.length,
        k = a || this.getDefaultSortDirection(),
        d = this.getSortRoot(),
        m = this.getSorters(),
        n = [],
        h,
        b,
        o,
        e;
        if (!m) {
            m = this.createSortersCollection()
        }
        for (b = 0; b < g; b++) {
            o = j[b];
            h = {
                direction: k,
                root: d
            };
            if (typeof o === "string") {
                e = m.get(o);
                if (!e) {
                    h.property = o
                } else {
                    if (a) {
                        e.setDirection(a)
                    } else {
                        e.toggle()
                    }
                    continue
                }
            } else {
                if (Ext.isFunction(o)) {
                    h.sorterFn = o
                } else {
                    if (Ext.isObject(o)) {
                        if (!o.isSorter) {
                            if (o.fn) {
                                o.sorterFn = o.fn;
                                delete o.fn
                            }
                            h = Ext.apply(h, o)
                        } else {
                            n.push(o);
                            if (!o.getRoot()) {
                                o.setRoot(d)
                            }
                            continue
                        }
                    }
                }
            }
            o = Ext.create("Ext.util.Sorter", h);
            n.push(o)
        }
        for (b = 0, g = n.length; b < g; b++) {
            m.insert(f + b, n[b])
        }
        this.dirtySortFn = true;
        if (m.length) {
            this.sorted = true
        }
        return m
    },
    removeSorter: function(a) {
        return this.removeSorters([a])
    },
    removeSorters: function(e) {
        if (!Ext.isArray(e)) {
            e = [e]
        }
        var b = e.length,
        d = this.getSorters(),
        a,
        f;
        for (a = 0; a < b; a++) {
            f = e[a];
            if (typeof f === "string") {
                d.removeAtKey(f)
            } else {
                if (typeof f === "function") {
                    d.each(function(g) {
                        if (g.getSorterFn() === f) {
                            d.remove(g)
                        }
                    })
                } else {
                    if (f.isSorter) {
                        d.remove(f)
                    }
                }
            }
        }
        if (!d.length) {
            this.sorted = false
        }
    },
    updateSortFn: function() {
        var a = this.getSorters().items;
        this.sortFn = function(e, d) {
            var g = a.length,
            b, f;
            for (f = 0; f < g; f++) {
                b = a[f].sort.call(this, e, d);
                if (b !== 0) {
                    break
                }
            }
            return b
        };
        this.dirtySortFn = false;
        return this.sortFn
    },
    getSortFn: function() {
        if (this.dirtySortFn) {
            return this.updateSortFn()
        }
        return this.sortFn
    },
    sort: function(a) {
        Ext.Array.sort(a, this.getSortFn());
        return a
    },
    findInsertionIndex: function(b, f, h) {
        var i = 0,
        a = b.length - 1,
        e = h || this.getSortFn(),
        d,
        g;
        while (i <= a) {
            d = (i + a) >> 1;
            g = e(f, b[d]);
            if (g >= 0) {
                i = d + 1
            } else {
                if (g < 0) {
                    a = d - 1
                }
            }
        }
        return i
    }
});
Ext.define("Ext.mixin.Filterable", {
    extend: Ext.mixin.Mixin,
    mixinConfig: {
        id: "filterable"
    },
    config: {
        filters: null,
        filterRoot: null
    },
    dirtyFilterFn: false,
    filterFn: null,
    filtered: false,
    applyFilters: function(a, b) {
        if (!b) {
            b = this.createFiltersCollection()
        }
        b.clear();
        this.filtered = false;
        this.dirtyFilterFn = true;
        if (a) {
            this.addFilters(a)
        }
        return b
    },
    createFiltersCollection: function() {
        this._filters = Ext.create("Ext.util.Collection",
        function(a) {
            return a.getId()
        });
        return this._filters
    },
    addFilter: function(a) {
        this.addFilters([a])
    },
    addFilters: function(b) {
        var a = this.getFilters();
        return this.insertFilters(a ? a.length: 0, b)
    },
    insertFilter: function(a, b) {
        return this.insertFilters(a, [b])
    },
    insertFilters: function(j, d) {
        if (!Ext.isArray(d)) {
            d = [d]
        }
        var k = d.length,
        a = this.getFilterRoot(),
        e = this.getFilters(),
        f = [],
        g,
        h,
        b;
        if (!e) {
            e = this.createFiltersCollection()
        }
        for (h = 0; h < k; h++) {
            b = d[h];
            g = {
                root: a
            };
            if (Ext.isFunction(b)) {
                g.filterFn = b
            } else {
                if (Ext.isObject(b)) {
                    if (!b.isFilter) {
                        if (b.fn) {
                            b.filterFn = b.fn;
                            delete b.fn
                        }
                        g = Ext.apply(g, b)
                    } else {
                        f.push(b);
                        if (!b.getRoot()) {
                            b.setRoot(a)
                        }
                        continue
                    }
                }
            }
            b = Ext.create("Ext.util.Filter", g);
            f.push(b)
        }
        for (h = 0, k = f.length; h < k; h++) {
            e.insert(j + h, f[h])
        }
        this.dirtyFilterFn = true;
        if (e.length) {
            this.filtered = true
        }
        return e
    },
    removeFilters: function(f) {
        if (!Ext.isArray(f)) {
            f = [f]
        }
        var e = f.length,
        d = this.getFilters(),
        a,
        b;
        for (a = 0; a < e; a++) {
            b = f[a];
            if (typeof b === "string") {
                d.each(function(g) {
                    if (g.getProperty() === b) {
                        d.remove(g)
                    }
                })
            } else {
                if (typeof b === "function") {
                    d.each(function(g) {
                        if (g.getFilterFn() === b) {
                            d.remove(g)
                        }
                    })
                } else {
                    if (b.isFilter) {
                        d.remove(b)
                    } else {
                        if (b.property !== undefined && b.value !== undefined) {
                            d.each(function(g) {
                                if (g.getProperty() === b.property && g.getValue() === b.value) {
                                    d.remove(g)
                                }
                            })
                        }
                    }
                }
            }
        }
        if (!d.length) {
            this.filtered = false
        }
    },
    updateFilterFn: function() {
        var a = this.getFilters().items;
        this.filterFn = function(j) {
            var g = true,
            h = a.length,
            b;
            for (b = 0; b < h; b++) {
                var f = a[b],
                e = f.getFilterFn(),
                d = f.getScope() || this;
                g = g && e.call(d, j)
            }
            return g
        };
        this.dirtyFilterFn = false;
        return this.filterFn
    },
    filter: function(a) {
        return this.getFilters().length ? Ext.Array.filter(a, this.getFilterFn()) : a
    },
    isFiltered: function(a) {
        return this.getFilters().length ? !this.getFilterFn()(a) : false
    },
    getFilterFn: function() {
        if (this.dirtyFilterFn) {
            return this.updateFilterFn()
        }
        return this.filterFn
    }
});
Ext.define("Ext.util.Collection", {
    config: {
        autoFilter: true,
        autoSort: true
    },
    mixins: {
        sortable: Ext.mixin.Sortable,
        filterable: Ext.mixin.Filterable
    },
    constructor: function(b, a) {
        var d = this;
        d.all = [];
        d.items = [];
        d.keys = [];
        d.indices = {};
        d.map = {};
        d.length = 0;
        if (b) {
            d.getKey = b
        }
        this.initConfig(a)
    },
    updateAutoSort: function(a, b) {
        if (b === false && a && this.items.length) {
            this.sort()
        }
    },
    updateAutoFilter: function(b, a) {
        if (a === false && b && this.all.length) {
            this.filter()
        }
    },
    insertSorters: function() {
        this.mixins.sortable.insertSorters.apply(this, arguments);
        if (this.getAutoSort() && this.items.length) {
            this.sort()
        }
        return this
    },
    removeSorters: function(a) {
        this.mixins.sortable.removeSorters.call(this, a);
        if (this.sorted && this.getAutoSort() && this.items.length) {
            this.sort()
        }
        return this
    },
    applyFilters: function(a) {
        var b = this.mixins.filterable.applyFilters.call(this, a);
        if (!a && this.all.length && this.getAutoFilter()) {
            this.filter()
        }
        return b
    },
    addFilters: function(a) {
        this.mixins.filterable.addFilters.call(this, a);
        if (this.items.length && this.getAutoFilter()) {
            this.filter()
        }
        return this
    },
    removeFilters: function(a) {
        this.mixins.filterable.removeFilters.call(this, a);
        if (this.filtered && this.all.length && this.getAutoFilter()) {
            this.filter()
        }
        return this
    },
    filter: function(d, b, e, a) {
        if (d) {
            if (Ext.isString(d)) {
                this.addFilters({
                    property: d,
                    value: b,
                    anyMatch: e,
                    caseSensitive: a
                });
                return this.items
            } else {
                this.addFilters(d);
                return this.items
            }
        }
        this.items = this.mixins.filterable.filter.call(this, this.all.slice());
        this.updateAfterFilter();
        if (this.sorted && this.getAutoSort()) {
            this.sort()
        }
    },
    updateAfterFilter: function() {
        var a = this.items,
        g = this.keys,
        h = this.indices = {},
        f = a.length,
        d, e, b;
        g.length = 0;
        for (d = 0; d < f; d++) {
            e = a[d];
            b = this.getKey(e);
            h[b] = d;
            g[d] = b
        }
        this.length = a.length;
        this.dirtyIndices = false
    },
    sort: function(f, a) {
        var e = this.items,
        j = this.keys,
        h = this.indices,
        d = e.length,
        b, k, g;
        if (f) {
            this.addSorters(f, a);
            return this.items
        }
        for (b = 0; b < d; b++) {
            e[b]._current_key = j[b]
        }
        this.handleSort(e);
        for (b = 0; b < d; b++) {
            k = e[b];
            g = k._current_key;
            j[b] = g;
            h[g] = b;
            delete k._current_key
        }
        this.dirtyIndices = true
    },
    handleSort: function(a) {
        this.mixins.sortable.sort.call(this, a)
    },
    add: function(j, m) {
        var h = this,
        e = this.filtered,
        f = this.sorted,
        i = this.all,
        g = this.items,
        n = this.keys,
        k = this.indices,
        a = this.mixins.filterable,
        b = g.length,
        d = b;
        if (arguments.length == 1) {
            m = j;
            j = h.getKey(m)
        }
        if (typeof j != "undefined" && j !== null) {
            if (typeof h.map[j] != "undefined") {
                return h.replace(j, m)
            }
            h.map[j] = m
        }
        i.push(m);
        if (e && this.getAutoFilter() && a.isFiltered.call(h, m)) {
            return null
        }
        h.length++;
        if (f && this.getAutoSort()) {
            d = this.findInsertionIndex(g, m)
        }
        if (d !== b) {
            this.dirtyIndices = true;
            Ext.Array.splice(n, d, 0, j);
            Ext.Array.splice(g, d, 0, m)
        } else {
            k[j] = b;
            n.push(j);
            g.push(m)
        }
        return m
    },
    getKey: function(a) {
        return a.id
    },
    replace: function(e, o) {
        var j = this,
        h = j.sorted,
        g = j.filtered,
        b = j.mixins.filterable,
        i = j.items,
        p = j.keys,
        m = j.all,
        d = j.map,
        n = null,
        a = i.length,
        q, f, k;
        if (arguments.length == 1) {
            o = e;
            e = k = j.getKey(o)
        } else {
            k = j.getKey(o)
        }
        q = d[e];
        if (typeof e == "undefined" || e === null || typeof q == "undefined") {
            return j.add(k, o)
        }
        j.map[k] = o;
        if (k !== e) {
            delete j.map[e]
        }
        if (h && j.getAutoSort()) {
            Ext.Array.remove(i, q);
            Ext.Array.remove(p, e);
            Ext.Array.remove(m, q);
            m.push(o);
            j.dirtyIndices = true;
            if (g && j.getAutoFilter()) {
                if (b.isFiltered.call(j, o)) {
                    if (a !== i.length) {
                        j.length--
                    }
                    return null
                } else {
                    if (a === i.length) {
                        j.length++;
                        n = o
                    }
                }
            }
            f = this.findInsertionIndex(i, o);
            Ext.Array.splice(p, f, 0, k);
            Ext.Array.splice(i, f, 0, o)
        } else {
            if (g) {
                if (j.getAutoFilter() && b.isFiltered.call(j, o)) {
                    if (j.indexOf(q) !== -1) {
                        Ext.Array.remove(i, q);
                        Ext.Array.remove(p, e);
                        j.length--;
                        j.dirtyIndices = true
                    }
                    return null
                } else {
                    if (j.indexOf(q) === -1) {
                        i.push(o);
                        p.push(k);
                        j.indices[k] = j.length;
                        j.length++;
                        return o
                    }
                }
            }
            f = j.indexOf(q);
            p[f] = k;
            i[f] = o;
            if (k !== e) {
                this.dirtyIndices = true
            }
        }
        return n
    },
    addAll: function(j) {
        var s = this,
        f = s.filtered,
        a = s.sorted,
        b = s.all,
        m = s.items,
        k = s.keys,
        r = s.map,
        n = s.getAutoFilter(),
        o = s.getAutoSort(),
        t = [],
        g = [],
        d = s.mixins.filterable,
        e = [],
        h,
        u,
        p,
        q;
        if (Ext.isObject(j)) {
            for (u in j) {
                if (j.hasOwnProperty(u)) {
                    g.push(m[u]);
                    t.push(u)
                }
            }
        } else {
            g = j;
            h = j.length;
            for (p = 0; p < h; p++) {
                t.push(s.getKey(j[p]))
            }
        }
        for (p = 0; p < h; p++) {
            u = t[p];
            q = g[p];
            if (typeof u != "undefined" && u !== null) {
                if (typeof r[u] != "undefined") {
                    s.replace(u, q);
                    continue
                }
                r[u] = q
            }
            b.push(q);
            if (f && n && d.isFiltered.call(s, q)) {
                continue
            }
            s.length++;
            k.push(u);
            m.push(q);
            e.push(q)
        }
        if (e.length) {
            s.dirtyIndices = true;
            if (a && o) {
                s.sort()
            }
            return e
        }
        return null
    },
    each: function(f, e) {
        var b = this.items.slice(),
        d = 0,
        a = b.length,
        g;
        for (; d < a; d++) {
            g = b[d];
            if (f.call(e || g, g, d, a) === false) {
                break
            }
        }
    },
    eachKey: function(e, d) {
        var g = this.keys,
        a = this.items,
        f = g.length,
        b;
        for (b = 0; b < f; b++) {
            e.call(d || window, g[b], a[b], b, f)
        }
    },
    findBy: function(f, e) {
        var g = this.keys,
        b = this.items,
        d = 0,
        a = b.length;
        for (; d < a; d++) {
            if (f.call(e || window, b[d], g[d])) {
                return b[d]
            }
        }
        return null
    },
    filterBy: function(f, e) {
        var j = this,
        d = new this.self(),
        h = j.keys,
        a = j.all,
        g = a.length,
        b;
        d.getKey = j.getKey;
        for (b = 0; b < g; b++) {
            if (f.call(e || j, a[b], j.getKey(a[b]))) {
                d.add(h[b], a[b])
            }
        }
        return d
    },
    insert: function(d, e, g) {
        var f = this,
        a = this.sorted,
        h = this.map,
        b = this.filtered;
        if (arguments.length == 2) {
            g = e;
            e = f.getKey(g)
        }
        if (d >= f.length || (a && f.getAutoSort())) {
            return f.add(e, g)
        }
        if (typeof e != "undefined" && e !== null) {
            if (typeof h[e] != "undefined") {
                f.replace(e, g);
                return false
            }
            h[e] = g
        }
        this.all.push(g);
        if (b && this.getAutoFilter() && this.mixins.filterable.isFiltered.call(f, g)) {
            return null
        }
        f.length++;
        Ext.Array.splice(f.items, d, 0, g);
        Ext.Array.splice(f.keys, d, 0, e);
        f.dirtyIndices = true;
        return g
    },
    insertAll: function(h, e) {
        if (h >= this.items.length || (this.sorted && this.getAutoSort())) {
            return this.addAll(e)
        }
        var u = this,
        j = this.filtered,
        a = this.sorted,
        b = this.all,
        o = this.items,
        n = this.keys,
        t = this.map,
        p = this.getAutoFilter(),
        q = this.getAutoSort(),
        v = [],
        k = [],
        g = [],
        d = this.mixins.filterable,
        f = false,
        m,
        y,
        r,
        s;
        if (a && this.getAutoSort()) {}
        if (Ext.isObject(e)) {
            for (y in e) {
                if (e.hasOwnProperty(y)) {
                    k.push(o[y]);
                    v.push(y)
                }
            }
        } else {
            k = e;
            m = e.length;
            for (r = 0; r < m; r++) {
                v.push(u.getKey(e[r]))
            }
        }
        for (r = 0; r < m; r++) {
            y = v[r];
            s = k[r];
            if (typeof y != "undefined" && y !== null) {
                if (typeof t[y] != "undefined") {
                    u.replace(y, s);
                    continue
                }
                t[y] = s
            }
            b.push(s);
            if (j && p && d.isFiltered.call(u, s)) {
                continue
            }
            u.length++;
            Ext.Array.splice(o, h + r, 0, s);
            Ext.Array.splice(n, h + r, 0, y);
            f = true;
            g.push(s)
        }
        if (f) {
            this.dirtyIndices = true;
            if (a && q) {
                this.sort()
            }
            return g
        }
        return null
    },
    remove: function(d) {
        var a = this.items.indexOf(d);
        if (a === -1) {
            Ext.Array.remove(this.all, d);
            if (typeof this.getKey == "function") {
                var b = this.getKey(d);
                if (b !== undefined) {
                    delete this.map[b]
                }
            }
            return d
        }
        return this.removeAt(this.items.indexOf(d))
    },
    removeAll: function(a) {
        if (a) {
            var d = a.length,
            b;
            for (b = 0; b < d; b++) {
                this.remove(a[b])
            }
        }
        return this
    },
    removeAt: function(b) {
        var h = this,
        a = h.items,
        g = h.keys,
        e = h.all,
        f, d;
        if (b < h.length && b >= 0) {
            f = a[b];
            d = g[b];
            if (typeof d != "undefined") {
                delete h.map[d]
            }
            Ext.Array.erase(a, b, 1);
            Ext.Array.erase(g, b, 1);
            Ext.Array.remove(e, f);
            delete h.indices[d];
            h.length--;
            this.dirtyIndices = true;
            return f
        }
        return false
    },
    removeAtKey: function(a) {
        return this.removeAt(this.indexOfKey(a))
    },
    getCount: function() {
        return this.length
    },
    indexOf: function(b) {
        if (this.dirtyIndices) {
            this.updateIndices()
        }
        var a = b ? this.indices[this.getKey(b)] : -1;
        return (a === undefined) ? -1 : a
    },
    indexOfKey: function(b) {
        if (this.dirtyIndices) {
            this.updateIndices()
        }
        var a = this.indices[b];
        return (a === undefined) ? -1 : a
    },
    updateIndices: function() {
        var a = this.items,
        f = a.length,
        g = this.indices = {},
        d, e, b;
        for (d = 0; d < f; d++) {
            e = a[d];
            b = this.getKey(e);
            g[b] = d
        }
        this.dirtyIndices = false
    },
    get: function(b) {
        var e = this,
        a = e.map[b],
        d;
        if (a !== undefined) {
            d = a
        } else {
            if (typeof b == "number") {
                d = e.items[b]
            }
        }
        return typeof d != "function" || e.getAllowFunctions() ? d: null
    },
    getAt: function(a) {
        return this.items[a]
    },
    getByKey: function(a) {
        return this.map[a]
    },
    contains: function(b) {
        var a = this.getKey(b);
        if (a) {
            return this.containsKey(a)
        } else {
            return Ext.Array.contains(this.items, b)
        }
    },
    containsKey: function(a) {
        return typeof this.map[a] != "undefined"
    },
    clear: function() {
        var a = this;
        a.length = 0;
        a.items.length = 0;
        a.keys.length = 0;
        a.all.length = 0;
        a.dirtyIndices = true;
        a.indices = {};
        a.map = {}
    },
    first: function() {
        return this.items[0]
    },
    last: function() {
        return this.items[this.length - 1]
    },
    getRange: function(g, a) {
        var f = this,
        d = f.items,
        b = [],
        e;
        if (d.length < 1) {
            return b
        }
        g = g || 0;
        a = Math.min(typeof a == "undefined" ? f.length - 1 : a, f.length - 1);
        if (g <= a) {
            for (e = g; e <= a; e++) {
                b[b.length] = d[e]
            }
        } else {
            for (e = g; e >= a; e--) {
                b[b.length] = d[e]
            }
        }
        return b
    },
    findIndexBy: function(e, d, j) {
        var h = this,
        g = h.keys,
        a = h.items,
        b = j || 0,
        f = a.length;
        for (; b < f; b++) {
            if (e.call(d || h, a[b], g[b])) {
                return b
            }
        }
        return - 1
    },
    clone: function() {
        var f = this,
        g = new this.self(),
        e = f.keys,
        a = f.items,
        b = 0,
        d = a.length;
        for (; b < d; b++) {
            g.add(e[b], a[b])
        }
        g.getKey = f.getKey;
        return g
    },
    destroy: function() {
        this.callSuper();
        this.clear()
    }
});
Ext.define("Ext.data.ResultSet", {
    config: {
        loaded: true,
        count: null,
        total: null,
        success: false,
        records: null,
        message: null
    },
    constructor: function(a) {
        this.initConfig(a)
    },
    applyCount: function(a) {
        if (!a && a !== 0) {
            return this.getRecords().length
        }
        return a
    },
    updateRecords: function(a) {
        this.setCount(a.length)
    }
});
Ext.define("Ext.data.reader.Reader", {
    alternateClassName: ["Ext.data.Reader", "Ext.data.DataReader"],
    mixins: [Ext.mixin.Observable],
    isReader: true,
    config: {
        idProperty: undefined,
        clientIdProperty: "clientId",
        totalProperty: "total",
        successProperty: "success",
        messageProperty: null,
        rootProperty: "",
        implicitIncludes: true,
        model: undefined
    },
    constructor: function(a) {
        this.initConfig(a)
    },
    fieldCount: 0,
    applyModel: function(a) {
        if (typeof a == "string") {
            a = Ext.data.ModelManager.getModel(a);
            if (!a) {
                Ext.Logger.error("Model with name " + arguments[0] + " doesnt exist.")
            }
        }
        if (a && !a.prototype.isModel && Ext.isObject(a)) {
            a = Ext.data.ModelManager.registerType(a.storeId || a.id || Ext.id(), a)
        }
        return a
    },
    applyIdProperty: function(a) {
        if (!a && this.getModel()) {
            a = this.getModel().getIdProperty()
        }
        return a
    },
    updateModel: function(a) {
        if (a) {
            if (!this.getIdProperty()) {
                this.setIdProperty(a.getIdProperty())
            }
            this.buildExtractors()
        }
    },
    createAccessor: Ext.emptyFn,
    createFieldAccessExpression: function() {
        return "undefined"
    },
    buildExtractors: function() {
        if (!this.getModel()) {
            return
        }
        var b = this,
        d = b.getTotalProperty(),
        a = b.getSuccessProperty(),
        e = b.getMessageProperty();
        if (d) {
            b.getTotal = b.createAccessor(d)
        }
        if (a) {
            b.getSuccess = b.createAccessor(a)
        }
        if (e) {
            b.getMessage = b.createAccessor(e)
        }
        b.extractRecordData = b.buildRecordDataExtractor()
    },
    buildRecordDataExtractor: function() {
        var m = this,
        f = m.getModel(),
        h = f.getFields(),
        k = h.length,
        a = [],
        j = m.getModel().getClientIdProperty(),
        g = "__field",
        b = ["var me = this,\n", "    fields = me.getModel().getFields(),\n", "    idProperty = me.getIdProperty(),\n", '    idPropertyIsFn = (typeof idProperty == "function"),', "    value,\n", "    internalId"],
        e,
        n,
        d,
        o;
        h = h.items;
        for (e = 0; e < k; e++) {
            n = h[e];
            o = n.getName();
            if (o === f.getIdProperty()) {
                a[e] = "idField"
            } else {
                a[e] = g + e
            }
            b.push(",\n    ", a[e], ' = fields.get("', n.getName(), '")')
        }
        b.push(";\n\n    return function(source) {\n        var dest = {};\n");
        b.push("        if (idPropertyIsFn) {\n");
        b.push("            idField.setMapping(idProperty);\n");
        b.push("        }\n");
        for (e = 0; e < k; e++) {
            n = h[e];
            d = a[e];
            o = n.getName();
            if (o === f.getIdProperty() && n.getMapping() === null && f.getIdProperty() !== this.getIdProperty()) {
                n.setMapping(this.getIdProperty())
            }
            b.push("        try {\n");
            b.push("            value = ", m.createFieldAccessExpression(n, d, "source"), ";\n");
            b.push("            if (value !== undefined) {\n");
            b.push('                dest["' + n.getName() + '"] = value;\n');
            b.push("            }\n");
            b.push("        } catch(e){}\n")
        }
        if (j) {
            b.push("        internalId = " + m.createFieldAccessExpression(Ext.create("Ext.data.Field", {
                name: j
            }), null, "source") + ";\n");
            b.push("        if (internalId !== undefined) {\n");
            b.push('            dest["_clientId"] = internalId;\n        }\n')
        }
        b.push("        return dest;\n");
        b.push("    };");
        return Ext.functionFactory(b.join("")).call(m)
    },
    getFields: function() {
        return this.getModel().getFields().items
    },
    getData: function(a) {
        return a
    },
    getResponseData: function(a) {
        return a
    },
    getRoot: function(a) {
        return a
    },
    read: function(d) {
        var h = d,
        j = this.getModel(),
        f,
        b,
        e,
        g,
        a;
        if (d) {
            h = this.getResponseData(d)
        }
        if (h) {
            f = this.readRecords(h);
            b = f.getRecords();
            for (e = 0, g = b.length; e < g; e++) {
                a = b[e];
                b[e] = new j(a.data, a.id, a.node)
            }
            return f
        } else {
            return this.nullResultSet
        }
    },
    process: function(a) {
        var b = a;
        if (a) {
            b = this.getResponseData(a)
        }
        if (b) {
            return this.readRecords(b)
        } else {
            return this.nullResultSet
        }
    },
    readRecords: function(d) {
        var f = this;
        f.rawData = d;
        d = f.getData(d);
        if (d.metaData) {
            f.onMetaChange(d.metaData)
        }
        var e = Ext.isArray(d),
        h = e ? d: f.getRoot(d),
        j = true,
        b = 0,
        g,
        i,
        a,
        k;
        if (e && Ext.isEmpty(d.length)) {
            return f.nullResultSet
        }
        if (f.getTotal) {
            i = parseInt(f.getTotal(d), 10);
            if (!isNaN(i)) {
                g = i
            }
        }
        if (f.getSuccess) {
            i = f.getSuccess(d);
            if (i === false || i === "false") {
                j = false
            }
        }
        if (f.getMessage) {
            k = f.getMessage(d)
        }
        if (h) {
            a = f.extractData(h);
            b = a.length
        } else {
            b = 0;
            a = []
        }
        return new Ext.data.ResultSet({
            total: g,
            count: b,
            records: a,
            success: j,
            message: k
        })
    },
    extractData: function(n) {
        var k = this,
        f = [],
        d = n.length,
        j = k.getModel(),
        o = j.getIdProperty(),
        m = j.getFields(),
        e,
        h,
        g,
        b,
        a;
        if (m.isDirty) {
            k.buildExtractors(true);
            delete m.isDirty
        }
        if (!n.length && Ext.isObject(n)) {
            n = [n];
            d = 1
        }
        for (h = 0; h < d; h++) {
            a = null;
            b = null;
            e = n[h];
            if (e.isModel) {
                g = e.data
            } else {
                g = k.extractRecordData(e)
            }
            if (g._clientId !== undefined) {
                a = g._clientId;
                delete g._clientId
            }
            if (g[o] !== undefined) {
                b = g[o]
            }
            if (k.getImplicitIncludes()) {
                k.readAssociated(g, e)
            }
            f.push({
                clientId: a,
                id: b,
                data: g,
                node: e
            })
        }
        return f
    },
    readAssociated: function(b, j) {
        var g = this.getModel().associations.items,
        h = g.length,
        f = 0,
        a,
        e,
        d;
        for (; f < h; f++) {
            a = g[f];
            d = a.getAssociationKey();
            e = this.getAssociatedDataRoot(j, d);
            if (e) {
                b[d] = e
            }
        }
    },
    getAssociatedDataRoot: function(e, a) {
        var d = /[\[\.]/,
        b = String(a).search(d);
        if (b >= 0) {
            return Ext.functionFactory("obj", "return obj" + (b > 0 ? ".": "") + a)(e)
        }
        return e[a]
    },
    onMetaChange: function(g) {
        var a = g.fields,
        f = this,
        e, d, b;
        f.metaData = g;
        if (g.rootProperty !== undefined) {
            f.setRootProperty(g.rootProperty)
        } else {
            if (g.root !== undefined) {
                f.setRootProperty(g.root)
            }
        }
        if (g.idProperty !== undefined) {
            f.setIdProperty(g.idProperty)
        }
        if (g.totalProperty !== undefined) {
            f.setTotalProperty(g.totalProperty)
        }
        if (g.successProperty !== undefined) {
            f.setSuccessProperty(g.successProperty)
        }
        if (g.messageProperty !== undefined) {
            f.setMessageProperty(g.messageProperty)
        }
        if (a) {
            if (f.getModel()) {
                f.getModel().setFields(a);
                f.buildExtractors()
            } else {
                b = f.getIdProperty();
                d = {
                    fields: a
                };
                if (b) {
                    d.idProperty = b
                }
                e = Ext.define("Ext.data.reader.MetaModel" + Ext.id(), {
                    extend: "Ext.data.Model",
                    config: d
                });
                f.setModel(e)
            }
        } else {
            f.buildExtractors()
        }
    }
},
function() {
    Ext.apply(this.prototype, {
        nullResultSet: new Ext.data.ResultSet({
            total: 0,
            count: 0,
            records: [],
            success: false
        })
    })
});
Ext.define("Ext.data.reader.Json", {
    extend: Ext.data.reader.Reader,
    alternateClassName: "Ext.data.JsonReader",
    alias: "reader.json",
    config: {
        record: null,
        useSimpleAccessors: false
    },
    objectRe: /[\[\.]/,
    getResponseData: function(a) {
        var e = a;
        if (a && a.responseText) {
            e = a.responseText
        }
        if (typeof e !== "string") {
            return e
        }
        var d;
        try {
            d = Ext.decode(e)
        } catch(b) {
            this.fireEvent("exception", this, a, "Unable to parse the JSON returned by the server: " + b.toString());
            Ext.Logger.warn("Unable to parse the JSON returned by the server: " + b.toString())
        }
        return d
    },
    buildExtractors: function() {
        var b = this,
        a = b.getRootProperty();
        b.callParent(arguments);
        if (a) {
            b.rootAccessor = b.createAccessor(a)
        } else {
            delete b.rootAccessor
        }
    },
    getRoot: function(b) {
        var a = this.getModel().getFields();
        if (a.isDirty) {
            this.buildExtractors(true);
            delete a.isDirty
        }
        if (this.rootAccessor) {
            return this.rootAccessor.call(this, b)
        } else {
            return b
        }
    },
    extractData: function(a) {
        var f = this.getRecord(),
        e = [],
        d,
        b;
        if (f) {
            d = a.length;
            if (!d && Ext.isObject(a)) {
                d = 1;
                a = [a]
            }
            for (b = 0; b < d; b++) {
                e[b] = a[b][f]
            }
        } else {
            e = a
        }
        return this.callParent([e])
    },
    createAccessor: function() {
        var a = /[\[\.]/;
        return function(d) {
            if (Ext.isEmpty(d)) {
                return Ext.emptyFn
            }
            if (Ext.isFunction(d)) {
                return d
            }
            if (this.getUseSimpleAccessors() !== true) {
                var b = String(d).search(a);
                if (b >= 0) {
                    return Ext.functionFactory("obj", "var value; try {value = obj" + (b > 0 ? ".": "") + d + "} catch(e) {}; return value;")
                }
            }
            return function(e) {
                return e[d]
            }
        }
    } (),
    createFieldAccessExpression: function(h, b, d) {
        var g = this,
        i = g.objectRe,
        f = (h.getMapping() !== null),
        a = f ? h.getMapping() : h.getName(),
        j,
        e;
        if (typeof a === "function") {
            j = b + ".getMapping()(" + d + ", this)"
        } else {
            if (g.getUseSimpleAccessors() === true || ((e = String(a).search(i)) < 0)) {
                if (!f || isNaN(a)) {
                    a = '"' + a + '"'
                }
                j = d + "[" + a + "]"
            } else {
                j = d + (e > 0 ? ".": "") + a
            }
        }
        return j
    }
});
Ext.define("Ext.data.writer.Writer", {
    alias: "writer.base",
    alternateClassName: ["Ext.data.DataWriter", "Ext.data.Writer"],
    config: {
        writeAllFields: true,
        nameProperty: "name"
    },
    constructor: function(a) {
        this.initConfig(a)
    },
    write: function(f) {
        var d = f.getOperation(),
        b = d.getRecords() || [],
        a = b.length,
        e = 0,
        g = [];
        for (; e < a; e++) {
            g.push(this.getRecordData(b[e]))
        }
        return this.writeRecords(f, g)
    },
    writeDate: function(d, b) {
        if (!b) {
            return null
        }
        var a = d.getDateFormat() || "timestamp";
        switch (a) {
        case "timestamp":
            return b.getTime() / 1000;
        case "time":
            return b.getTime();
        default:
            return Ext.Date.format(b, a)
        }
    },
    getRecordData: function(f) {
        var k = f.phantom === true,
        b = this.getWriteAllFields() || k,
        d = this.getNameProperty(),
        g = f.getFields(),
        e = {},
        i,
        a,
        h,
        m,
        j;
        if (b) {
            g.each(function(n) {
                if (n.getPersist()) {
                    a = n.config[d] || n.getName();
                    j = f.get(n.getName());
                    if (n.getType().type == "date") {
                        j = this.writeDate(n, j)
                    }
                    e[a] = j
                }
            },
            this)
        } else {
            i = f.getChanges();
            for (m in i) {
                if (i.hasOwnProperty(m)) {
                    h = g.get(m);
                    if (h.getPersist()) {
                        a = h.config[d] || h.getName();
                        j = i[m];
                        if (h.getType().type == "date") {
                            j = this.writeDate(h, j)
                        }
                        e[a] = j
                    }
                }
            }
            if (!k) {
                e[f.getIdProperty()] = f.getId()
            }
        }
        return e
    }
});
Ext.define("Ext.data.writer.Json", {
    extend: Ext.data.writer.Writer,
    alternateClassName: "Ext.data.JsonWriter",
    alias: "writer.json",
    config: {
        rootProperty: undefined,
        encode: false,
        allowSingle: true,
        encodeRequest: false
    },
    applyRootProperty: function(a) {
        if (!a && (this.getEncode() || this.getEncodeRequest())) {
            a = "data"
        }
        return a
    },
    writeRecords: function(e, f) {
        var a = this.getRootProperty(),
        g = e.getParams(),
        b = this.getAllowSingle(),
        d;
        if (this.getAllowSingle() && f && f.length == 1) {
            f = f[0]
        }
        if (this.getEncodeRequest()) {
            d = e.getJsonData() || {};
            if (f && (f.length || (b && Ext.isObject(f)))) {
                d[a] = f
            }
            e.setJsonData(Ext.apply(d, g || {}));
            e.setParams(null);
            e.setMethod("POST");
            return e
        }
        if (!f || !(f.length || (b && Ext.isObject(f)))) {
            return e
        }
        if (this.getEncode()) {
            if (a) {
                g[a] = Ext.encode(f)
            } else {}
        } else {
            d = e.getJsonData() || {};
            if (a) {
                d[a] = f
            } else {
                d = f
            }
            e.setJsonData(d)
        }
        return e
    }
});
Ext.define("Ext.data.Batch", {
    mixins: {
        observable: Ext.mixin.Observable
    },
    config: {
        autoStart: false,
        pauseOnException: true,
        proxy: null
    },
    current: -1,
    total: 0,
    isRunning: false,
    isComplete: false,
    hasException: false,
    constructor: function(a) {
        var b = this;
        b.initConfig(a);
        b.operations = []
    },
    add: function(a) {
        this.total++;
        a.setBatch(this);
        this.operations.push(a)
    },
    start: function() {
        this.hasException = false;
        this.isRunning = true;
        this.runNextOperation()
    },
    runNextOperation: function() {
        this.runOperation(this.current + 1)
    },
    pause: function() {
        this.isRunning = false
    },
    runOperation: function(e) {
        var f = this,
        d = f.operations,
        b = d[e],
        a;
        if (b === undefined) {
            f.isRunning = false;
            f.isComplete = true;
            f.fireEvent("complete", f, d[d.length - 1])
        } else {
            f.current = e;
            a = function(g) {
                var h = g.hasException();
                if (h) {
                    f.hasException = true;
                    f.fireEvent("exception", f, g)
                } else {
                    f.fireEvent("operationcomplete", f, g)
                }
                if (h && f.getPauseOnException()) {
                    f.pause()
                } else {
                    g.setCompleted();
                    f.runNextOperation()
                }
            };
            b.setStarted();
            f.getProxy()[b.getAction()](b, a, f)
        }
    }
});
Ext.define("Ext.data.Operation", {
    config: {
        synchronous: true,
        action: null,
        filters: null,
        sorters: null,
        grouper: null,
        start: null,
        limit: null,
        batch: null,
        callback: null,
        scope: null,
        resultSet: null,
        records: null,
        request: null,
        response: null,
        withCredentials: null,
        params: null,
        url: null,
        page: null,
        node: null,
        model: undefined,
        addRecords: false
    },
    started: false,
    running: false,
    complete: false,
    success: undefined,
    exception: false,
    error: undefined,
    constructor: function(a) {
        this.initConfig(a)
    },
    applyModel: function(a) {
        if (typeof a == "string") {
            a = Ext.data.ModelManager.getModel(a);
            if (!a) {
                Ext.Logger.error("Model with name " + arguments[0] + " doesnt exist.")
            }
        }
        if (a && !a.prototype.isModel && Ext.isObject(a)) {
            a = Ext.data.ModelManager.registerType(a.storeId || a.id || Ext.id(), a)
        }
        return a
    },
    getRecords: function() {
        var a = this.getResultSet();
        return this._records || (a ? a.getRecords() : [])
    },
    setStarted: function() {
        this.started = true;
        this.running = true
    },
    setCompleted: function() {
        this.complete = true;
        this.running = false
    },
    setSuccessful: function() {
        this.success = true
    },
    setException: function(a) {
        this.exception = true;
        this.success = false;
        this.running = false;
        this.error = a
    },
    hasException: function() {
        return this.exception === true
    },
    getError: function() {
        return this.error
    },
    isStarted: function() {
        return this.started === true
    },
    isRunning: function() {
        return this.running === true
    },
    isComplete: function() {
        return this.complete === true
    },
    wasSuccessful: function() {
        return this.isComplete() && this.success === true
    },
    allowWrite: function() {
        return this.getAction() != "read"
    },
    process: function(e, b, d, a) {
        if (b.getSuccess() !== false) {
            this.setResponse(a);
            this.setResultSet(b);
            this.setCompleted();
            this.setSuccessful()
        } else {
            this.setResponse(a);
            this.setResultSet(b);
            return false
        }
        return this["process" + Ext.String.capitalize(e)].call(this, b, d, a)
    },
    processRead: function(e) {
        var b = e.getRecords(),
        h = [],
        g = this.getModel(),
        f = b.length,
        d,
        a;
        for (d = 0; d < f; d++) {
            a = b[d];
            h.push(new g(a.data, a.id, a.node))
        }
        this.setRecords(h);
        e.setRecords(h);
        return true
    },
    processCreate: function(f) {
        var d = f.getRecords(),
        b = this.getRecords(),
        g = d.length,
        e,
        a,
        h;
        for (e = 0; e < g; e++) {
            h = d[e];
            if (h.clientId === null && b.length == 1 && d.length == 1) {
                a = b[e]
            } else {
                a = this.findCurrentRecord(h.clientId)
            }
            if (a) {
                this.updateRecord(a, h)
            }
        }
        return true
    },
    processUpdate: function(f) {
        var d = f.getRecords(),
        b = this.getRecords(),
        g = d.length,
        e,
        a,
        h;
        for (e = 0; e < g; e++) {
            h = d[e];
            a = b[e];
            if (a) {
                this.updateRecord(a, h)
            }
        }
        return true
    },
    processDestroy: function(e) {
        var b = e.getRecords(),
        f = b.length,
        d,
        a,
        g;
        for (d = 0; d < f; d++) {
            g = b[d];
            a = this.findCurrentRecord(g.id);
            if (a) {
                a.setIsErased(true);
                a.notifyStores("afterErase", a)
            }
        }
    },
    findCurrentRecord: function(a) {
        var d = this.getRecords(),
        f = d.length,
        e,
        b;
        for (e = 0; e < f; e++) {
            b = d[e];
            if (b.getId() === a) {
                return b
            }
        }
    },
    updateRecord: function(b, e) {
        var a = e.data,
        d = e.id;
        b.beginEdit();
        b.set(a);
        if (d !== null) {
            b.setId(d)
        }
        b.endEdit(true);
        b.commit()
    }
});
Ext.define("Ext.data.proxy.Proxy", {
    extend: Ext.Evented,
    alias: "proxy.proxy",
    alternateClassName: ["Ext.data.DataProxy", "Ext.data.Proxy"],
    config: {
        batchOrder: "create,update,destroy",
        batchActions: true,
        model: null,
        reader: {
            type: "json"
        },
        writer: {
            type: "json"
        }
    },
    isProxy: true,
    applyModel: function(a) {
        if (typeof a == "string") {
            a = Ext.data.ModelManager.getModel(a);
            if (!a) {
                Ext.Logger.error("Model with name " + arguments[0] + " doesnt exist.")
            }
        }
        if (a && !a.prototype.isModel && Ext.isObject(a)) {
            a = Ext.data.ModelManager.registerType(a.storeId || a.id || Ext.id(), a)
        }
        return a
    },
    updateModel: function(b) {
        if (b) {
            var a = this.getReader();
            if (a && !a.getModel()) {
                a.setModel(b)
            }
        }
    },
    applyReader: function(b, a) {
        return Ext.factory(b, Ext.data.Reader, a, "reader")
    },
    updateReader: function(a) {
        if (a) {
            var b = this.getModel();
            if (!b) {
                b = a.getModel();
                if (b) {
                    this.setModel(b)
                }
            } else {
                a.setModel(b)
            }
            if (a.onMetaChange) {
                a.onMetaChange = Ext.Function.createSequence(a.onMetaChange, this.onMetaChange, this)
            }
        }
    },
    onMetaChange: function(b) {
        var a = this.getReader().getModel();
        if (!this.getModel() && a) {
            this.setModel(a)
        }
        this.fireEvent("metachange", this, b)
    },
    applyWriter: function(b, a) {
        return Ext.factory(b, Ext.data.Writer, a, "writer")
    },
    create: Ext.emptyFn,
    read: Ext.emptyFn,
    update: Ext.emptyFn,
    destroy: Ext.emptyFn,
    onDestroy: function() {
        Ext.destroy(this.getReader(), this.getWriter());
        Ext.Evented.prototype.destroy.apply(this, arguments)
    },
    batch: function(f, g) {
        var h = this,
        e = h.getBatchActions(),
        d = h.getModel(),
        b,
        a;
        if (f.operations === undefined) {
            f = {
                operations: f,
                listeners: g
            }
        }
        if (f.batch && f.batch.isBatch) {
            b = f.batch
        } else {
            b = new Ext.data.Batch(f.batch || {})
        }
        b.setProxy(h);
        b.on("complete", Ext.bind(h.onBatchComplete, h, [f], 0));
        if (f.listeners) {
            b.on(f.listeners)
        }
        Ext.each(h.getBatchOrder().split(","),
        function(i) {
            a = f.operations[i];
            if (a) {
                if (e) {
                    b.add(new Ext.data.Operation({
                        action: i,
                        records: a,
                        model: d
                    }))
                } else {
                    Ext.each(a,
                    function(j) {
                        b.add(new Ext.data.Operation({
                            action: i,
                            records: [j],
                            model: d
                        }))
                    })
                }
            }
        },
        h);
        b.start();
        return b
    },
    onBatchComplete: function(a, b) {
        var d = a.scope || this;
        if (b.hasException) {
            if (Ext.isFunction(a.failure)) {
                Ext.callback(a.failure, d, [b, a])
            }
        } else {
            if (Ext.isFunction(a.success)) {
                Ext.callback(a.success, d, [b, a])
            }
        }
        if (Ext.isFunction(a.callback)) {
            Ext.callback(a.callback, d, [b, a])
        }
        Ext.destroy(b)
    }
},
function() {});
Ext.define("Ext.data.proxy.Client", {
    extend: Ext.data.proxy.Proxy,
    alternateClassName: "Ext.proxy.ClientProxy",
    clear: function() {}
});
Ext.define("Ext.data.proxy.Memory", {
    extend: Ext.data.proxy.Client,
    alias: "proxy.memory",
    alternateClassName: "Ext.data.MemoryProxy",
    isMemoryProxy: true,
    config: {
        data: []
    },
    finishOperation: function(b, g, e) {
        if (b) {
            var d = 0,
            f = b.getRecords(),
            a = f.length;
            for (d; d < a; d++) {
                f[d].commit()
            }
            b.setCompleted();
            b.setSuccessful();
            Ext.callback(g, e || this, [b])
        }
    },
    create: function() {
        this.finishOperation.apply(this, arguments)
    },
    update: function() {
        this.finishOperation.apply(this, arguments)
    },
    destroy: function() {
        this.finishOperation.apply(this, arguments)
    },
    read: function(b, f, d) {
        var e = this,
        a = e.getReader();
        if (b.process("read", a.process(e.getData())) === false) {
            this.fireEvent("exception", this, null, b)
        }
        Ext.callback(f, d || e, [b])
    },
    clear: Ext.emptyFn
});
Ext.define("Ext.data.reader.Array", {
    extend: Ext.data.reader.Json,
    alternateClassName: "Ext.data.ArrayReader",
    alias: "reader.array",
    config: {
        totalProperty: undefined,
        successProperty: undefined
    },
    createFieldAccessExpression: function(h, d, b) {
        var g = this,
        f = h.getMapping(),
        e = (f == null) ? g.getModel().getFields().indexOf(h) : f,
        a;
        if (typeof e === "function") {
            a = d + ".getMapping()(" + b + ", this)"
        } else {
            if (isNaN(e)) {
                e = '"' + e + '"'
            }
            a = b + "[" + e + "]"
        }
        return a
    }
});
Ext.define("Ext.data.StoreManager", {
    extend: Ext.util.Collection,
    alternateClassName: ["Ext.StoreMgr", "Ext.data.StoreMgr", "Ext.StoreManager"],
    singleton: true,
    register: function() {
        for (var a = 0,
        b; (b = arguments[a]); a++) {
            this.add(b)
        }
    },
    unregister: function() {
        for (var a = 0,
        b; (b = arguments[a]); a++) {
            this.remove(this.lookup(b))
        }
    },
    lookup: function(d) {
        if (Ext.isArray(d)) {
            var b = ["field1"],
            f = !Ext.isArray(d[0]),
            g = d,
            e,
            a;
            if (f) {
                g = [];
                for (e = 0, a = d.length; e < a; ++e) {
                    g.push([d[e]])
                }
            } else {
                for (e = 2, a = d[0].length; e <= a; ++e) {
                    b.push("field" + e)
                }
            }
            return Ext.create("Ext.data.ArrayStore", {
                data: g,
                fields: b,
                autoDestroy: true,
                autoCreated: true,
                expanded: f
            })
        }
        if (Ext.isString(d)) {
            return this.get(d)
        } else {
            if (d instanceof Ext.data.Store) {
                return d
            } else {
                return Ext.factory(d, Ext.data.Store, null, "store")
            }
        }
    },
    getKey: function(a) {
        return a.getStoreId()
    }
},
function() {
    Ext.regStore = function(d, b) {
        var a;
        if (Ext.isObject(d)) {
            b = d
        } else {
            if (b instanceof Ext.data.Store) {
                b.setStoreId(d)
            } else {
                b.storeId = d
            }
        }
        if (b instanceof Ext.data.Store) {
            a = b
        } else {
            a = Ext.create("Ext.data.Store", b)
        }
        return Ext.data.StoreManager.register(a)
    };
    Ext.getStore = function(a) {
        return Ext.data.StoreManager.lookup(a)
    }
});
Ext.define("Ext.mixin.Selectable", {
    extend: Ext.mixin.Mixin,
    mixinConfig: {
        id: "selectable",
        hooks: {
            updateStore: "updateStore"
        }
    },
    config: {
        disableSelection: null,
        mode: "SINGLE",
        allowDeselect: false,
        lastSelected: null,
        lastFocused: null,
        deselectOnContainerClick: true
    },
    modes: {
        SINGLE: true,
        SIMPLE: true,
        MULTI: true
    },
    selectableEventHooks: {
        addrecords: "onSelectionStoreAdd",
        removerecords: "onSelectionStoreRemove",
        updaterecord: "onSelectionStoreUpdate",
        load: "refreshSelection",
        refresh: "refreshSelection"
    },
    constructor: function() {
        this.selected = new Ext.util.MixedCollection();
        this.callParent(arguments)
    },
    applyMode: function(a) {
        a = a ? a.toUpperCase() : "SINGLE";
        return this.modes[a] ? a: "SINGLE"
    },
    updateStore: function(a, d) {
        var b = this,
        e = Ext.apply({},
        b.selectableEventHooks, {
            scope: b
        });
        if (d && Ext.isObject(d) && d.isStore) {
            if (d.autoDestroy) {
                d.destroy()
            } else {
                d.un(e);
                if (a) {
                    a.un("clear", "onSelectionStoreClear", this)
                }
            }
        }
        if (a) {
            a.on(e);
            a.onBefore("clear", "onSelectionStoreClear", this);
            b.refreshSelection()
        }
    },
    selectAll: function(a) {
        var d = this,
        b = d.getStore().getRange();
        d.select(b, true, a)
    },
    deselectAll: function(d) {
        var b = this,
        a = b.getStore().getRange();
        b.deselect(a, d);
        b.selected.clear();
        b.setLastSelected(null);
        b.setLastFocused(null)
    },
    selectWithEvent: function(a) {
        var d = this,
        b = d.isSelected(a);
        switch (d.getMode()) {
        case "MULTI":
        case "SIMPLE":
            if (b) {
                d.deselect(a)
            } else {
                d.select(a, true)
            }
            break;
        case "SINGLE":
            if (d.getAllowDeselect() && b) {
                d.deselect(a)
            } else {
                d.select(a, false)
            }
            break
        }
    },
    selectRange: function(d, h, j) {
        var g = this,
        b = g.getStore(),
        a = [],
        f,
        e;
        if (g.getDisableSelection()) {
            return
        }
        if (d > h) {
            f = h;
            h = d;
            d = f
        }
        for (e = d; e <= h; e++) {
            a.push(b.getAt(e))
        }
        this.doMultiSelect(a, j)
    },
    select: function(d, f, b) {
        var e = this,
        a;
        if (e.getDisableSelection()) {
            return
        }
        if (typeof d === "number") {
            d = [e.getStore().getAt(d)]
        }
        if (!d) {
            return
        }
        if (e.getMode() == "SINGLE" && d) {
            a = d.length ? d[0] : d;
            e.doSingleSelect(a, b)
        } else {
            e.doMultiSelect(d, f, b)
        }
    },
    doSingleSelect: function(a, b) {
        var e = this,
        d = e.selected;
        if (e.getDisableSelection()) {
            return
        }
        if (e.isSelected(a)) {
            return
        }
        if (d.getCount() > 0) {
            e.deselect(e.getLastSelected(), b)
        }
        d.add(a);
        e.setLastSelected(a);
        e.onItemSelect(a, b);
        e.setLastFocused(a);
        if (!b) {
            e.fireSelectionChange([a])
        }
    },
    doMultiSelect: function(a, k, j) {
        if (a === null || this.getDisableSelection()) {
            return
        }
        a = !Ext.isArray(a) ? [a] : a;
        var g = this,
        b = g.selected,
        f = a.length,
        h = false,
        d = 0,
        e;
        if (!k && b.getCount() > 0) {
            h = true;
            g.deselect(g.getSelection(), true)
        }
        for (; d < f; d++) {
            e = a[d];
            if (k && g.isSelected(e)) {
                continue
            }
            h = true;
            g.setLastSelected(e);
            b.add(e);
            if (!j) {
                g.setLastFocused(e)
            }
            g.onItemSelect(e, j)
        }
        if (h && !j) {
            this.fireSelectionChange(a)
        }
    },
    deselect: function(a, k) {
        var g = this;
        if (g.getDisableSelection()) {
            return
        }
        a = Ext.isArray(a) ? a: [a];
        var b = g.selected,
        h = false,
        d = 0,
        j = g.getStore(),
        f = a.length,
        e;
        for (; d < f; d++) {
            e = a[d];
            if (typeof e === "number") {
                e = j.getAt(e)
            }
            if (b.remove(e)) {
                if (g.getLastSelected() == e) {
                    g.setLastSelected(b.last())
                }
                h = true
            }
            if (e) {
                g.onItemDeselect(e, k)
            }
        }
        if (h && !k) {
            g.fireSelectionChange(a)
        }
    },
    updateLastFocused: function(b, a) {
        this.onLastFocusChanged(a, b)
    },
    fireSelectionChange: function(a) {
        var b = this;
        b.fireAction("selectionchange", [b, a], "getSelection")
    },
    getSelection: function() {
        return this.selected.getRange()
    },
    isSelected: function(a) {
        a = Ext.isNumber(a) ? this.getStore().getAt(a) : a;
        return this.selected.indexOf(a) !== -1
    },
    hasSelection: function() {
        return this.selected.getCount() > 0
    },
    refreshSelection: function() {
        var b = this,
        a = b.getSelection();
        b.deselectAll(true);
        if (a.length) {
            b.select(a, false, true)
        }
    },
    onSelectionStoreRemove: function(d, b) {
        var h = this,
        f = h.selected,
        g = b.length,
        a, e;
        if (h.getDisableSelection()) {
            return
        }
        for (e = 0; e < g; e++) {
            a = b[e];
            if (f.remove(a)) {
                if (h.getLastSelected() == a) {
                    h.setLastSelected(null)
                }
                if (h.getLastFocused() == a) {
                    h.setLastFocused(null)
                }
                h.fireSelectionChange([a])
            }
        }
    },
    onSelectionStoreClear: function(b) {
        var a = b.getData().items;
        this.onSelectionStoreRemove(b, a)
    },
    getSelectionCount: function() {
        return this.selected.getCount()
    },
    onSelectionStoreAdd: Ext.emptyFn,
    onSelectionStoreUpdate: Ext.emptyFn,
    onItemSelect: Ext.emptyFn,
    onItemDeselect: Ext.emptyFn,
    onLastFocusChanged: Ext.emptyFn,
    onEditorKey: Ext.emptyFn
},
function() {});
Ext.define("Ext.dataview.component.DataItem", {
    extend: Ext.Container,
    xtype: "dataitem",
    config: {
        baseCls: Ext.baseCSSPrefix + "data-item",
        defaultType: "component",
        record: null,
        itemCls: null,
        dataMap: {},
        dataview: null,
        width: "100%",
        items: [{
            xtype: "component"
        }]
    },
    updateBaseCls: function(a, b) {
        var d = this;
        d.callParent(arguments)
    },
    updateItemCls: function(b, a) {
        if (a) {
            this.removeCls(a)
        }
        if (b) {
            this.addCls(b)
        }
    },
    doMapData: function(e, h, g) {
        var a, f, d, b;
        for (a in e) {
            d = e[a];
            f = this[a]();
            if (f) {
                for (b in d) {
                    if (h && f[b] && h[d[b]] !== undefined && h[d[b]] !== null) {
                        f[b](h[d[b]])
                    }
                }
            }
        }
        if (g) {
            g.updateData(h)
        }
    },
    updateRecord: function(e) {
        if (!e) {
            return
        }
        this._record = e;
        var g = this,
        a = g.dataview || this.getDataview(),
        h = a.prepareData(e.getData(true), a.getStore().indexOf(e), e),
        d = g.getItems(),
        f = d.first(),
        b = g.getDataMap();
        if (!f) {
            return
        }
        if (b) {
            this.doMapData(b, h, f)
        }
        g.fireEvent("updatedata", g, h)
    }
});
Ext.define("Ext.dataview.component.Container", {
    extend: Ext.Container,
    constructor: function() {
        this.itemCache = [];
        this.callParent(arguments)
    },
    doInitialize: function() {
        this.innerElement.on({
            touchstart: "onItemTouchStart",
            touchend: "onItemTouchEnd",
            tap: "onItemTap",
            taphold: "onItemTapHold",
            touchmove: "onItemTouchMove",
            singletap: "onItemSingleTap",
            doubletap: "onItemDoubleTap",
            swipe: "onItemSwipe",
            delegate: "> ." + Ext.baseCSSPrefix + "data-item",
            scope: this
        })
    },
    initialize: function() {
        this.callParent();
        this.doInitialize()
    },
    onItemTouchStart: function(f) {
        var b = this,
        d = f.getTarget(),
        a = Ext.getCmp(d.id);
        a.on({
            touchmove: "onItemTouchMove",
            scope: b,
            single: true
        });
        b.fireEvent("itemtouchstart", b, a, b.indexOf(a), f)
    },
    onItemTouchMove: function(f) {
        var b = this,
        d = f.getTarget(),
        a = Ext.getCmp(d.id);
        b.fireEvent("itemtouchmove", b, a, b.indexOf(a), f)
    },
    onItemTouchEnd: function(f) {
        var b = this,
        d = f.getTarget(),
        a = Ext.getCmp(d.id);
        a.un({
            touchmove: "onItemTouchMove",
            scope: b
        });
        b.fireEvent("itemtouchend", b, a, b.indexOf(a), f)
    },
    onItemTap: function(f) {
        var b = this,
        d = f.getTarget(),
        a = Ext.getCmp(d.id);
        b.fireEvent("itemtap", b, a, b.indexOf(a), f)
    },
    onItemTapHold: function(f) {
        var b = this,
        d = f.getTarget(),
        a = Ext.getCmp(d.id);
        b.fireEvent("itemtaphold", b, a, b.indexOf(a), f)
    },
    onItemSingleTap: function(f) {
        var b = this,
        d = f.getTarget(),
        a = Ext.getCmp(d.id);
        b.fireEvent("itemsingletap", b, a, b.indexOf(a), f)
    },
    onItemDoubleTap: function(f) {
        var b = this,
        d = f.getTarget(),
        a = Ext.getCmp(d.id);
        b.fireEvent("itemdoubletap", b, a, b.indexOf(a), f)
    },
    onItemSwipe: function(f) {
        var b = this,
        d = f.getTarget(),
        a = Ext.getCmp(d.id);
        b.fireEvent("itemswipe", b, a, b.indexOf(a), f)
    },
    moveItemsToCache: function(k, m) {
        var j = this,
        d = j.dataview,
        a = d.getMaxItemCache(),
        h = j.getViewItems(),
        g = j.itemCache,
        f = g.length,
        n = d.getPressedCls(),
        e = d.getSelectedCls(),
        b = m - k,
        o;
        for (; b >= 0; b--) {
            o = h[k + b];
            if (f !== a) {
                j.remove(o, false);
                o.removeCls([n, e]);
                g.push(o);
                f++
            } else {
                o.destroy()
            }
        }
        if (j.getViewItems().length == 0) {
            this.dataview.showEmptyText()
        }
    },
    moveItemsFromCache: function(b) {
        var n = this,
        f = n.dataview,
        o = f.getStore(),
        m = b.length,
        a = f.getDefaultType(),
        j = f.getItemConfig(),
        h = n.itemCache,
        g = h.length,
        k = [],
        d,
        p,
        e;
        if (m) {
            f.hideEmptyText()
        }
        for (d = 0; d < m; d++) {
            b[d]._tmpIndex = o.indexOf(b[d])
        }
        Ext.Array.sort(b,
        function(q, i) {
            return q._tmpIndex > i._tmpIndex ? 1 : -1
        });
        for (d = 0; d < m; d++) {
            e = b[d];
            if (g) {
                g--;
                p = h.pop();
                this.updateListItem(e, p)
            } else {
                p = n.getDataItemConfig(a, e, j)
            }
            p = this.insert(e._tmpIndex, p);
            delete e._tmpIndex
        }
        return k
    },
    getViewItems: function() {
        return this.getInnerItems()
    },
    updateListItem: function(a, b) {
        if (b.updateRecord) {
            if (b.getRecord() === a) {
                b.updateRecord(a)
            } else {
                b.setRecord(a)
            }
        }
    },
    getDataItemConfig: function(f, b, d) {
        var a = this.dataview,
        e = {
            xtype: f,
            record: b,
            itemCls: a.getItemCls(),
            defaults: d,
            dataview: a
        };
        return Ext.merge(e, d)
    },
    doRemoveItemCls: function(a) {
        var b = this.getViewItems(),
        e = b.length,
        d = 0;
        for (; d < e; d++) {
            b[d].removeCls(a)
        }
    },
    doAddItemCls: function(a) {
        var b = this.getViewItems(),
        e = b.length,
        d = 0;
        for (; d < e; d++) {
            b[d].addCls(a)
        }
    },
    updateAtNewIndex: function(d, b, a) {
        this.moveItemsToCache(d, d);
        this.moveItemsFromCache([a])
    },
    destroy: function() {
        var e = this,
        b = e.itemCache,
        d = b.length,
        a = 0;
        for (; a < d; a++) {
            b[a].destroy()
        }
        this.callParent()
    }
});
Ext.define("Ext.dataview.element.Container", {
    extend: Ext.Component,
    doInitialize: function() {
        this.element.on({
            touchstart: "onItemTouchStart",
            touchend: "onItemTouchEnd",
            tap: "onItemTap",
            taphold: "onItemTapHold",
            touchmove: "onItemTouchMove",
            singletap: "onItemSingleTap",
            doubletap: "onItemDoubleTap",
            swipe: "onItemSwipe",
            delegate: "> div",
            scope: this
        })
    },
    initialize: function() {
        this.callParent();
        this.doInitialize()
    },
    updateBaseCls: function(a, b) {
        var d = this;
        d.callParent([a + "-container", b])
    },
    onItemTouchStart: function(f) {
        var b = this,
        d = f.getTarget(),
        a = b.getViewItems().indexOf(d);
        Ext.get(d).on({
            touchmove: "onItemTouchMove",
            scope: b,
            single: true
        });
        b.fireEvent("itemtouchstart", b, Ext.get(d), a, f)
    },
    onItemTouchEnd: function(f) {
        var b = this,
        d = f.getTarget(),
        a = b.getViewItems().indexOf(d);
        Ext.get(d).un({
            touchmove: "onItemTouchMove",
            scope: b
        });
        b.fireEvent("itemtouchend", b, Ext.get(d), a, f)
    },
    onItemTouchMove: function(f) {
        var b = this,
        d = f.getTarget(),
        a = b.getViewItems().indexOf(d);
        b.fireEvent("itemtouchmove", b, Ext.get(d), a, f)
    },
    onItemTap: function(f) {
        var b = this,
        d = f.getTarget(),
        a = b.getViewItems().indexOf(d);
        b.fireEvent("itemtap", b, Ext.get(d), a, f)
    },
    onItemTapHold: function(f) {
        var b = this,
        d = f.getTarget(),
        a = b.getViewItems().indexOf(d);
        b.fireEvent("itemtaphold", b, Ext.get(d), a, f)
    },
    onItemDoubleTap: function(f) {
        var b = this,
        d = f.getTarget(),
        a = b.getViewItems().indexOf(d);
        b.fireEvent("itemdoubletap", b, Ext.get(d), a, f)
    },
    onItemSingleTap: function(f) {
        var b = this,
        d = f.getTarget(),
        a = b.getViewItems().indexOf(d);
        b.fireEvent("itemsingletap", b, Ext.get(d), a, f)
    },
    onItemSwipe: function(f) {
        var b = this,
        d = f.getTarget(),
        a = b.getViewItems().indexOf(d);
        b.fireEvent("itemswipe", b, Ext.get(d), a, f)
    },
    updateListItem: function(b, g) {
        var f = this,
        a = f.dataview,
        d = a.getStore(),
        e = d.indexOf(b),
        h = a.prepareData(b.getData(true), e, b);
        h.xcount = d.getCount();
        h.xindex = typeof h.xindex === "number" ? h.xindex: e;
        g.innerHTML = a.getItemTpl().apply(h)
    },
    addListItem: function(f, d) {
        var i = this,
        e = i.dataview,
        j = e.getStore(),
        a = e.prepareData(d.getData(true), f, d),
        b = i.element,
        k = b.dom.childNodes,
        h = k.length,
        g;
        a.xcount = typeof a.xcount === "number" ? a.xcount: j.getCount();
        a.xindex = typeof a.xindex === "number" ? a.xindex: f;
        g = Ext.Element.create(this.getItemElementConfig(f, a));
        if (!h || f == h) {
            g.appendTo(b)
        } else {
            g.insertBefore(k[f])
        }
    },
    getItemElementConfig: function(d, f) {
        var b = this.dataview,
        e = b.getItemCls(),
        a = b.getBaseCls() + "-item";
        if (e) {
            a += " " + e
        }
        return {
            cls: a,
            html: b.getItemTpl().apply(f)
        }
    },
    doRemoveItemCls: function(a) {
        var e = this.getViewItems(),
        d = e.length,
        b = 0;
        for (; b < d; b++) {
            Ext.fly(e[b]).removeCls(a)
        }
    },
    doAddItemCls: function(a) {
        var e = this.getViewItems(),
        d = e.length,
        b = 0;
        for (; b < d; b++) {
            Ext.fly(e[b]).addCls(a)
        }
    },
    moveItemsToCache: function(g, f) {
        var e = this,
        a = e.getViewItems(),
        b = f - g,
        d;
        for (; b >= 0; b--) {
            d = a[g + b];
            Ext.get(d).destroy()
        }
        if (e.getViewItems().length == 0) {
            this.dataview.showEmptyText()
        }
    },
    moveItemsFromCache: function(e) {
        var h = this,
        b = h.dataview,
        d = b.getStore(),
        g = e.length,
        f,
        a;
        if (g) {
            b.hideEmptyText()
        }
        for (f = 0; f < g; f++) {
            e[f]._tmpIndex = d.indexOf(e[f])
        }
        Ext.Array.sort(e,
        function(j, i) {
            return j._tmpIndex > i._tmpIndex ? 1 : -1
        });
        for (f = 0; f < g; f++) {
            a = e[f];
            h.addListItem(a._tmpIndex, a);
            delete a._tmpIndex
        }
    },
    getViewItems: function() {
        return Array.prototype.slice.call(this.element.dom.childNodes)
    },
    updateAtNewIndex: function(d, b, a) {
        this.moveItemsToCache(d, d);
        this.moveItemsFromCache([a])
    },
    destroy: function() {
        var d = this.getViewItems(),
        b = d.length,
        a = 0;
        for (; a < b; a++) {
            Ext.get(d[a]).destroy()
        }
        this.callParent()
    }
});
Ext.define("Ext.dataview.DataView", {
    extend: Ext.Container,
    alternateClassName: "Ext.DataView",
    mixins: [Ext.mixin.Selectable],
    xtype: "dataview",
    config: {
        store: null,
        data: null,
        baseCls: Ext.baseCSSPrefix + "dataview",
        emptyText: null,
        deferEmptyText: true,
        itemTpl: "<div>{text}</div>",
        pressedCls: "x-item-pressed",
        itemCls: null,
        selectedCls: "x-item-selected",
        triggerEvent: "itemtap",
        triggerCtEvent: "tap",
        deselectOnContainerClick: true,
        scrollable: true,
        inline: null,
        pressedDelay: 100,
        loadingText: "Loading...",
        useComponents: null,
        itemConfig: {},
        maxItemCache: 20,
        defaultType: "dataitem",
        scrollToTopOnRefresh: true
    },
    constructor: function(a) {
        var d = this,
        b;
        d.hasLoadedStore = false;
        d.mixins.selectable.constructor.apply(d, arguments);
        d.indexOffset = 0;
        d.callParent(arguments)
    },
    updateItemCls: function(d, b) {
        var a = this.container;
        if (a) {
            if (b) {
                a.doRemoveItemCls(b)
            }
            if (d) {
                a.doAddItemCls(d)
            }
        }
    },
    storeEventHooks: {
        beforeload: "onBeforeLoad",
        load: "onLoad",
        refresh: "refresh",
        addrecords: "onStoreAdd",
        removerecords: "onStoreRemove",
        updaterecord: "onStoreUpdate"
    },
    initialize: function() {
        this.callParent();
        var b = this,
        a, d = b.getTriggerEvent();
        b.on(b.getTriggerCtEvent(), b.onContainerTrigger, b);
        a = b.container = this.add(new Ext.dataview[b.getUseComponents() ? "component": "element"].Container({
            baseCls: this.getBaseCls()
        }));
        a.dataview = b;
        if (d) {
            b.on(d, b.onItemTrigger, b)
        }
        a.on({
            itemtouchstart: "onItemTouchStart",
            itemtouchend: "onItemTouchEnd",
            itemtap: "onItemTap",
            itemtaphold: "onItemTapHold",
            itemtouchmove: "onItemTouchMove",
            itemsingletap: "onItemSingleTap",
            itemdoubletap: "onItemDoubleTap",
            itemswipe: "onItemSwipe",
            scope: b
        });
        if (b.getStore()) {
            if (b.isPainted()) {
                b.refresh()
            } else {
                b.on({
                    painted: "refresh",
                    single: true
                })
            }
        }
    },
    applyInline: function(a) {
        if (Ext.isObject(a)) {
            a = Ext.apply({},
            a)
        }
        return a
    },
    updateInline: function(d, b) {
        var a = this.getBaseCls();
        if (b) {
            this.removeCls([a + "-inlineblock", a + "-nowrap"])
        }
        if (d) {
            this.addCls(a + "-inlineblock");
            if (Ext.isObject(d) && d.wrap === false) {
                this.addCls(a + "-nowrap")
            } else {
                this.removeCls(a + "-nowrap")
            }
        }
    },
    prepareData: function(d, b, a) {
        return d
    },
    onContainerTrigger: function(b) {
        var a = this;
        if (b.target != a.element.dom) {
            return
        }
        if (a.getDeselectOnContainerClick() && a.getStore()) {
            a.deselectAll()
        }
    },
    onItemTrigger: function(b, a) {
        if (!this.isDestroyed) {
            this.selectWithEvent(this.getStore().getAt(a))
        }
    },
    doAddPressedCls: function(a) {
        var d = this,
        b = d.getItemAt(d.getStore().indexOf(a));
        if (Ext.isElement(b)) {
            b = Ext.get(b)
        }
        if (b) {
            if (b.isComponent) {
                b.renderElement.addCls(d.getPressedCls())
            } else {
                b.addCls(d.getPressedCls())
            }
        }
    },
    onItemTouchStart: function(b, i, f, h) {
        var g = this,
        d = g.getStore(),
        a = d && d.getAt(f);
        g.fireAction("itemtouchstart", [g, f, i, a, h], "doItemTouchStart")
    },
    doItemTouchStart: function(d, b, f, a) {
        var e = d.getPressedDelay();
        if (a) {
            if (e > 0) {
                d.pressedTimeout = Ext.defer(d.doAddPressedCls, e, d, [a])
            } else {
                d.doAddPressedCls(a)
            }
        }
    },
    onItemTouchEnd: function(b, i, f, h) {
        var g = this,
        d = g.getStore(),
        a = d && d.getAt(f);
        if (this.hasOwnProperty("pressedTimeout")) {
            clearTimeout(this.pressedTimeout);
            delete this.pressedTimeout
        }
        if (a && i) {
            if (i.isComponent) {
                i.renderElement.removeCls(g.getPressedCls())
            } else {
                i.removeCls(g.getPressedCls())
            }
        }
        g.fireEvent("itemtouchend", g, f, i, a, h)
    },
    onItemTouchMove: function(b, i, f, h) {
        var g = this,
        d = g.getStore(),
        a = d && d.getAt(f);
        if (g.hasOwnProperty("pressedTimeout")) {
            clearTimeout(g.pressedTimeout);
            delete g.pressedTimeout
        }
        if (a && i) {
            if (i.isComponent) {
                i.renderElement.removeCls(g.getPressedCls())
            } else {
                i.removeCls(g.getPressedCls())
            }
        }
        g.fireEvent("itemtouchmove", g, f, i, a, h)
    },
    onItemTap: function(b, i, f, h) {
        var g = this,
        d = g.getStore(),
        a = d && d.getAt(f);
        g.fireEvent("itemtap", g, f, i, a, h)
    },
    onItemTapHold: function(b, i, f, h) {
        var g = this,
        d = g.getStore(),
        a = d && d.getAt(f);
        g.fireEvent("itemtaphold", g, f, i, a, h)
    },
    onItemSingleTap: function(b, i, f, h) {
        var g = this,
        d = g.getStore(),
        a = d && d.getAt(f);
        g.fireEvent("itemsingletap", g, f, i, a, h)
    },
    onItemDoubleTap: function(b, i, f, h) {
        var g = this,
        d = g.getStore(),
        a = d && d.getAt(f);
        g.fireEvent("itemdoubletap", g, f, i, a, h)
    },
    onItemSwipe: function(b, i, f, h) {
        var g = this,
        d = g.getStore(),
        a = d && d.getAt(f);
        g.fireEvent("itemswipe", g, f, i, a, h)
    },
    onItemSelect: function(a, b) {
        var d = this;
        if (b) {
            d.doItemSelect(d, a)
        } else {
            d.fireAction("select", [d, a], "doItemSelect")
        }
    },
    doItemSelect: function(d, a) {
        if (d.container && !d.isDestroyed) {
            var b = d.getItemAt(d.getStore().indexOf(a));
            if (Ext.isElement(b)) {
                b = Ext.get(b)
            }
            if (b) {
                if (b.isComponent) {
                    b.renderElement.removeCls(d.getPressedCls());
                    b.renderElement.addCls(d.getSelectedCls())
                } else {
                    b.removeCls(d.getPressedCls());
                    b.addCls(d.getSelectedCls())
                }
            }
        }
    },
    onItemDeselect: function(a, b) {
        var d = this;
        if (d.container && !d.isDestroyed) {
            if (b) {
                d.doItemDeselect(d, a)
            } else {
                d.fireAction("deselect", [d, a, b], "doItemDeselect")
            }
        }
    },
    doItemDeselect: function(d, a) {
        var b = d.getItemAt(d.getStore().indexOf(a));
        if (Ext.isElement(b)) {
            b = Ext.get(b)
        }
        if (b) {
            if (b.isComponent) {
                b.renderElement.removeCls([d.getPressedCls(), d.getSelectedCls()])
            } else {
                b.removeCls([d.getPressedCls(), d.getSelectedCls()])
            }
        }
    },
    updateData: function(b) {
        var a = this.getStore();
        if (!a) {
            this.setStore(Ext.create("Ext.data.Store", {
                data: b,
                autoDestroy: true
            }))
        } else {
            a.add(b)
        }
    },
    applyStore: function(b) {
        var e = this,
        f = Ext.apply({},
        e.storeEventHooks, {
            scope: e
        }),
        d,
        a;
        if (b) {
            b = Ext.data.StoreManager.lookup(b);
            if (b && Ext.isObject(b) && b.isStore) {
                b.on(f);
                d = b.getProxy();
                if (d) {
                    a = d.getReader();
                    if (a) {
                        a.on("exception", "handleException", this)
                    }
                }
            }
        }
        return b
    },
    handleException: function() {
        this.setMasked(false)
    },
    updateStore: function(b, f) {
        var e = this,
        g = Ext.apply({},
        e.storeEventHooks, {
            scope: e
        }),
        d,
        a;
        if (f && Ext.isObject(f) && f.isStore) {
            f.un(g);
            if (!e.isDestroyed) {
                e.onStoreClear()
            }
            if (f.getAutoDestroy()) {
                f.destroy()
            } else {
                d = f.getProxy();
                if (d) {
                    a = d.getReader();
                    if (a) {
                        a.un("exception", "handleException", this)
                    }
                }
            }
        }
        if (b) {
            if (b.isLoaded()) {
                this.hasLoadedStore = true
            }
            if (b.isLoading()) {
                e.onBeforeLoad()
            }
            if (e.container) {
                e.refresh()
            }
        }
    },
    onBeforeLoad: function() {
        var a = this.getLoadingText();
        if (a && this.isPainted()) {
            this.setMasked({
                xtype: "loadmask",
                message: a
            })
        }
        this.hideEmptyText()
    },
    updateEmptyText: function(d, e) {
        var b = this,
        a;
        if (e && b.emptyTextCmp) {
            b.remove(b.emptyTextCmp, true);
            delete b.emptyTextCmp
        }
        if (d) {
            b.emptyTextCmp = b.add({
                xtype: "component",
                cls: b.getBaseCls() + "-emptytext",
                html: d,
                hidden: true
            });
            a = b.getStore();
            if (a && b.hasLoadedStore && !a.getCount()) {
                this.showEmptyText()
            }
        }
    },
    onLoad: function(a) {
        this.hasLoadedStore = true;
        this.setMasked(false);
        if (!a.getCount()) {
            this.showEmptyText()
        }
    },
    refresh: function() {
        var b = this,
        a = b.container;
        if (!b.getStore()) {
            if (!b.hasLoadedStore && !b.getDeferEmptyText()) {
                b.showEmptyText()
            }
            return
        }
        if (a) {
            b.fireAction("refresh", [b], "doRefresh")
        }
    },
    applyItemTpl: function(a) {
        return (Ext.isObject(a) && a.isTemplate) ? a: new Ext.XTemplate(a)
    },
    onAfterRender: function() {
        var a = this;
        a.callParent(arguments);
        a.updateStore(a.getStore())
    },
    getItemAt: function(a) {
        return this.getViewItems()[a - this.indexOffset]
    },
    getItemIndex: function(b) {
        var a = this.getViewItems().indexOf(b);
        return (a === -1) ? a: this.indexOffset + a
    },
    getViewItems: function() {
        return this.container.getViewItems()
    },
    doRefresh: function(h) {
        var a = h.container,
        n = h.getStore(),
        b = n.getRange(),
        g = h.getViewItems(),
        k = b.length,
        q = g.length,
        d = k - q,
        j = h.getScrollable(),
        e,
        o;
        if (this.getScrollToTopOnRefresh() && j) {
            j.getScroller().scrollToTop()
        }
        if (k < 1) {
            h.onStoreClear();
            return
        } else {
            h.hideEmptyText()
        }
        if (d < 0) {
            a.moveItemsToCache(q + d, q - 1);
            g = h.getViewItems();
            q = g.length
        } else {
            if (d > 0) {
                a.moveItemsFromCache(n.getRange(q))
            }
        }
        for (e = 0; e < q; e++) {
            o = g[e];
            a.updateListItem(b[e], o)
        }
        if (this.hasSelection()) {
            var m = this.getSelection(),
            p = this.getSelectionCount(),
            f;
            for (e = 0; e < p; e++) {
                f = m[e];
                this.doItemSelect(this, f)
            }
        }
    },
    showEmptyText: function() {
        if (this.getEmptyText() && (this.hasLoadedStore || !this.getDeferEmptyText())) {
            this.emptyTextCmp.show()
        }
    },
    hideEmptyText: function() {
        if (this.getEmptyText()) {
            this.emptyTextCmp.hide()
        }
    },
    destroy: function() {
        var b = this.getStore(),
        d = (b && b.getProxy()),
        a = (d && d.getReader());
        if (a) {
            a.clearListeners()
        }
        this.callParent(arguments);
        this.setStore(null)
    },
    onStoreClear: function() {
        var d = this,
        a = d.container,
        b = d.getViewItems();
        a.moveItemsToCache(0, b.length - 1);
        this.showEmptyText()
    },
    onStoreAdd: function(b, a) {
        if (a) {
            this.hideEmptyText();
            this.container.moveItemsFromCache(a)
        }
    },
    onStoreRemove: function(d, b, g) {
        var a = this.container,
        f = b.length,
        e;
        for (e = 0; e < f; e++) {
            a.moveItemsToCache(g[e], g[e])
        }
    },
    onStoreUpdate: function(d, b, e, h) {
        var g = this,
        a = g.container,
        f;
        h = (typeof h === "undefined") ? e: h;
        if (h !== e) {
            a.updateAtNewIndex(h, e, b);
            if (g.isSelected(b)) {
                g.doItemSelect(g, b)
            }
        } else {
            f = g.getViewItems()[e];
            if (f) {
                a.updateListItem(b, f)
            }
        }
    }
});
Ext.define("Ext.data.SortTypes", {
    singleton: true,
    stripTagsRE: /<\/?[^>]+>/gi,
    none: function(a) {
        return a
    },
    asText: function(a) {
        return String(a).replace(this.stripTagsRE, "")
    },
    asUCText: function(a) {
        return String(a).toUpperCase().replace(this.stripTagsRE, "")
    },
    asUCString: function(a) {
        return String(a).toUpperCase()
    },
    asDate: function(a) {
        if (!a) {
            return 0
        }
        if (Ext.isDate(a)) {
            return a.getTime()
        }
        return Date.parse(String(a))
    },
    asFloat: function(a) {
        a = parseFloat(String(a).replace(/,/g, ""));
        return isNaN(a) ? 0 : a
    },
    asInt: function(a) {
        a = parseInt(String(a).replace(/,/g, ""), 10);
        return isNaN(a) ? 0 : a
    }
});
Ext.define("Ext.data.Types", {
    singleton: true,
    stripRe: /[\$,%]/g,
    dashesRe: /-/g,
    iso8601TestRe: /\d\dT\d\d/,
    iso8601SplitRe: /[- :T\.Z\+]/
},
function() {
    var b = this,
    a = Ext.data.SortTypes;
    Ext.apply(b, {
        AUTO: {
            convert: function(d) {
                return d
            },
            sortType: a.none,
            type: "auto"
        },
        STRING: {
            convert: function(d) {
                return (d === undefined || d === null) ? (this.getAllowNull() ? null: "") : String(d)
            },
            sortType: a.asUCString,
            type: "string"
        },
        INT: {
            convert: function(d) {
                return (d !== undefined && d !== null && d !== "") ? ((typeof d === "number") ? parseInt(d, 10) : parseInt(String(d).replace(b.stripRe, ""), 10)) : (this.getAllowNull() ? null: 0)
            },
            sortType: a.none,
            type: "int"
        },
        FLOAT: {
            convert: function(d) {
                return (d !== undefined && d !== null && d !== "") ? ((typeof d === "number") ? d: parseFloat(String(d).replace(b.stripRe, ""), 10)) : (this.getAllowNull() ? null: 0)
            },
            sortType: a.none,
            type: "float"
        },
        BOOL: {
            convert: function(d) {
                if ((d === undefined || d === null || d === "") && this.getAllowNull()) {
                    return null
                }
                return d !== "false" && d !== "0" && !!d
            },
            sortType: a.none,
            type: "bool"
        },
        DATE: {
            convert: function(f) {
                var d = this.getDateFormat(),
                e;
                if (!f) {
                    return null
                }
                if (Ext.isDate(f)) {
                    return f
                }
                if (d) {
                    if (d == "timestamp") {
                        return new Date(f * 1000)
                    }
                    if (d == "time") {
                        return new Date(parseInt(f, 10))
                    }
                    return Ext.Date.parse(f, d)
                }
                e = new Date(Date.parse(f));
                if (isNaN(e)) {
                    if (b.iso8601TestRe.test(f)) {
                        e = f.split(b.iso8601SplitRe);
                        e = new Date(e[0], e[1] - 1, e[2], e[3], e[4], e[5])
                    }
                    if (isNaN(e)) {
                        e = new Date(Date.parse(f.replace(b.dashesRe, "/")))
                    }
                }
                return isNaN(e) ? null: e
            },
            sortType: a.asDate,
            type: "date"
        }
    });
    Ext.apply(b, {
        BOOLEAN: this.BOOL,
        INTEGER: this.INT,
        NUMBER: this.FLOAT
    })
});
Ext.define("Ext.data.Field", {
    alias: "data.field",
    isField: true,
    config: {
        name: null,
        type: "auto",
        convert: undefined,
        dateFormat: null,
        allowNull: true,
        defaultValue: undefined,
        mapping: null,
        sortType: undefined,
        sortDir: "ASC",
        allowBlank: true,
        persist: true,
        encode: null,
        decode: null,
        bubbleEvents: "action"
    },
    constructor: function(a) {
        if (Ext.isString(a)) {
            a = {
                name: a
            }
        }
        this.initConfig(a)
    },
    applyType: function(d) {
        var b = Ext.data.Types,
        a = b.AUTO;
        if (d) {
            if (Ext.isString(d)) {
                return b[d.toUpperCase()] || a
            } else {
                return d
            }
        }
        return a
    },
    updateType: function(a, b) {
        var d = this.getConvert();
        if (b && d === b.convert) {
            this.setConvert(a.convert)
        }
    },
    applySortType: function(e) {
        var d = Ext.data.SortTypes,
        a = this.getType(),
        b = a.sortType;
        if (e) {
            if (Ext.isString(e)) {
                return d[e] || b
            } else {
                return e
            }
        }
        return b
    },
    applyConvert: function(b) {
        var a = this.getType().convert;
        if (b && b !== a) {
            this._hasCustomConvert = true;
            return b
        } else {
            this._hasCustomConvert = false;
            return a
        }
    },
    hasCustomConvert: function() {
        return this._hasCustomConvert
    }
});
Ext.define("Ext.data.identifier.Simple", {
    alias: "data.identifier.simple",
    statics: {
        AUTO_ID: 1
    },
    config: {
        prefix: "ext-record-"
    },
    constructor: function(a) {
        this.initConfig(a)
    },
    generate: function(a) {
        return this._prefix + this.self.AUTO_ID++
    }
});
Ext.define("Ext.data.ModelManager", {
    extend: Ext.AbstractManager,
    alternateClassName: ["Ext.ModelMgr", "Ext.ModelManager"],
    singleton: true,
    modelNamespace: null,
    registerType: function(d, b) {
        var e = b.prototype,
        a;
        if (e && e.isModel) {
            a = b
        } else {
            b = {
                extend: b.extend || "Ext.data.Model",
                config: b
            };
            a = Ext.define(d, b)
        }
        this.types[d] = a;
        return a
    },
    onModelDefined: Ext.emptyFn,
    getModel: function(b) {
        var a = b;
        if (typeof a == "string") {
            a = this.types[a];
            if (!a && this.modelNamespace) {
                a = this.types[this.modelNamespace + "." + a]
            }
        }
        return a
    },
    create: function(d, b, e) {
        var a = typeof b == "function" ? b: this.types[b || d.name];
        return new a(d, e)
    }
},
function() {
    Ext.regModel = function() {
        return this.ModelManager.registerType.apply(this.ModelManager, arguments)
    }
});
Ext.define("Ext.data.Request", {
    config: {
        action: null,
        params: null,
        method: "GET",
        url: null,
        operation: null,
        proxy: null,
        disableCaching: false,
        headers: {},
        callbackKey: null,
        jsonP: null,
        jsonData: null,
        xmlData: null,
        withCredentials: null,
        username: null,
        password: null,
        callback: null,
        scope: null,
        timeout: 30000,
        records: null,
        directFn: null,
        args: null,
        useDefaultXhrHeader: null
    },
    constructor: function(a) {
        this.initConfig(a)
    }
});
Ext.define("Ext.data.proxy.Server", {
    extend: Ext.data.proxy.Proxy,
    alias: "proxy.server",
    alternateClassName: "Ext.data.ServerProxy",
    config: {
        url: null,
        pageParam: "page",
        startParam: "start",
        limitParam: "limit",
        groupParam: "group",
        sortParam: "sort",
        filterParam: "filter",
        directionParam: "dir",
        enablePagingParams: true,
        simpleSortMode: false,
        noCache: true,
        cacheString: "_dc",
        timeout: 30000,
        api: {
            create: undefined,
            read: undefined,
            update: undefined,
            destroy: undefined
        },
        extraParams: {}
    },
    constructor: function(a) {
        a = a || {};
        if (a.nocache !== undefined) {
            a.noCache = a.nocache
        }
        this.callParent([a])
    },
    create: function() {
        return this.doRequest.apply(this, arguments)
    },
    read: function() {
        return this.doRequest.apply(this, arguments)
    },
    update: function() {
        return this.doRequest.apply(this, arguments)
    },
    destroy: function() {
        return this.doRequest.apply(this, arguments)
    },
    setExtraParam: function(a, b) {
        this.getExtraParams()[a] = b
    },
    buildRequest: function(a) {
        var d = this,
        e = Ext.applyIf(a.getParams() || {},
        d.getExtraParams() || {}),
        b;
        e = Ext.applyIf(e, d.getParams(a));
        b = Ext.create("Ext.data.Request", {
            params: e,
            action: a.getAction(),
            records: a.getRecords(),
            url: a.getUrl(),
            operation: a,
            proxy: d
        });
        b.setUrl(d.buildUrl(b));
        a.setRequest(b);
        return b
    },
    processResponse: function(m, b, f, d, k, n) {
        var i = this,
        a = b.getAction(),
        g,
        j;
        if (m === true) {
            g = i.getReader();
            try {
                j = g.process(i.getResponseResult(d))
            } catch(h) {
                b.setException(h.message);
                i.fireEvent("exception", i, d, b);
                return
            }
            if (!b.getModel()) {
                b.setModel(this.getModel())
            }
            if (b.process(a, j, f, d) === false) {
                i.setException(b, d);
                i.fireEvent("exception", i, d, b)
            }
        } else {
            i.setException(b, d);
            i.fireEvent("exception", this, d, b)
        }
        if (typeof k == "function") {
            k.call(n || i, b)
        }
        i.afterRequest(f, m)
    },
    getResponseResult: function(a) {
        return a
    },
    setException: function(b, a) {
        if (Ext.isObject(a)) {
            b.setException({
                status: a.status,
                statusText: a.statusText
            })
        }
    },
    applyEncoding: function(a) {
        return Ext.encode(a)
    },
    encodeSorters: function(e) {
        var b = [],
        d = e.length,
        a = 0;
        for (; a < d; a++) {
            b[a] = {
                property: e[a].getProperty(),
                direction: e[a].getDirection()
            }
        }
        return this.applyEncoding(b)
    },
    encodeFilters: function(e) {
        var b = [],
        d = e.length,
        a = 0;
        for (; a < d; a++) {
            b[a] = {
                property: e[a].getProperty(),
                value: e[a].getValue()
            }
        }
        return this.applyEncoding(b)
    },
    getParams: function(j) {
        var p = this,
        i = {},
        a = j.getGrouper(),
        o = j.getSorters(),
        g = j.getFilters(),
        n = j.getPage(),
        e = j.getStart(),
        h = j.getLimit(),
        q = p.getSimpleSortMode(),
        s = p.getPageParam(),
        m = p.getStartParam(),
        r = p.getLimitParam(),
        k = p.getGroupParam(),
        f = p.getSortParam(),
        d = p.getFilterParam(),
        b = p.getDirectionParam();
        if (p.getEnablePagingParams()) {
            if (s && n !== null) {
                i[s] = n
            }
            if (m && e !== null) {
                i[m] = e
            }
            if (r && h !== null) {
                i[r] = h
            }
        }
        if (k && a) {
            i[k] = p.encodeSorters([a])
        }
        if (f && o && o.length > 0) {
            if (q) {
                i[f] = o[0].getProperty();
                i[b] = o[0].getDirection()
            } else {
                i[f] = p.encodeSorters(o)
            }
        }
        if (d && g && g.length > 0) {
            i[d] = p.encodeFilters(g)
        }
        return i
    },
    buildUrl: function(d) {
        var b = this,
        a = b.getUrl(d);
        if (b.getNoCache()) {
            a = Ext.urlAppend(a, Ext.String.format("{0}={1}", b.getCacheString(), Ext.Date.now()))
        }
        return a
    },
    getUrl: function(a) {
        return a ? a.getUrl() || this.getApi()[a.getAction()] || this._url: this._url
    },
    doRequest: function() {},
    afterRequest: Ext.emptyFn
});
Ext.define("Ext.data.proxy.Ajax", {
    extend: Ext.data.proxy.Server,
    alias: "proxy.ajax",
    alternateClassName: ["Ext.data.HttpProxy", "Ext.data.AjaxProxy"],
    config: {
        withCredentials: false,
        useDefaultXhrHeader: true,
        username: null,
        password: null,
        actionMethods: {
            create: "POST",
            read: "GET",
            update: "POST",
            destroy: "POST"
        },
        headers: {}
    },
    doRequest: function(a, g, b) {
        var e = this,
        f = e.getWriter(),
        d = e.buildRequest(a);
        d.setConfig({
            headers: e.getHeaders(),
            timeout: e.getTimeout(),
            method: e.getMethod(d),
            callback: e.createRequestCallback(d, a, g, b),
            scope: e,
            proxy: e,
            useDefaultXhrHeader: e.getUseDefaultXhrHeader()
        });
        if (a.getWithCredentials() || e.getWithCredentials()) {
            d.setWithCredentials(true);
            d.setUsername(e.getUsername());
            d.setPassword(e.getPassword())
        }
        d = f.write(d);
        Ext.Ajax.request(d.getCurrentConfig());
        return d
    },
    getMethod: function(a) {
        return this.getActionMethods()[a.getAction()]
    },
    createRequestCallback: function(e, a, f, b) {
        var d = this;
        return function(h, i, g) {
            d.processResponse(i, a, e, g, f, b)
        }
    }
});
Ext.define("Ext.data.association.Association", {
    alternateClassName: "Ext.data.Association",
    config: {
        ownerModel: null,
        ownerName: undefined,
        associatedModel: null,
        associatedName: undefined,
        associationKey: undefined,
        primaryKey: "id",
        reader: null,
        type: null,
        name: undefined
    },
    statics: {
        create: function(a) {
            if (!a.isAssociation) {
                if (Ext.isString(a)) {
                    a = {
                        type: a
                    }
                }
                a.type = a.type.toLowerCase();
                return Ext.factory(a, Ext.data.association.Association, null, "association")
            }
            return a
        }
    },
    constructor: function(a) {
        this.initConfig(a)
    },
    applyName: function(a) {
        if (!a) {
            a = this.getAssociatedName()
        }
        return a
    },
    applyOwnerModel: function(a) {
        var b = Ext.data.ModelManager.getModel(a);
        if (b === undefined) {
            Ext.Logger.error("The configured ownerModel was not valid (you tried " + a + ")")
        }
        return b
    },
    applyOwnerName: function(a) {
        if (!a) {
            a = this.getOwnerModel().modelName
        }
        a = a.slice(a.lastIndexOf(".") + 1);
        return a
    },
    updateOwnerModel: function(a, b) {
        if (b) {
            this.setOwnerName(a.modelName)
        }
    },
    applyAssociatedModel: function(a) {
        var b = Ext.data.ModelManager.types[a];
        if (b === undefined) {
            Ext.Logger.error("The configured associatedModel was not valid (you tried " + a + ")")
        }
        return b
    },
    applyAssociatedName: function(a) {
        if (!a) {
            a = this.getAssociatedModel().modelName
        }
        a = a.slice(a.lastIndexOf(".") + 1);
        return a
    },
    updateAssociatedModel: function(b, a) {
        if (a) {
            this.setAssociatedName(b.modelName)
        }
    },
    applyReader: function(a) {
        if (a) {
            if (Ext.isString(a)) {
                a = {
                    type: a
                }
            }
            if (!a.isReader) {
                Ext.applyIf(a, {
                    type: "json"
                })
            }
        }
        return Ext.factory(a, Ext.data.Reader, this.getReader(), "reader")
    },
    updateReader: function(a) {
        a.setModel(this.getAssociatedModel())
    }
});
Ext.define("Ext.util.Inflector", {
    singleton: true,
    plurals: [[(/(quiz)$/i), "$1zes"], [(/^(ox)$/i), "$1en"], [(/([m|l])ouse$/i), "$1ice"], [(/(matr|vert|ind)ix|ex$/i), "$1ices"], [(/(x|ch|ss|sh)$/i), "$1es"], [(/([^aeiouy]|qu)y$/i), "$1ies"], [(/(hive)$/i), "$1s"], [(/(?:([^f])fe|([lr])f)$/i), "$1$2ves"], [(/sis$/i), "ses"], [(/([ti])um$/i), "$1a"], [(/(buffal|tomat|potat)o$/i), "$1oes"], [(/(bu)s$/i), "$1ses"], [(/(alias|status|sex)$/i), "$1es"], [(/(octop|vir)us$/i), "$1i"], [(/(ax|test)is$/i), "$1es"], [(/^person$/), "people"], [(/^man$/), "men"], [(/^(child)$/), "$1ren"], [(/s$/i), "s"], [(/$/), "s"]],
    singulars: [[(/(quiz)zes$/i), "$1"], [(/(matr)ices$/i), "$1ix"], [(/(vert|ind)ices$/i), "$1ex"], [(/^(ox)en/i), "$1"], [(/(alias|status)es$/i), "$1"], [(/(octop|vir)i$/i), "$1us"], [(/(cris|ax|test)es$/i), "$1is"], [(/(shoe)s$/i), "$1"], [(/(o)es$/i), "$1"], [(/(bus)es$/i), "$1"], [(/([m|l])ice$/i), "$1ouse"], [(/(x|ch|ss|sh)es$/i), "$1"], [(/(m)ovies$/i), "$1ovie"], [(/(s)eries$/i), "$1eries"], [(/([^aeiouy]|qu)ies$/i), "$1y"], [(/([lr])ves$/i), "$1f"], [(/(tive)s$/i), "$1"], [(/(hive)s$/i), "$1"], [(/([^f])ves$/i), "$1fe"], [(/(^analy)ses$/i), "$1sis"], [(/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i), "$1$2sis"], [(/([ti])a$/i), "$1um"], [(/(n)ews$/i), "$1ews"], [(/people$/i), "person"], [(/s$/i), ""]],
    uncountable: ["sheep", "fish", "series", "species", "money", "rice", "information", "equipment", "grass", "mud", "offspring", "deer", "means"],
    singular: function(b, a) {
        this.singulars.unshift([b, a])
    },
    plural: function(b, a) {
        this.plurals.unshift([b, a])
    },
    clearSingulars: function() {
        this.singulars = []
    },
    clearPlurals: function() {
        this.plurals = []
    },
    isTransnumeral: function(a) {
        return Ext.Array.indexOf(this.uncountable, a) != -1
    },
    pluralize: function(g) {
        if (this.isTransnumeral(g)) {
            return g
        }
        var f = this.plurals,
        e = f.length,
        a, d, b;
        for (b = 0; b < e; b++) {
            a = f[b];
            d = a[0];
            if (d == g || (d.test && d.test(g))) {
                return g.replace(d, a[1])
            }
        }
        return g
    },
    singularize: function(g) {
        if (this.isTransnumeral(g)) {
            return g
        }
        var f = this.singulars,
        e = f.length,
        a, d, b;
        for (b = 0; b < e; b++) {
            a = f[b];
            d = a[0];
            if (d == g || (d.test && d.test(g))) {
                return g.replace(d, a[1])
            }
        }
        return g
    },
    classify: function(a) {
        return Ext.String.capitalize(this.singularize(a))
    },
    ordinalize: function(e) {
        var b = parseInt(e, 10),
        d = b % 10,
        a = b % 100;
        if (11 <= a && a <= 13) {
            return e + "th"
        } else {
            switch (d) {
            case 1:
                return e + "st";
            case 2:
                return e + "nd";
            case 3:
                return e + "rd";
            default:
                return e + "th"
            }
        }
    }
},
function() {
    var b = {
        alumnus: "alumni",
        cactus: "cacti",
        focus: "foci",
        nucleus: "nuclei",
        radius: "radii",
        stimulus: "stimuli",
        ellipsis: "ellipses",
        paralysis: "paralyses",
        oasis: "oases",
        appendix: "appendices",
        index: "indexes",
        beau: "beaux",
        bureau: "bureaux",
        tableau: "tableaux",
        woman: "women",
        child: "children",
        man: "men",
        corpus: "corpora",
        criterion: "criteria",
        curriculum: "curricula",
        genus: "genera",
        memorandum: "memoranda",
        phenomenon: "phenomena",
        foot: "feet",
        goose: "geese",
        tooth: "teeth",
        antenna: "antennae",
        formula: "formulae",
        nebula: "nebulae",
        vertebra: "vertebrae",
        vita: "vitae"
    },
    a;
    for (a in b) {
        this.plural(a, b[a]);
        this.singular(b[a], a)
    }
});
Ext.define("Ext.data.association.HasMany", {
    extend: Ext.data.association.Association,
    alternateClassName: "Ext.data.HasManyAssociation",
    alias: "association.hasmany",
    config: {
        foreignKey: undefined,
        store: undefined,
        storeName: undefined,
        filterProperty: null,
        autoLoad: false,
        autoSync: false
    },
    constructor: function(a) {
        a = a || {};
        if (a.storeConfig) {
            a.store = a.storeConfig;
            delete a.storeConfig
        }
        this.callParent([a])
    },
    applyName: function(a) {
        if (!a) {
            a = Ext.util.Inflector.pluralize(this.getAssociatedName().toLowerCase())
        }
        return a
    },
    applyStoreName: function(a) {
        if (!a) {
            a = this.getName() + "Store"
        }
        return a
    },
    applyForeignKey: function(b) {
        if (!b) {
            var a = this.getInverseAssociation();
            if (a) {
                b = a.getForeignKey()
            } else {
                b = this.getOwnerName().toLowerCase() + "_id"
            }
        }
        return b
    },
    applyAssociationKey: function(a) {
        if (!a) {
            var b = this.getAssociatedName();
            a = Ext.util.Inflector.pluralize(b[0].toLowerCase() + b.slice(1))
        }
        return a
    },
    updateForeignKey: function(b, e) {
        var a = this.getAssociatedModel().getFields(),
        d = a.get(b);
        if (!d) {
            d = new Ext.data.Field({
                name: b
            });
            a.add(d);
            a.isDirty = true
        }
        if (e) {
            d = a.get(e);
            if (d) {
                a.remove(d);
                a.isDirty = true
            }
        }
    },
    applyStore: function(b) {
        var f = this,
        j = f.getAssociatedModel(),
        g = f.getStoreName(),
        e = f.getForeignKey(),
        i = f.getPrimaryKey(),
        h = f.getFilterProperty(),
        d = f.getAutoLoad(),
        a = f.getAutoSync();
        return function() {
            var m = this,
            o, q, n, k = {},
            p = {
                addrecords: f.onAddRecords,
                removerecords: f.onRemoveRecords,
                scope: f
            };
            if (m[g] === undefined) {
                if (h) {
                    q = {
                        property: h,
                        value: m.get(h),
                        exactMatch: true
                    }
                } else {
                    q = {
                        property: e,
                        value: m.get(i),
                        exactMatch: true
                    }
                }
                k[e] = m.get(i);
                o = Ext.apply({},
                b, {
                    model: j,
                    filters: [q],
                    remoteFilter: true,
                    autoSync: a,
                    modelDefaults: k
                });
                n = m[g] = Ext.create("Ext.data.Store", o);
                n.boundTo = m;
                n.onAfter(p);
                if (d) {
                    m[g].load()
                }
            }
            return m[g]
        }
    },
    onAddRecords: function(d, b) {
        var f = b.length,
        g = d.boundTo.getId(),
        e,
        a;
        for (e = 0; e < f; e++) {
            a = b[e];
            a.set(this.getForeignKey(), g)
        }
        this.updateInverseInstances(d.boundTo)
    },
    onRemoveRecords: function(d, b) {
        var f = b.length,
        e, a;
        for (e = 0; e < f; e++) {
            a = b[e];
            a.set(this.getForeignKey(), null)
        }
    },
    updateStore: function(a) {
        this.getOwnerModel().prototype[this.getName()] = a
    },
    read: function(b, a, f) {
        var e = b[this.getName()](),
        d = a.read(f).getRecords();
        e.add(d)
    },
    updateInverseInstances: function(b) {
        var d = b[this.getName()](),
        a = this.getInverseAssociation();
        if (a) {
            d.each(function(e) {
                e[a.getInstanceName()] = b
            })
        }
    },
    getInverseAssociation: function() {
        var a = this.getOwnerModel().modelName;
        return this.getAssociatedModel().associations.findBy(function(b) {
            return b.getType().toLowerCase() === "belongsto" && b.getAssociatedModel().modelName === a
        })
    }
});
Ext.define("Ext.data.association.BelongsTo", {
    extend: Ext.data.association.Association,
    alternateClassName: "Ext.data.BelongsToAssociation",
    alias: "association.belongsto",
    config: {
        foreignKey: undefined,
        getterName: undefined,
        setterName: undefined,
        instanceName: undefined
    },
    applyForeignKey: function(a) {
        if (!a) {
            a = this.getAssociatedName().toLowerCase() + "_id"
        }
        return a
    },
    updateForeignKey: function(b, e) {
        var a = this.getOwnerModel().getFields(),
        d = a.get(b);
        if (!d) {
            d = new Ext.data.Field({
                name: b
            });
            a.add(d);
            a.isDirty = true
        }
        if (e) {
            d = a.get(e);
            if (d) {
                a.isDirty = true;
                a.remove(d)
            }
        }
    },
    applyInstanceName: function(a) {
        if (!a) {
            a = this.getAssociatedName() + "BelongsToInstance"
        }
        return a
    },
    applyAssociationKey: function(a) {
        if (!a) {
            var b = this.getAssociatedName();
            a = b[0].toLowerCase() + b.slice(1)
        }
        return a
    },
    applyGetterName: function(a) {
        if (!a) {
            var b = this.getAssociatedName();
            a = "get" + b[0].toUpperCase() + b.slice(1)
        }
        return a
    },
    applySetterName: function(a) {
        if (!a) {
            var b = this.getAssociatedName();
            a = "set" + b[0].toUpperCase() + b.slice(1)
        }
        return a
    },
    updateGetterName: function(b, d) {
        var a = this.getOwnerModel().prototype;
        if (d) {
            delete a[d]
        }
        if (b) {
            a[b] = this.createGetter()
        }
    },
    updateSetterName: function(b, d) {
        var a = this.getOwnerModel().prototype;
        if (d) {
            delete a[d]
        }
        if (b) {
            a[b] = this.createSetter()
        }
    },
    createSetter: function() {
        var e = this,
        d = e.getForeignKey(),
        g = e.getAssociatedModel(),
        f,
        a,
        b;
        return function(m, j, k) {
            var i = e.getInverseAssociation(),
            h = this;
            if (m && m.isModel) {
                m = m.getId()
            }
            if (Ext.isFunction(j)) {
                j = {
                    callback: j,
                    scope: k || h
                }
            }
            delete h[e.getInstanceName()];
            f = Ext.data.Model.cache[Ext.data.Model.generateCacheId(g.modelName, this.get(d))];
            a = Ext.data.Model.cache[Ext.data.Model.generateCacheId(g.modelName, m)];
            h.set(d, m);
            if (i) {
                if (a) {
                    if (i.getType().toLowerCase() === "hasmany") {
                        b = a[i.getName()]();
                        b.add(h)
                    } else {
                        a[i.getInstanceName()] = h
                    }
                }
                if (f) {
                    if (i.getType().toLowerCase() === "hasmany") {
                        b = f[i.getName()]();
                        b.remove(h)
                    } else {
                        delete m[i.getInstanceName()]
                    }
                }
            }
            if (a) {
                h[e.getInstanceName()] = a
            }
            if (Ext.isObject(j)) {
                return h.save(j)
            }
            return h
        }
    },
    createGetter: function() {
        var d = this,
        e = d.getAssociatedModel(),
        b = d.getForeignKey(),
        a = d.getInstanceName();
        return function(i, j) {
            i = i || {};
            var h = this,
            k = h.get(b),
            m,
            f,
            g;
            f = h[a];
            if (!f) {
                f = Ext.data.Model.cache[Ext.data.Model.generateCacheId(e.modelName, k)];
                if (f) {
                    h[a] = f
                }
            }
            if (i.reload === true || f === undefined) {
                if (typeof i == "function") {
                    i = {
                        callback: i,
                        scope: j || h
                    }
                }
                m = i.success;
                i.success = function(n) {
                    h[a] = n;
                    if (m) {
                        m.apply(this, arguments)
                    }
                };
                e.load(k, i)
            } else {
                g = [f];
                j = j || h;
                Ext.callback(i, j, g);
                Ext.callback(i.success, j, g);
                Ext.callback(i.failure, j, g);
                Ext.callback(i.callback, j, g);
                return f
            }
        }
    },
    read: function(b, a, d) {
        b[this.getInstanceName()] = a.read([d]).getRecords()[0]
    },
    getInverseAssociation: function() {
        var b = this.getOwnerModel().modelName,
        a = this.getForeignKey();
        return this.getAssociatedModel().associations.findBy(function(e) {
            var d = e.getType().toLowerCase();
            return (d === "hasmany" || d === "hasone") && e.getAssociatedModel().modelName === b && e.getForeignKey() === a
        })
    }
});
Ext.define("Ext.data.association.HasOne", {
    extend: Ext.data.association.Association,
    alternateClassName: "Ext.data.HasOneAssociation",
    alias: "association.hasone",
    config: {
        foreignKey: undefined,
        getterName: undefined,
        setterName: undefined,
        instanceName: undefined
    },
    applyForeignKey: function(b) {
        if (!b) {
            var a = this.getInverseAssociation();
            if (a) {
                b = a.getForeignKey()
            } else {
                b = this.getAssociatedName().toLowerCase() + "_id"
            }
        }
        return b
    },
    updateForeignKey: function(b, e) {
        var a = this.getOwnerModel().getFields(),
        d = a.get(b);
        if (!d) {
            d = new Ext.data.Field({
                name: b
            });
            a.add(d);
            a.isDirty = true
        }
        if (e) {
            d = a.get(e);
            if (d) {
                a.remove(d);
                a.isDirty = true
            }
        }
    },
    applyInstanceName: function(a) {
        if (!a) {
            a = this.getAssociatedName() + "HasOneInstance"
        }
        return a
    },
    applyAssociationKey: function(a) {
        if (!a) {
            var b = this.getAssociatedName();
            a = b[0].toLowerCase() + b.slice(1)
        }
        return a
    },
    applyGetterName: function(a) {
        if (!a) {
            var b = this.getAssociatedName();
            a = "get" + b[0].toUpperCase() + b.slice(1)
        }
        return a
    },
    applySetterName: function(a) {
        if (!a) {
            var b = this.getAssociatedName();
            a = "set" + b[0].toUpperCase() + b.slice(1)
        }
        return a
    },
    updateGetterName: function(b, d) {
        var a = this.getOwnerModel().prototype;
        if (d) {
            delete a[d]
        }
        if (b) {
            a[b] = this.createGetter()
        }
    },
    updateSetterName: function(b, d) {
        var a = this.getOwnerModel().prototype;
        if (d) {
            delete a[d]
        }
        if (b) {
            a[b] = this.createSetter()
        }
    },
    createSetter: function() {
        var d = this,
        b = d.getForeignKey(),
        a = d.getInstanceName(),
        e = d.getAssociatedModel();
        return function(i, g, h) {
            var j = Ext.data.Model,
            f;
            if (i && i.isModel) {
                i = i.getId()
            }
            this.set(b, i);
            if (i || i === 0) {
                f = j.cache[j.generateCacheId(e.modelName, i)];
                if (f) {
                    this[a] = f
                }
            } else {
                delete this[a]
            }
            if (Ext.isFunction(g)) {
                g = {
                    callback: g,
                    scope: h || this
                }
            }
            if (Ext.isObject(g)) {
                return this.save(g)
            }
            return this
        }
    },
    createGetter: function() {
        var d = this,
        e = d.getAssociatedModel(),
        b = d.getForeignKey(),
        a = d.getInstanceName();
        return function(i, j) {
            i = i || {};
            var h = this,
            k = h.get(b),
            m,
            f,
            g;
            if (i.reload === true || h[a] === undefined) {
                if (typeof i == "function") {
                    i = {
                        callback: i,
                        scope: j || h
                    }
                }
                m = i.success;
                i.success = function(n) {
                    h[a] = n;
                    if (m) {
                        m.apply(this, arguments)
                    }
                };
                e.load(k, i)
            } else {
                f = h[a];
                g = [f];
                j = j || h;
                Ext.callback(i, j, g);
                Ext.callback(i.success, j, g);
                Ext.callback(i.failure, j, g);
                Ext.callback(i.callback, j, g);
                return f
            }
        }
    },
    read: function(d, a, f) {
        var b = this.getInverseAssociation(),
        e = a.read([f]).getRecords()[0];
        d[this.getSetterName()].call(d, e);
        if (b) {
            e[b.getInstanceName()] = d
        }
    },
    getInverseAssociation: function() {
        var a = this.getOwnerModel().modelName;
        return this.getAssociatedModel().associations.findBy(function(b) {
            return b.getType().toLowerCase() === "belongsto" && b.getAssociatedModel().modelName === a
        })
    }
});
Ext.define("Ext.data.Error", {
    config: {
        field: null,
        message: ""
    },
    constructor: function(a) {
        this.initConfig(a)
    }
});
Ext.define("Ext.data.Errors", {
    extend: Ext.util.Collection,
    isValid: function() {
        return this.length === 0
    },
    getByField: function(e) {
        var d = [],
        a,
        b;
        for (b = 0; b < this.length; b++) {
            a = this.items[b];
            if (a.getField() == e) {
                d.push(a)
            }
        }
        return d
    },
    add: function() {
        var a = arguments.length == 1 ? arguments[0] : arguments[1];
        if (! (a instanceof Ext.data.Error)) {
            a = Ext.create("Ext.data.Error", {
                field: a.field || a.name,
                message: a.error || a.message
            })
        }
        return this.callParent([a])
    }
});
Ext.define("Ext.data.Validations", {
    alternateClassName: "Ext.data.validations",
    singleton: true,
    config: {
        presenceMessage: "must be present",
        lengthMessage: "is the wrong length",
        formatMessage: "is the wrong format",
        inclusionMessage: "is not included in the list of acceptable values",
        exclusionMessage: "is not an acceptable value",
        emailMessage: "is not a valid email address"
    },
    constructor: function(a) {
        this.initConfig(a)
    },
    getMessage: function(a) {
        var b = this["get" + a[0].toUpperCase() + a.slice(1) + "Message"];
        if (b) {
            return b.call(this)
        }
        return ""
    },
    emailRe: /^\s*[\w\-\+_]+(\.[\w\-\+_]+)*\@[\w\-\+_]+\.[\w\-\+_]+(\.[\w\-\+_]+)*\s*$/,
    presence: function(a, b) {
        if (arguments.length === 1) {
            b = a
        }
        return !! b || b === 0
    },
    length: function(b, f) {
        if (f === undefined || f === null) {
            return false
        }
        var e = f.length,
        d = b.min,
        a = b.max;
        if ((d && e < d) || (a && e > a)) {
            return false
        } else {
            return true
        }
    },
    email: function(b, a) {
        return Ext.data.validations.emailRe.test(a)
    },
    format: function(a, b) {
        if (b === undefined || b === null) {
            b = ""
        }
        return !! (a.matcher && a.matcher.test(b))
    },
    inclusion: function(a, b) {
        return a.list && Ext.Array.indexOf(a.list, b) != -1
    },
    exclusion: function(a, b) {
        return a.list && Ext.Array.indexOf(a.list, b) == -1
    }
});
Ext.define("Ext.data.Model", {
    alternateClassName: "Ext.data.Record",
    mixins: {
        observable: Ext.mixin.Observable
    },
    isModel: true,
    config: {
        idProperty: "id",
        data: null,
        fields: undefined,
        validations: null,
        associations: null,
        hasMany: null,
        hasOne: null,
        belongsTo: null,
        proxy: null,
        identifier: {
            type: "simple"
        },
        clientIdProperty: "clientId",
        isErased: false,
        useCache: true
    },
    staticConfigs: ["idProperty", "fields", "validations", "associations", "hasMany", "hasOne", "belongsTo", "clientIdProperty", "identifier", "useCache", "proxy"],
    statics: {
        EDIT: "edit",
        REJECT: "reject",
        COMMIT: "commit",
        cache: {},
        generateProxyMethod: function(a) {
            return function() {
                var b = this.prototype;
                return b[a].apply(b, arguments)
            }
        },
        generateCacheId: function(b, d) {
            var a;
            if (b && b.isModel) {
                a = b.modelName;
                if (d === undefined) {
                    d = b.getId()
                }
            } else {
                a = b
            }
            return a.replace(/\./g, "-").toLowerCase() + "-" + d
        }
    },
    inheritableStatics: {
        load: function(a, b, i) {
            var g = this.getProxy(),
            j = this.getIdProperty(),
            f = null,
            e = {},
            h,
            d;
            i = i || (b && b.scope) || this;
            if (Ext.isFunction(b)) {
                b = {
                    callback: b,
                    scope: i
                }
            }
            e[j] = a;
            b = Ext.apply({},
            b);
            b = Ext.applyIf(b, {
                action: "read",
                params: e,
                model: this
            });
            d = Ext.create("Ext.data.Operation", b);
            if (!g) {
                Ext.Logger.error("You are trying to load a model that doesn't have a Proxy specified")
            }
            h = function(k) {
                if (k.wasSuccessful()) {
                    f = k.getRecords()[0] || null;
                    Ext.callback(b.success, i, [f, k])
                } else {
                    Ext.callback(b.failure, i, [f, k])
                }
                Ext.callback(b.callback, i, [f, k])
            };
            g.read(d, h, this)
        }
    },
    editing: false,
    dirty: false,
    phantom: false,
    constructor: function(g, i, d, h) {
        var f = this,
        e = null,
        a = f.getUseCache(),
        b = f.getIdProperty();
        g = g || h || {};
        if (i || i === 0) {
            g[b] = f.internalId = i
        }
        i = g[b];
        if (a && (i || i === 0)) {
            e = Ext.data.Model.cache[Ext.data.Model.generateCacheId(this, i)];
            if (e) {
                e.raw = d || e.raw;
                return e.mergeData(h || g || {})
            }
        }
        f.modified = {};
        f.raw = d || g || {};
        f.stores = [];
        if (h) {
            f.setConvertedData(g)
        } else {
            f.setData(g)
        }
        f.id = f.getIdentifier().generate(f);
        i = f.data[b];
        if (!i && i !== 0) {
            f.data[b] = f.internalId = f.id;
            f.phantom = true;
            if (this.associations.length) {
                this.handleInlineAssociationData(g)
            }
        } else {
            this.internalId = i
        }
        if (a) {
            Ext.data.Model.cache[Ext.data.Model.generateCacheId(f)] = f
        }
        if (this.init && typeof this.init == "function") {
            this.init()
        }
    },
    mergeData: function(a) {
        var h = this,
        f = h.getFields().items,
        g = f.length,
        m = h.modified,
        d = h.data,
        e,
        j,
        n,
        k,
        b;
        for (e = 0; e < g; e++) {
            j = f[e];
            n = j._name;
            k = a[n];
            if (k !== undefined && !m.hasOwnProperty(n)) {
                if (j._convert) {
                    k = j._convert(k, h)
                }
                d[n] = k
            } else {
                if (Ext.isFunction(j._convert)) {
                    k = j._convert(k, h);
                    d[n] = k
                }
            }
        }
        if (h.associations.length) {
            h.handleInlineAssociationData(a)
        }
        return this
    },
    setData: function(a) {
        var m = this,
        h = m.fields.items,
        j = h.length,
        g = Ext.isArray(a),
        e = m._data = m.data = {},
        f,
        n,
        b,
        o,
        k,
        d;
        if (!a) {
            return m
        }
        for (f = 0; f < j; f++) {
            n = h[f];
            b = n._name;
            k = n._convert;
            if (g) {
                o = a[f]
            } else {
                o = a[b];
                if (typeof o == "undefined") {
                    o = n._defaultValue
                }
            }
            if (k) {
                o = n._convert(o, m)
            }
            e[b] = o
        }
        d = m.getId();
        if (m.associations.length && (d || d === 0)) {
            m.handleInlineAssociationData(a)
        }
        return m
    },
    handleInlineAssociationData: function(f) {
        var e = this.associations.items,
        j = e.length,
        g, d, b, h, k, a;
        f = Ext.apply({},
        f, this.raw);
        for (g = 0; g < j; g++) {
            d = e[g];
            a = d.getAssociationKey();
            b = f[a];
            if (b) {
                h = d.getReader();
                if (!h) {
                    k = d.getAssociatedModel().getProxy();
                    if (k) {
                        h = k.getReader()
                    } else {
                        h = new Ext.data.JsonReader({
                            model: d.getAssociatedModel()
                        })
                    }
                }
                d.read(this, h, b)
            }
        }
    },
    setId: function(b) {
        var a = this.getId();
        this.set(this.getIdProperty(), b);
        this.internalId = b;
        if (this.getUseCache()) {
            delete Ext.data.Model.cache[Ext.data.Model.generateCacheId(this, a)];
            Ext.data.Model.cache[Ext.data.Model.generateCacheId(this)] = this
        }
    },
    getId: function() {
        return this.get(this.getIdProperty())
    },
    setConvertedData: function(a) {
        this._data = this.data = a;
        return this
    },
    get: function(a) {
        return this.data[a]
    },
    set: function(q, m) {
        var j = this,
        b = j.fields.map,
        p = j.modified,
        a = !j.editing,
        f = 0,
        d = [],
        k,
        o,
        e,
        n,
        g,
        h;
        if (arguments.length == 1) {
            for (o in q) {
                if (q.hasOwnProperty(o)) {
                    k = b[o];
                    if (k && k.hasCustomConvert()) {
                        d.push(o);
                        continue
                    }
                    if (!f && a) {
                        j.beginEdit()
                    }++f;
                    j.set(o, q[o])
                }
            }
            g = d.length;
            if (g) {
                if (!f && a) {
                    j.beginEdit()
                }
                f += g;
                for (e = 0; e < g; e++) {
                    k = d[e];
                    j.set(k, q[k])
                }
            }
            if (a && f) {
                j.endEdit(false, d)
            }
        } else {
            if (p) {
                k = b[q];
                h = k && k.getConvert();
                if (h) {
                    m = h.call(k, m, j)
                }
                n = j.data[q];
                j.data[q] = m;
                if (k && !j.isEqual(n, m)) {
                    if (p.hasOwnProperty(q)) {
                        if (j.isEqual(p[q], m)) {
                            delete p[q];
                            j.dirty = false;
                            for (o in p) {
                                if (p.hasOwnProperty(o)) {
                                    j.dirty = true;
                                    break
                                }
                            }
                        }
                    } else {
                        j.dirty = true;
                        p[q] = n
                    }
                }
                if (a) {
                    j.afterEdit([q], p)
                }
            }
        }
    },
    isEqual: function(e, d) {
        if (Ext.isDate(e) && Ext.isDate(d)) {
            return e.getTime() === d.getTime()
        }
        return e === d
    },
    beginEdit: function() {
        var a = this;
        if (!a.editing) {
            a.editing = true;
            a.dirtySave = a.dirty;
            a.dataSave = Ext.apply({},
            a.data);
            a.modifiedSave = Ext.apply({},
            a.modified)
        }
    },
    cancelEdit: function() {
        var a = this;
        if (a.editing) {
            a.editing = false;
            a.modified = a.modifiedSave;
            a.data = a.dataSave;
            a.dirty = a.dirtySave;
            delete a.modifiedSave;
            delete a.dataSave;
            delete a.dirtySave
        }
    },
    endEdit: function(a, d) {
        var b = this;
        if (b.editing) {
            b.editing = false;
            if (a !== true && (b.changedWhileEditing())) {
                b.afterEdit(d || Ext.Object.getKeys(this.modified), this.modified)
            }
            delete b.modifiedSave;
            delete b.dataSave;
            delete b.dirtySave
        }
    },
    changedWhileEditing: function() {
        var d = this,
        b = d.dataSave,
        e = d.data,
        a;
        for (a in e) {
            if (e.hasOwnProperty(a)) {
                if (!d.isEqual(e[a], b[a])) {
                    return true
                }
            }
        }
        return false
    },
    getChanges: function() {
        var a = this.modified,
        b = {},
        d;
        for (d in a) {
            if (a.hasOwnProperty(d)) {
                b[d] = this.get(d)
            }
        }
        return b
    },
    isModified: function(a) {
        return this.modified.hasOwnProperty(a)
    },
    save: function(b, e) {
        var f = this,
        g = f.phantom ? "create": "update",
        d = f.getProxy(),
        a,
        h;
        if (!d) {
            Ext.Logger.error("You are trying to save a model instance that doesn't have a Proxy specified")
        }
        b = b || {};
        e = e || f;
        if (Ext.isFunction(b)) {
            b = {
                callback: b,
                scope: e
            }
        }
        Ext.applyIf(b, {
            records: [f],
            action: g,
            model: f.self
        });
        a = Ext.create("Ext.data.Operation", b);
        h = function(i) {
            if (i.wasSuccessful()) {
                Ext.callback(b.success, e, [f, i])
            } else {
                Ext.callback(b.failure, e, [f, i])
            }
            Ext.callback(b.callback, e, [f, i])
        };
        d[g](a, h, f);
        return f
    },
    erase: function(b, e) {
        var f = this,
        d = this.getProxy(),
        a,
        g;
        if (!d) {
            Ext.Logger.error("You are trying to erase a model instance that doesn't have a Proxy specified")
        }
        b = b || {};
        e = e || f;
        if (Ext.isFunction(b)) {
            b = {
                callback: b,
                scope: e
            }
        }
        Ext.applyIf(b, {
            records: [f],
            action: "destroy",
            model: this.self
        });
        a = Ext.create("Ext.data.Operation", b);
        g = function(h) {
            if (h.wasSuccessful()) {
                Ext.callback(b.success, e, [f, h])
            } else {
                Ext.callback(b.failure, e, [f, h])
            }
            Ext.callback(b.callback, e, [f, h])
        };
        d.destroy(a, g, f);
        return f
    },
    reject: function(a) {
        var d = this,
        b = d.modified,
        e;
        for (e in b) {
            if (b.hasOwnProperty(e)) {
                if (typeof b[e] != "function") {
                    d.data[e] = b[e]
                }
            }
        }
        d.dirty = false;
        d.editing = false;
        d.modified = {};
        if (a !== true) {
            d.afterReject()
        }
    },
    commit: function(a) {
        var d = this,
        b = this.modified;
        d.phantom = d.dirty = d.editing = false;
        d.modified = {};
        if (a !== true) {
            d.afterCommit(b)
        }
    },
    afterEdit: function(b, a) {
        this.notifyStores("afterEdit", b, a)
    },
    afterReject: function() {
        this.notifyStores("afterReject")
    },
    afterCommit: function(a) {
        this.notifyStores("afterCommit", Ext.Object.getKeys(a || {}), a)
    },
    notifyStores: function(f) {
        var d = Ext.Array.clone(arguments),
        a = this.stores;
        if (Ext.isArray(a)) {
            var g = a.length,
            e, b;
            d[0] = this;
            for (e = 0; e < g; ++e) {
                b = a[e];
                if (b !== undefined && typeof b[f] == "function") {
                    b[f].apply(b, d)
                }
            }
        }
    },
    copy: function(d) {
        var e = this,
        b = e.getIdProperty(),
        a = Ext.apply({},
        e.raw),
        f = Ext.apply({},
        e.data);
        delete a[b];
        delete f[b];
        return new e.self(null, d, a, f)
    },
    getData: function(a) {
        var b = this.data;
        if (a === true) {
            Ext.apply(b, this.getAssociatedData())
        }
        return b
    },
    getAssociatedData: function() {
        return this.prepareAssociatedData(this, [], null)
    },
    prepareAssociatedData: function(e, o, d) {
        var t = e.associations.items,
        h = t.length,
        u = {},
        q = [],
        p,
        y,
        b,
        a,
        m,
        f,
        n,
        s,
        r,
        g,
        v,
        k;
        for (s = 0; s < h; s++) {
            f = t[s];
            y = f.getName();
            g = f.getType();
            v = true;
            if (d) {
                v = g == d
            }
            if (v && g.toLowerCase() == "hasmany") {
                p = e[f.getStoreName()];
                u[y] = [];
                if (p && p.getCount() > 0) {
                    b = p.data.items;
                    m = b.length;
                    q.length = 0;
                    for (r = 0; r < m; r++) {
                        a = b[r];
                        n = a.id;
                        if (Ext.Array.indexOf(o, n) == -1) {
                            o.push(n);
                            u[y][r] = a.getData();
                            q.push({
                                associationName: y,
                                j: r,
                                associatedRecord: a,
                                ids: o,
                                associationType: d
                            })
                        }
                    }
                    while (q.length > 0) {
                        k = q.shift();
                        Ext.apply(u[k.associationName][k.j], this.prepareAssociatedData(k.associatedRecord, k.ids, k.associationType))
                    }
                }
            } else {
                if (v && (g.toLowerCase() == "belongsto" || g.toLowerCase() == "hasone")) {
                    a = e[f.getInstanceName()];
                    if (a !== undefined) {
                        n = a.id;
                        if (Ext.Array.indexOf(o, n) === -1) {
                            o.push(n);
                            u[y] = a.getData();
                            Ext.apply(u[y], this.prepareAssociatedData(a, o, d))
                        }
                    }
                }
            }
        }
        return u
    },
    join: function(a) {
        Ext.Array.include(this.stores, a)
    },
    unjoin: function(a) {
        Ext.Array.remove(this.stores, a)
    },
    setDirty: function() {
        var b = this,
        a;
        b.dirty = true;
        b.fields.each(function(d) {
            if (d.getPersist()) {
                a = d.getName();
                b.modified[a] = b.get(a)
            }
        })
    },
    validate: function() {
        var k = Ext.create("Ext.data.Errors"),
        d = this.getValidations().items,
        f = Ext.data.Validations,
        b,
        e,
        j,
        a,
        h,
        g;
        if (d) {
            b = d.length;
            for (g = 0; g < b; g++) {
                e = d[g];
                j = e.field || e.name;
                h = e.type;
                a = f[h](e, this.get(j));
                if (!a) {
                    k.add(Ext.create("Ext.data.Error", {
                        field: j,
                        message: e.message || f.getMessage(h)
                    }))
                }
            }
        }
        return k
    },
    isValid: function() {
        return this.validate().isValid()
    },
    toUrl: function() {
        var b = this.$className.split("."),
        a = b[b.length - 1].toLowerCase();
        return a + "/" + this.getId()
    },
    destroy: function() {
        var a = this;
        a.notifyStores("afterErase", a);
        if (a.getUseCache()) {
            delete Ext.data.Model.cache[Ext.data.Model.generateCacheId(a)]
        }
        a.raw = a.stores = a.modified = null;
        a.callParent(arguments)
    },
    applyProxy: function(b, a) {
        return Ext.factory(b, Ext.data.Proxy, a, "proxy")
    },
    updateProxy: function(a) {
        if (a) {
            a.setModel(this.self)
        }
    },
    applyAssociations: function(a) {
        if (a) {
            this.addAssociations(a, "hasMany")
        }
    },
    applyBelongsTo: function(a) {
        if (a) {
            this.addAssociations(a, "belongsTo")
        }
    },
    applyHasMany: function(a) {
        if (a) {
            this.addAssociations(a, "hasMany")
        }
    },
    applyHasOne: function(a) {
        if (a) {
            this.addAssociations(a, "hasOne")
        }
    },
    addAssociations: function(f, j) {
        var g, e, b, d = this.self.modelName,
        h = this.self.associations,
        a;
        f = Ext.Array.from(f);
        for (e = 0, g = f.length; e < g; e++) {
            b = f[e];
            if (!Ext.isObject(b)) {
                b = {
                    model: b
                }
            }
            Ext.applyIf(b, {
                type: j,
                ownerModel: d,
                associatedModel: b.model
            });
            delete b.model;
            a = Ext.Function.bind(function(i) {
                h.add(Ext.data.association.Association.create(this))
            },
            b);
            Ext.ClassManager.onCreated(a, this, (typeof b.associatedModel === "string") ? b.associatedModel: Ext.getClassName(b.associatedModel))
        }
    },
    applyValidations: function(a) {
        if (a) {
            if (!Ext.isArray(a)) {
                a = [a]
            }
            this.addValidations(a)
        }
    },
    addValidations: function(a) {
        this.self.validations.addAll(a)
    },
    applyFields: function(a) {
        var b = this.superclass.fields;
        if (b) {
            a = b.items.concat(a || [])
        }
        return a || []
    },
    updateFields: function(d) {
        var e = d.length,
        f = this,
        j = f.self.prototype,
        k = this.getIdProperty(),
        a,
        g,
        h,
        b;
        g = f._fields = f.fields = new Ext.util.Collection(j.getFieldName);
        for (b = 0; b < e; b++) {
            h = d[b];
            if (!h.isField) {
                h = new Ext.data.Field(d[b])
            }
            g.add(h)
        }
        a = g.get(k);
        if (!a) {
            g.add(new Ext.data.Field(k))
        } else {
            a.setType("auto")
        }
        g.addSorter(j.sortConvertFields)
    },
    applyIdentifier: function(a) {
        if (typeof a === "string") {
            a = {
                type: a
            }
        }
        return Ext.factory(a, Ext.data.identifier.Simple, this.getIdentifier(), "data.identifier")
    },
    getFieldName: function(a) {
        return a.getName()
    },
    sortConvertFields: function(a, e) {
        var d = a.hasCustomConvert(),
        b = e.hasCustomConvert();
        if (d && !b) {
            return 1
        }
        if (!d && b) {
            return - 1
        }
        return 0
    },
    onClassExtended: function(m, e, k) {
        var g = k.onBeforeCreated,
        b = this,
        i = b.prototype,
        f = Ext.Class.configNameCache,
        h = i.staticConfigs.concat(e.staticConfigs || []),
        d = i.config,
        a = e.config || {},
        j;
        e.config = a;
        k.onBeforeCreated = function(E, v) {
            var z = [],
            B = E.prototype,
            A = {},
            o = B.config,
            p = h.length,
            s = ["set", "get"],
            u = s.length,
            q = o.associations || [],
            n = Ext.getClassName(E),
            D,
            C,
            t,
            r,
            y;
            for (t = 0; t < p; t++) {
                D = h[t];
                for (r = 0; r < u; r++) {
                    C = f[D][s[r]];
                    if (C in B) {
                        A[C] = b.generateProxyMethod(C)
                    }
                }
            }
            E.addStatics(A);
            E.modelName = n;
            B.modelName = n;
            if (o.belongsTo) {
                z.push("association.belongsto")
            }
            if (o.hasMany) {
                z.push("association.hasmany")
            }
            if (o.hasOne) {
                z.push("association.hasone")
            }
            for (t = 0, y = q.length; t < y; ++t) {
                z.push("association." + q[t].type.toLowerCase())
            }
            if (o.identifier) {
                if (typeof o.identifier === "string") {
                    z.push("data.identifier." + o.identifier)
                } else {
                    if (typeof o.identifier.type === "string") {
                        z.push("data.identifier." + o.identifier.type)
                    }
                }
            }
            if (o.proxy) {
                if (typeof o.proxy === "string") {
                    z.push("proxy." + o.proxy)
                } else {
                    if (typeof o.proxy.type === "string") {
                        z.push("proxy." + o.proxy.type)
                    }
                }
            }
            if (o.validations) {
                z.push("Ext.data.Validations")
            }
            Ext.require(z,
            function() {
                Ext.Function.interceptBefore(k, "onCreated",
                function() {
                    Ext.data.ModelManager.registerType(n, E);
                    var F = E.prototype.superclass;
                    E.prototype.associations = E.associations = E.prototype._associations = (F && F.associations) ? F.associations.clone() : new Ext.util.Collection(function(G) {
                        return G.getName()
                    });
                    E.prototype.validations = E.validations = E.prototype._validations = (F && F.validations) ? F.validations.clone() : new Ext.util.Collection(function(G) {
                        return G.field ? (G.field + "-" + G.type) : (G.name + "-" + G.type)
                    });
                    E.prototype = Ext.Object.chain(E.prototype);
                    E.prototype.initConfig.call(E.prototype, o);
                    delete E.prototype.initConfig
                });
                g.call(b, E, v, k)
            })
        }
    }
});
Ext.define("Ext.util.Grouper", {
    extend: Ext.util.Sorter,
    isGrouper: true,
    config: {
        groupFn: null,
        sortProperty: null,
        sorterFn: function(e, d) {
            var f = this.getSortProperty(),
            h,
            b,
            g,
            a;
            h = this.getGroupFn();
            b = h.call(this, e);
            g = h.call(this, d);
            if (f) {
                if (b !== g) {
                    return this.defaultSortFn.call(this, e, d)
                } else {
                    return 0
                }
            }
            return (b > g) ? 1 : ((b < g) ? -1 : 0)
        }
    },
    defaultSortFn: function(f, d) {
        var h = this,
        g = h._transform,
        b = h._root,
        e, a, i = h._sortProperty;
        if (b !== null) {
            f = f[b];
            d = d[b]
        }
        e = f[i];
        a = d[i];
        if (g) {
            e = g(e);
            a = g(a)
        }
        return e > a ? 1 : (e < a ? -1 : 0)
    },
    updateProperty: function(a) {
        this.setGroupFn(this.standardGroupFn)
    },
    standardGroupFn: function(b) {
        var a = this.getRoot(),
        e = this.getProperty(),
        d = b;
        if (a) {
            d = b[a]
        }
        return d[e]
    },
    getGroupString: function(a) {
        var b = this.getGroupFn().call(this, a);
        return (b !== null && typeof b != "undefined") ? b.toString() : ""
    }
});
Ext.define("Ext.data.Store", {
    alias: "store.store",
    extend: Ext.Evented,
    statics: {
        create: function(a) {
            if (!a.isStore) {
                if (!a.type) {
                    a.type = "store"
                }
                a = Ext.createByAlias("store." + a.type, a)
            }
            return a
        }
    },
    isStore: true,
    config: {
        storeId: undefined,
        data: null,
        autoLoad: null,
        autoSync: false,
        model: undefined,
        proxy: undefined,
        fields: null,
        remoteSort: false,
        remoteFilter: false,
        remoteGroup: false,
        filters: null,
        sorters: null,
        grouper: null,
        groupField: null,
        groupDir: null,
        getGroupString: null,
        pageSize: 25,
        totalCount: null,
        clearOnPageLoad: true,
        params: {},
        modelDefaults: {},
        autoDestroy: false,
        syncRemovedRecords: true,
        destroyRemovedRecords: true,
        buffered: false,
        plugins: null
    },
    currentPage: 1,
    constructor: function(a) {
        a = a || {};
        this.data = this._data = this.createDataCollection();
        this.data.setSortRoot("data");
        this.data.setFilterRoot("data");
        this.removed = [];
        if (a.id && !a.storeId) {
            a.storeId = a.id;
            delete a.id
        }
        this.initConfig(a);
        this.callParent(arguments)
    },
    applyPlugins: function(a) {
        var d, b, e;
        if (!a) {
            return a
        }
        a = [].concat(a);
        for (b = 0, d = a.length; b < d; b++) {
            e = a[b];
            a[b] = Ext.factory(e, "Ext.plugin.Plugin", null, "plugin")
        }
        return a
    },
    updatePlugins: function(e, a) {
        var d, b;
        if (e) {
            for (b = 0, d = e.length; b < d; b++) {
                e[b].init(this)
            }
        }
        if (a) {
            for (b = 0, d = a.length; b < d; b++) {
                Ext.destroy(a[b])
            }
        }
    },
    createDataCollection: function() {
        return new Ext.util.Collection(function(a) {
            return a.getId()
        })
    },
    applyStoreId: function(a) {
        if (a === undefined || a === null) {
            a = this.getUniqueId()
        }
        return a
    },
    updateStoreId: function(a, b) {
        if (b) {
            Ext.data.StoreManager.unregister(this)
        }
        if (a) {
            Ext.data.StoreManager.register(this)
        }
    },
    applyModel: function(b) {
        if (typeof b == "string") {
            var e = Ext.data.ModelManager.getModel(b);
            if (!e) {
                Ext.Logger.error('Model with name "' + b + '" does not exist.')
            }
            b = e
        }
        if (b && !b.prototype.isModel && Ext.isObject(b)) {
            b = Ext.data.ModelManager.registerType(b.storeId || b.id || Ext.id(), b)
        }
        if (!b) {
            var a = this.getFields(),
            d = this.config.data;
            if (!a && d && d.length) {
                a = Ext.Object.getKeys(d[0])
            }
            if (a) {
                b = Ext.define("Ext.data.Store.ImplicitModel-" + (this.getStoreId() || Ext.id()), {
                    extend: "Ext.data.Model",
                    config: {
                        fields: a,
                        useCache: false,
                        proxy: this.getProxy()
                    }
                });
                this.implicitModel = true
            }
        }
        if (!b && this.getProxy()) {
            b = this.getProxy().getModel()
        }
        return b
    },
    updateModel: function(a) {
        var b = this.getProxy();
        if (b && !b.getModel()) {
            b.setModel(a)
        }
    },
    applyProxy: function(b, a) {
        b = Ext.factory(b, Ext.data.Proxy, a, "proxy");
        if (!b && this.getModel()) {
            b = this.getModel().getProxy()
        }
        if (!b) {
            b = new Ext.data.proxy.Memory({
                model: this.getModel()
            })
        }
        if (b.isMemoryProxy) {
            this.setSyncRemovedRecords(false)
        }
        return b
    },
    updateProxy: function(b, a) {
        if (b) {
            if (!b.getModel()) {
                b.setModel(this.getModel())
            }
            b.on("metachange", "onMetaChange", this)
        }
        if (a) {
            b.un("metachange", "onMetaChange", this)
        }
    },
    applyData: function(d) {
        var b = this,
        a;
        if (d) {
            a = b.getProxy();
            if (a instanceof Ext.data.proxy.Memory) {
                a.setData(d);
                b.load();
                return
            } else {
                b.removeAll(true);
                b.fireEvent("clear", b);
                b.suspendEvents();
                b.add(d);
                b.resumeEvents();
                b.dataLoaded = true
            }
        } else {
            b.removeAll(true);
            b.fireEvent("clear", b)
        }
        b.fireEvent("refresh", b, b.data)
    },
    clearData: function() {
        this.setData(null)
    },
    addData: function(e) {
        var a = this.getProxy().getReader(),
        d = a.read(e),
        b = d.getRecords();
        this.add(b)
    },
    updateAutoLoad: function(a) {
        var b = this.getProxy();
        if (a && (b && !b.isMemoryProxy)) {
            this.load(Ext.isObject(a) ? a: null)
        }
    },
    isAutoLoading: function() {
        var a = this.getProxy();
        return (this.getAutoLoad() || (a && a.isMemoryProxy) || this.dataLoaded)
    },
    updateGroupField: function(a) {
        var b = this.getGrouper();
        if (a) {
            if (!b) {
                this.setGrouper({
                    property: a,
                    direction: this.getGroupDir() || "ASC"
                })
            } else {
                b.setProperty(a)
            }
        } else {
            if (b) {
                this.setGrouper(null)
            }
        }
    },
    updateGroupDir: function(a) {
        var b = this.getGrouper();
        if (b) {
            b.setDirection(a)
        }
    },
    applyGetGroupString: function(b) {
        var a = this.getGrouper();
        if (b) {
            if (a) {
                a.setGroupFn(b)
            } else {
                this.setGrouper({
                    groupFn: b
                })
            }
        } else {
            if (a) {
                this.setGrouper(null)
            }
        }
    },
    applyGrouper: function(a) {
        if (typeof a == "string") {
            a = {
                property: a
            }
        } else {
            if (typeof a == "function") {
                a = {
                    groupFn: a
                }
            }
        }
        a = Ext.factory(a, Ext.util.Grouper);
        return a
    },
    updateGrouper: function(b, a) {
        var d = this.data;
        if (a) {
            d.removeSorter(a);
            if (!b) {
                d.getSorters().removeSorter("isGrouper")
            }
        }
        if (b) {
            d.insertSorter(0, b);
            if (!a) {
                d.getSorters().addSorter({
                    direction: "DESC",
                    property: "isGrouper",
                    transform: function(e) {
                        return (e === true) ? 1 : -1
                    }
                })
            }
        }
        if (a) {
            this.fireEvent("refresh", this, d)
        }
    },
    isGrouped: function() {
        return !! this.getGrouper()
    },
    updateSorters: function(e) {
        var b = this.getGrouper(),
        d = this.data,
        a = d.getAutoSort();
        d.setAutoSort(false);
        d.setSorters(e);
        if (b) {
            d.insertSorter(0, b)
        }
        this.updateSortTypes();
        d.setAutoSort(a)
    },
    updateSortTypes: function() {
        var b = this.getModel(),
        a = b && b.getFields(),
        d = this.data;
        if (a) {
            d.getSorters().each(function(g) {
                var e = g.getProperty(),
                f;
                if (!g.isGrouper && e && !g.getTransform()) {
                    f = a.get(e);
                    if (f) {
                        g.setTransform(f.getSortType())
                    }
                }
            })
        }
    },
    updateFilters: function(a) {
        this.data.setFilters(a)
    },
    add: function(a) {
        if (!Ext.isArray(a)) {
            a = Array.prototype.slice.call(arguments)
        }
        return this.insert(this.data.length, a)
    },
    insert: function(g, b) {
        if (!Ext.isArray(b)) {
            b = Array.prototype.slice.call(arguments, 1)
        }
        var k = this,
        n = false,
        e = this.data,
        h = b.length,
        a = this.getModel(),
        j = k.getModelDefaults(),
        m = false,
        d,
        f;
        b = b.slice();
        for (d = 0; d < h; d++) {
            f = b[d];
            if (!f.isModel) {
                f = new a(f)
            } else {
                if (this.removed.indexOf(f) != -1) {
                    Ext.Array.remove(this.removed, f)
                }
            }
            f.set(j);
            f.join(k);
            b[d] = f;
            n = n || (f.phantom === true)
        }
        if (b.length === 1) {
            m = e.insert(g, b[0]);
            if (m) {
                m = [m]
            }
        } else {
            m = e.insertAll(g, b)
        }
        if (m) {
            k.fireEvent("addrecords", k, m)
        }
        if (k.getAutoSync() && n) {
            k.sync()
        }
        return b
    },
    remove: function(b) {
        if (b.isModel) {
            b = [b]
        }
        var m = this,
        n = false,
        e = 0,
        a = this.getAutoSync(),
        q = m.getSyncRemovedRecords(),
        d = this.getDestroyRemovedRecords(),
        k = b.length,
        p = [],
        h = [],
        o,
        j = m.data.items,
        f,
        g;
        for (; e < k; e++) {
            f = b[e];
            if (m.data.contains(f)) {
                o = (f.phantom === true);
                g = j.indexOf(f);
                if (g !== -1) {
                    h.push(f);
                    p.push(g)
                }
                f.unjoin(m);
                m.data.remove(f);
                if (d && !q && !f.stores.length) {
                    f.destroy()
                } else {
                    if (!o && q) {
                        m.removed.push(f)
                    }
                }
                n = n || !o
            }
        }
        m.fireEvent("removerecords", m, h, p);
        if (a && n) {
            m.sync()
        }
    },
    removeAt: function(b) {
        var a = this.getAt(b);
        if (a) {
            this.remove(a)
        }
    },
    removeAll: function(a) {
        if (a !== true && this.eventFiringSuspended !== true) {
            this.fireAction("clear", [this], "doRemoveAll")
        } else {
            this.doRemoveAll.call(this, true)
        }
    },
    doRemoveAll: function(e) {
        var h = this,
        a = this.getDestroyRemovedRecords(),
        j = this.getSyncRemovedRecords(),
        d = h.data.all.slice(),
        g = d.length,
        f,
        b;
        for (f = 0; f < g; f++) {
            b = d[f];
            b.unjoin(h);
            if (a && !j && !b.stores.length) {
                b.destroy()
            } else {
                if (b.phantom !== true && j) {
                    h.removed.push(b)
                }
            }
        }
        h.data.clear();
        if (e !== true) {
            h.fireEvent("refresh", h, h.data)
        }
        if (h.getAutoSync()) {
            this.sync()
        }
    },
    each: function(b, a) {
        this.data.each(b, a)
    },
    getCount: function() {
        return this.data.items.length || 0
    },
    getAllCount: function() {
        return this.data.all.length || 0
    },
    getAt: function(a) {
        return this.data.getAt(a)
    },
    getRange: function(b, a) {
        return this.data.getRange(b, a)
    },
    getById: function(a) {
        return this.data.findBy(function(b) {
            return b.getId() == a
        })
    },
    indexOf: function(a) {
        return this.data.indexOf(a)
    },
    indexOfId: function(a) {
        return this.data.indexOfKey(a)
    },
    afterEdit: function(d, h, e) {
        var g = this,
        i = g.data,
        a = e[d.getIdProperty()] || d.getId(),
        b = i.keys.indexOf(a),
        f;
        if (b === -1 && i.map[a] === undefined) {
            return
        }
        if (g.getAutoSync()) {
            g.sync()
        }
        if (a !== d.getId()) {
            i.replace(a, d)
        } else {
            i.replace(d)
        }
        f = i.indexOf(d);
        if (b === -1 && f !== -1) {
            g.fireEvent("addrecords", g, [d])
        } else {
            if (b !== -1 && f === -1) {
                g.fireEvent("removerecords", g, [d], [b])
            } else {
                if (f !== -1) {
                    g.fireEvent("updaterecord", g, d, f, b, h, e)
                }
            }
        }
    },
    afterReject: function(a) {
        var b = this.data.indexOf(a);
        this.fireEvent("updaterecord", this, a, b, b, [], {})
    },
    afterCommit: function(d, h, e) {
        var g = this,
        i = g.data,
        a = e[d.getIdProperty()] || d.getId(),
        b = i.keys.indexOf(a),
        f;
        if (b === -1 && i.map[a] === undefined) {
            return
        }
        if (a !== d.getId()) {
            i.replace(a, d)
        } else {
            i.replace(d)
        }
        f = i.indexOf(d);
        if (b === -1 && f !== -1) {
            g.fireEvent("addrecords", g, [d])
        } else {
            if (b !== -1 && f === -1) {
                g.fireEvent("removerecords", g, [d], [b])
            } else {
                if (f !== -1) {
                    g.fireEvent("updaterecord", g, d, f, b, h, e)
                }
            }
        }
    },
    afterErase: function(a) {
        var d = this,
        e = d.data,
        b = e.indexOf(a);
        if (b !== -1) {
            e.remove(a);
            d.fireEvent("removerecords", d, [a], [b])
        }
    },
    applyRemoteFilter: function(b) {
        var a = this.getProxy();
        return b || (a && a.isSQLProxy === true)
    },
    applyRemoteSort: function(b) {
        var a = this.getProxy();
        return b || (a && a.isSQLProxy === true)
    },
    applyRemoteGroup: function(b) {
        var a = this.getProxy();
        return b || (a && a.isSQLProxy === true)
    },
    updateRemoteFilter: function(a) {
        this.data.setAutoFilter(!a)
    },
    updateRemoteSort: function(a) {
        this.data.setAutoSort(!a)
    },
    sort: function(g, e, d) {
        var f = this.data,
        b = this.getGrouper(),
        a = f.getAutoSort();
        if (g) {
            f.setAutoSort(false);
            if (typeof d === "string") {
                if (d == "prepend") {
                    f.insertSorters(b ? 1 : 0, g, e)
                } else {
                    f.addSorters(g, e)
                }
            } else {
                f.setSorters(null);
                if (b) {
                    f.addSorters(b)
                }
                f.addSorters(g, e)
            }
            this.updateSortTypes();
            f.setAutoSort(a)
        }
        if (!this.getRemoteSort()) {
            if (!g) {
                this.data.sort()
            }
            this.fireEvent("sort", this, this.data, this.data.getSorters());
            if (f.length) {
                this.fireEvent("refresh", this, this.data)
            }
        }
    },
    filter: function(f, e, g, a) {
        var d = this.data,
        b = null;
        if (f) {
            if (Ext.isFunction(f)) {
                b = {
                    filterFn: f
                }
            } else {
                if (Ext.isArray(f) || f.isFilter) {
                    b = f
                } else {
                    b = {
                        property: f,
                        value: e,
                        anyMatch: g,
                        caseSensitive: a,
                        id: f
                    }
                }
            }
        }
        if (this.getRemoteFilter()) {
            d.addFilters(b)
        } else {
            d.filter(b);
            this.fireEvent("filter", this, d, d.getFilters());
            this.fireEvent("refresh", this, d)
        }
    },
    filterBy: function(b, a) {
        var e = this,
        f = e.data,
        d = f.length;
        f.filter({
            filterFn: function(g) {
                return b.call(a || e, g, g.getId())
            }
        });
        this.fireEvent("filter", this, f, f.getFilters());
        if (f.length !== d) {
            this.fireEvent("refresh", this, f)
        }
    },
    queryBy: function(b, a) {
        return this.data.filterBy(b, a || this)
    },
    clearFilter: function(a) {
        var b = this.data.length;
        if (a) {
            this.suspendEvents()
        }
        this.data.setFilters(null);
        if (a) {
            this.resumeEvents(true)
        } else {
            if (b !== this.data.length) {
                this.fireEvent("refresh", this, this.data)
            }
        }
    },
    isFiltered: function() {
        return this.data.filtered
    },
    isSorted: function() {
        return this.data.sorted
    },
    getSorters: function() {
        var a = this.data.getSorters();
        return (a) ? a.items: []
    },
    getFilters: function() {
        var a = this.data.getFilters();
        return (a) ? a.items: []
    },
    getGroups: function(d) {
        var f = this.data.items,
        b = f.length,
        a = this.getGrouper(),
        e = [],
        m = {},
        h,
        j,
        k,
        g;
        for (g = 0; g < b; g++) {
            h = f[g];
            j = a.getGroupString(h);
            k = m[j];
            if (k === undefined) {
                k = {
                    name: j,
                    children: []
                };
                e.push(k);
                m[j] = k
            }
            k.children.push(h)
        }
        return d ? m[d] : e
    },
    getGroupString: function(a) {
        var b = this.getGrouper();
        if (b) {
            return b.getGroupString(a)
        }
        return null
    },
    find: function(h, e, f, g, a, d) {
        var b = Ext.create("Ext.util.Filter", {
            property: h,
            value: e,
            anyMatch: g,
            caseSensitive: a,
            exactMatch: d,
            root: "data"
        });
        return this.data.findIndexBy(b.getFilterFn(), null, f)
    },
    findRecord: function() {
        var b = this,
        a = b.find.apply(b, arguments);
        return a !== -1 ? b.getAt(a) : null
    },
    findExact: function(d, a, b) {
        return this.data.findIndexBy(function(e) {
            return e.get(d) === a
        },
        this, b)
    },
    findBy: function(b, a, d) {
        return this.data.findIndexBy(b, a, d)
    },
    load: function(d, f) {
        var g = this,
        b, e = g.currentPage,
        a = g.getPageSize();
        d = d || {};
        if (Ext.isFunction(d)) {
            d = {
                callback: d,
                scope: f || this
            }
        }
        if (g.getRemoteSort()) {
            d.sorters = d.sorters || this.getSorters()
        }
        if (g.getRemoteFilter()) {
            d.filters = d.filters || this.getFilters()
        }
        if (g.getRemoteGroup()) {
            d.grouper = d.grouper || this.getGrouper()
        }
        Ext.applyIf(d, {
            page: e,
            start: (e - 1) * a,
            limit: a,
            addRecords: false,
            action: "read",
            params: this.getParams(),
            model: this.getModel()
        });
        b = Ext.create("Ext.data.Operation", d);
        if (g.fireEvent("beforeload", g, b) !== false) {
            g.loading = true;
            g.getProxy().read(b, g.onProxyLoad, g)
        }
        return g
    },
    isLoading: function() {
        return Boolean(this.loading)
    },
    isLoaded: function() {
        return Boolean(this.loaded)
    },
    sync: function(d) {
        var f = this,
        b = {},
        g = f.getNewRecords(),
        e = f.getUpdatedRecords(),
        a = f.getRemovedRecords(),
        h = false;
        if (g.length > 0) {
            b.create = g;
            h = true
        }
        if (e.length > 0) {
            b.update = e;
            h = true
        }
        if (a.length > 0) {
            b.destroy = a;
            h = true
        }
        if (h && f.fireEvent("beforesync", this, b) !== false) {
            f.getProxy().batch(Ext.merge({
                operations: b,
                listeners: f.getBatchListeners()
            },
            d || {}))
        }
        return {
            added: g,
            updated: e,
            removed: a
        }
    },
    first: function() {
        return this.data.first()
    },
    last: function() {
        return this.data.last()
    },
    sum: function(f) {
        var e = 0,
        d = 0,
        b = this.data.items,
        a = b.length;
        for (; d < a; ++d) {
            e += b[d].get(f)
        }
        return e
    },
    min: function(g) {
        var e = 1,
        b = this.data.items,
        a = b.length,
        f, d;
        if (a > 0) {
            d = b[0].get(g)
        }
        for (; e < a; ++e) {
            f = b[e].get(g);
            if (f < d) {
                d = f
            }
        }
        return d
    },
    max: function(g) {
        var e = 1,
        d = this.data.items,
        b = d.length,
        f, a;
        if (b > 0) {
            a = d[0].get(g)
        }
        for (; e < b; ++e) {
            f = d[e].get(g);
            if (f > a) {
                a = f
            }
        }
        return a
    },
    average: function(f) {
        var d = 0,
        b = this.data.items,
        a = b.length,
        e = 0;
        if (b.length > 0) {
            for (; d < a; ++d) {
                e += b[d].get(f)
            }
            return e / a
        }
        return 0
    },
    getBatchListeners: function() {
        return {
            scope: this,
            exception: this.onBatchException,
            complete: this.onBatchComplete
        }
    },
    onBatchComplete: function(b) {
        var f = this,
        a = b.operations,
        e = a.length,
        d;
        for (d = 0; d < e; d++) {
            f.onProxyWrite(a[d])
        }
    },
    onBatchException: function(b, a) {},
    onProxyLoad: function(b) {
        var e = this,
        a = b.getRecords(),
        d = b.getResultSet(),
        f = b.wasSuccessful();
        if (d) {
            e.setTotalCount(d.getTotal())
        }
        if (f) {
            this.fireAction("datarefresh", [this, this.data, b], "doDataRefresh")
        }
        e.loaded = true;
        e.loading = false;
        e.fireEvent("load", this, a, f, b);
        Ext.callback(b.getCallback(), b.getScope() || e, [a, b, f])
    },
    doDataRefresh: function(o, j, e) {
        var d = e.getRecords(),
        n = this,
        g = n.getDestroyRemovedRecords(),
        f = j.all.slice(),
        m = f.length,
        b = d.length,
        a = {},
        h,
        k;
        if (e.getAddRecords() !== true) {
            for (h = 0; h < b; h++) {
                a[d[h].id] = true
            }
            for (h = 0; h < m; h++) {
                k = f[h];
                k.unjoin(n);
                if (a[k.id] !== true && g && !k.stores.length) {
                    k.destroy()
                }
            }
            j.clear();
            n.fireEvent("clear", n)
        }
        if (d && d.length) {
            n.suspendEvents();
            n.add(d);
            n.resumeEvents(true)
        }
        n.fireEvent("refresh", n, j)
    },
    onProxyWrite: function(b) {
        var d = this,
        e = b.wasSuccessful(),
        a = b.getRecords();
        switch (b.getAction()) {
        case "create":
            d.onCreateRecords(a, b, e);
            break;
        case "update":
            d.onUpdateRecords(a, b, e);
            break;
        case "destroy":
            d.onDestroyRecords(a, b, e);
            break
        }
        if (e) {
            d.fireEvent("write", d, b)
        }
        Ext.callback(b.getCallback(), b.getScope() || d, [a, b, e])
    },
    onCreateRecords: function(b, a, d) {},
    onUpdateRecords: function(b, a, d) {},
    onDestroyRecords: function(b, a, d) {
        this.removed = []
    },
    onMetaChange: function(b) {
        var a = this.getProxy().getModel();
        if (!this.getModel() && a) {
            this.setModel(a)
        }
        this.fireEvent("metachange", this, b)
    },
    getNewRecords: function() {
        return this.data.filterBy(function(a) {
            return a.phantom === true && a.isValid()
        }).items
    },
    getUpdatedRecords: function() {
        return this.data.filterBy(function(a) {
            return a.dirty === true && a.phantom !== true && a.isValid()
        }).items
    },
    getRemovedRecords: function() {
        return this.removed
    },
    loadPage: function(g, d, e) {
        if (typeof d === "function") {
            d = {
                callback: d,
                scope: e || this
            }
        }
        var f = this,
        b = f.getPageSize(),
        a = f.getClearOnPageLoad();
        d = Ext.apply({},
        d);
        f.currentPage = g;
        f.load(Ext.applyIf(d, {
            page: g,
            start: (g - 1) * b,
            limit: b,
            addRecords: !a
        }))
    },
    nextPage: function(a) {
        this.loadPage(this.currentPage + 1, a)
    },
    previousPage: function(a) {
        this.loadPage(this.currentPage - 1, a)
    },
    destroy: function() {
        this.clearData();
        var a = this.getProxy();
        if (a) {
            a.onDestroy()
        }
        Ext.data.StoreManager.unregister(this);
        Ext.destroy(this.getPlugins());
        if (this.implicitModel && this.getModel()) {
            delete Ext.data.ModelManager.types[this.getModel().getName()]
        }
        Ext.destroy(this.data);
        this.callParent(arguments)
    }
});
Ext.define("Ext.event.publisher.Publisher", {
    targetType: "",
    idSelectorRegex: /^#([\w\-]+)$/i,
    constructor: function() {
        var b = this.handledEvents,
        a, d, f, e;
        a = this.handledEventsMap = {};
        for (d = 0, f = b.length; d < f; d++) {
            e = b[d];
            a[e] = true
        }
        this.subscribers = {};
        return this
    },
    handles: function(a) {
        var b = this.handledEventsMap;
        return !! b[a] || !!b["*"] || a === "*"
    },
    getHandledEvents: function() {
        return this.handledEvents
    },
    setDispatcher: function(a) {
        this.dispatcher = a
    },
    subscribe: function() {
        return false
    },
    unsubscribe: function() {
        return false
    },
    unsubscribeAll: function() {
        delete this.subscribers;
        this.subscribers = {};
        return this
    },
    notify: function() {
        return false
    },
    getTargetType: function() {
        return this.targetType
    },
    dispatch: function(d, a, b) {
        this.dispatcher.doDispatchEvent(this.targetType, d, a, b)
    }
});
Ext.define("Ext.chart.series.ItemPublisher", {
    extend: Ext.event.publisher.Publisher,
    targetType: "series",
    handledEvents: ["itemmousemove", "itemmouseup", "itemmousedown", "itemmouseover", "itemmouseout", "itemclick", "itemdoubleclick", "itemtap", "itemtapstart", "itemtapend", "itemtapcancel", "itemtaphold", "itemdoubletap", "itemsingletap", "itemtouchstart", "itemtouchmove", "itemtouchend", "itemdragstart", "itemdrag", "itemdragend", "itempinchstart", "itempinch", "itempinchend", "itemswipe"],
    delegationRegex: /^item([a-z]+)$/i,
    getSubscribers: function(b) {
        var a = this.subscribers;
        if (!a.hasOwnProperty(b)) {
            a[b] = {}
        }
        return a[b]
    },
    subscribe: function(g, a) {
        var b = g.match(this.idSelectorRegex),
        e = this.dispatcher,
        f = this.targetType,
        d,
        h;
        if (!b) {
            return false
        }
        h = b[1];
        d = Ext.ComponentManager.get(h);
        if (!d) {
            return false
        }
        if (!d.getChart()) {
            e.addListener(f, g, "chartattached", "attachChart", this, [d, a], "before")
        } else {
            this.attachChart(d.getChart(), [d, a])
        }
        return true
    },
    attachChart: function(g, h) {
        var j = this.dispatcher,
        b = this.targetType,
        d = h[0],
        f = h[1],
        a = this.getSubscribers(g.getId()),
        e = f.match(this.delegationRegex);
        if (e) {
            var i = e[1];
            if (!a.hasOwnProperty(f)) {
                a[f] = [];
                j.addListener(b, "#" + d.getId(), "chartdetached", "detachChart", this, [d, f, a], "after");
                g.element.on(i, "relayMethod", this, [g, f])
            }
            a[f].push(d);
            return true
        } else {
            return false
        }
    },
    unsubscribe: function(g, a) {
        var b = g.match(this.idSelectorRegex),
        e = this.dispatcher,
        f = this.targetType,
        d,
        h;
        if (!b) {
            return false
        }
        h = b[1];
        d = Ext.ComponentManager.get(h);
        if (!d) {
            return false
        }
        e.removeListener(f, g, "chartattached", "attachChart", this, "before");
        if (d.getChart()) {
            this.detachChart(d.getChart(), [d, a])
        }
        return true
    },
    detachChart: function(i, j) {
        var m = this.dispatcher,
        b = this.targetType,
        e = j[0],
        g = j[1],
        a = this.getSubscribers(i.getId()),
        f = g.match(this.delegationRegex),
        h,
        d;
        if (f) {
            var k = f[1];
            if (a.hasOwnProperty(g)) {
                d = a[g];
                h = d.indexOf(e);
                if (h > -1) {
                    d.splice(h, 1)
                }
                if (d.length === 0) {
                    i.element.un(k, "relayMethod", this, [i, g]);
                    m.removeListener(b, "#" + e.getId(), "chartdetached", "detachChart", this, "after");
                    delete a[g]
                }
            }
        }
    },
    relayMethod: function(j, g, n) {
        var m = n[0],
        h = n[1],
        s = this.dispatcher,
        a = this.targetType,
        b = m.getEventXY(j),
        p = b[0],
        o = b[1],
        r = this.getSubscribers(m.getId())[h],
        f,
        k;
        if (r) {
            for (f = 0, k = r.length; f < k; f++) {
                var d = r[f],
                q = d.getItemForPoint(p, o);
                if (q) {
                    s.doDispatchEvent(a, "#" + d.getId(), h, [d, q, j]);
                    return
                }
            }
        }
    }
},
function() {});
Ext.define("Ext.data.ArrayStore", {
    extend: Ext.data.Store,
    alias: "store.array",
    config: {
        proxy: {
            type: "memory",
            reader: "array"
        }
    },
    loadData: function(b, a) {
        this.callParent([b, a])
    }
},
function() {
    Ext.data.SimpleStore = Ext.data.ArrayStore
});
Ext.define("Ext.event.Event", {
    alternateClassName: "Ext.EventObject",
    isStopped: false,
    set: function(a, b) {
        if (arguments.length === 1 && typeof a != "string") {
            var d = a;
            for (a in d) {
                if (d.hasOwnProperty(a)) {
                    this[a] = d[a]
                }
            }
        } else {
            this[a] = d[a]
        }
    },
    stopEvent: function() {
        return this.stopPropagation()
    },
    stopPropagation: function() {
        this.isStopped = true;
        return this
    }
});
Ext.define("Ext.event.Dom", {
    extend: Ext.event.Event,
    constructor: function(a) {
        var d = a.target,
        b;
        if (d && d.nodeType !== 1) {
            d = d.parentNode
        }
        b = a.changedTouches;
        if (b) {
            b = b[0];
            this.pageX = b.pageX;
            this.pageY = b.pageY
        } else {
            this.pageX = a.pageX;
            this.pageY = a.pageY
        }
        this.browserEvent = this.event = a;
        this.target = this.delegatedTarget = d;
        this.type = a.type;
        this.timeStamp = this.time = +a.timeStamp;
        return this
    },
    stopEvent: function() {
        this.preventDefault();
        return this.callParent()
    },
    preventDefault: function() {
        this.browserEvent.preventDefault()
    },
    getPageX: function() {
        return this.pageX || this.browserEvent.pageX
    },
    getPageY: function() {
        return this.pageY || this.browserEvent.pageY
    },
    getXY: function() {
        if (!this.xy) {
            this.xy = [this.getPageX(), this.getPageY()]
        }
        return this.xy
    },
    getTarget: function(b, d, a) {
        if (arguments.length === 0) {
            return this.delegatedTarget
        }
        return b ? Ext.fly(this.target).findParent(b, d, a) : (a ? Ext.get(this.target) : this.target)
    },
    getTime: function() {
        return this.time
    },
    setDelegatedTarget: function(a) {
        this.delegatedTarget = a
    },
    makeUnpreventable: function() {
        this.browserEvent.preventDefault = Ext.emptyFn
    }
});
Ext.define("Ext.event.Touch", {
    extend: Ext.event.Dom,
    constructor: function(b, d, a, j) {
        var g = [],
        e,
        f,
        k,
        h;
        if (d) {
            this.set(d)
        }
        this.changedTouches = this.cloneTouches(b.changedTouches, a);
        for (f = 0, k = j.length; f < k; f++) {
            h = j[f];
            g.push(a[h])
        }
        this.touches = g;
        this.targetTouches = g.slice();
        e = this.changedTouches[0];
        this.callSuper([b]);
        this.target = this.delegatedTarget = e.target;
        this.pageX = e.pageX;
        this.pageY = e.pageY
    },
    cloneTouches: function(g, f) {
        var e = [],
        b,
        d,
        h,
        a;
        for (b = 0, d = g.length; b < d; b++) {
            h = g[b];
            a = h.identifier;
            e[b] = f[a]
        }
        return e
    }
});
Ext.define("Ext.event.publisher.ComponentDelegation", {
    extend: Ext.event.publisher.Publisher,
    targetType: "component",
    optimizedSelectorRegex: /^#([\w\-]+)((?:[\s]*)>(?:[\s]*)|(?:\s*))([\w\-]+)$/i,
    handledEvents: ["*"],
    getSubscribers: function(b, a) {
        var e = this.subscribers,
        d = e[b];
        if (!d && a) {
            d = e[b] = {
                type: {
                    $length: 0
                },
                selector: [],
                $length: 0
            }
        }
        return d
    },
    subscribe: function(h, g) {
        if (this.idSelectorRegex.test(h)) {
            return false
        }
        var f = h.match(this.optimizedSelectorRegex),
        a = this.getSubscribers(g, true),
        m = a.type,
        d = a.selector,
        e,
        j,
        k,
        b,
        i;
        if (f !== null) {
            e = f[1];
            j = f[2].indexOf(">") === -1;
            k = f[3];
            b = m[k];
            if (!b) {
                m[k] = b = {
                    descendents: {
                        $length: 0
                    },
                    children: {
                        $length: 0
                    },
                    $length: 0
                }
            }
            i = j ? b.descendents: b.children;
            if (i.hasOwnProperty(e)) {
                i[e]++;
                return true
            }
            i[e] = 1;
            i.$length++;
            b.$length++;
            m.$length++
        } else {
            if (d.hasOwnProperty(h)) {
                d[h]++;
                return true
            }
            d[h] = 1;
            d.push(h)
        }
        a.$length++;
        return true
    },
    unsubscribe: function(h, g, m) {
        var a = this.getSubscribers(g);
        if (!a) {
            return false
        }
        var f = h.match(this.optimizedSelectorRegex),
        n = a.type,
        d = a.selector,
        e,
        j,
        k,
        b,
        i;
        m = Boolean(m);
        if (f !== null) {
            e = f[1];
            j = f[2].indexOf(">") === -1;
            k = f[3];
            b = n[k];
            if (!b) {
                return true
            }
            i = j ? b.descendents: b.children;
            if (!i.hasOwnProperty(e) || (!m && --i[e] > 0)) {
                return true
            }
            delete i[e];
            i.$length--;
            b.$length--;
            n.$length--
        } else {
            if (!d.hasOwnProperty(h) || (!m && --d[h] > 0)) {
                return true
            }
            delete d[h];
            Ext.Array.remove(d, h)
        }
        if (--a.$length === 0) {
            delete this.subscribers[g]
        }
        return true
    },
    notify: function(e, a) {
        var d = this.getSubscribers(a),
        f,
        b;
        if (!d || d.$length === 0) {
            return false
        }
        f = e.substr(1);
        b = Ext.ComponentManager.get(f);
        if (b) {
            this.dispatcher.doAddListener(this.targetType, e, a, "publish", this, {
                args: [a, b]
            },
            "before")
        }
    },
    matchesSelector: function(b, a) {
        return Ext.ComponentQuery.is(b, a)
    },
    dispatch: function(e, b, d, a) {
        this.dispatcher.doDispatchEvent(this.targetType, e, b, d, null, a)
    },
    publish: function(h, m) {
        var f = this.getSubscribers(h);
        if (!f) {
            return
        }
        var r = arguments[arguments.length - 1],
        q = f.type,
        b = f.selector,
        e = Array.prototype.slice.call(arguments, 2, -2),
        n = m.xtypesChain,
        u,
        p,
        v,
        a,
        o,
        z,
        t,
        y,
        k,
        g,
        s,
        d;
        for (y = 0, k = n.length; y < k; y++) {
            g = n[y];
            f = q[g];
            if (f && f.$length > 0) {
                u = f.descendents;
                if (u.$length > 0) {
                    if (!a) {
                        a = m.getAncestorIds()
                    }
                    for (s = 0, d = a.length; s < d; s++) {
                        o = a[s];
                        if (u.hasOwnProperty(o)) {
                            this.dispatch("#" + o + " " + g, h, e, r)
                        }
                    }
                }
                p = f.children;
                if (p.$length > 0) {
                    if (!v) {
                        if (a) {
                            v = a[0]
                        } else {
                            z = m.getParent();
                            if (z) {
                                v = z.getId()
                            }
                        }
                    }
                    if (v) {
                        if (p.hasOwnProperty(v)) {
                            this.dispatch("#" + v + " > " + g, h, e, r)
                        }
                    }
                }
            }
        }
        k = b.length;
        if (k > 0) {
            for (y = 0; y < k; y++) {
                t = b[y];
                if (this.matchesSelector(m, t)) {
                    this.dispatch(t, h, e, r)
                }
            }
        }
    }
});
Ext.define("Ext.event.publisher.ComponentPaint", {
    extend: Ext.event.publisher.Publisher,
    targetType: "component",
    handledEvents: ["erased"],
    eventNames: {
        painted: "painted",
        erased: "erased"
    },
    constructor: function() {
        this.callParent(arguments);
        this.hiddenQueue = {};
        this.renderedQueue = {}
    },
    getSubscribers: function(b, a) {
        var d = this.subscribers;
        if (!d.hasOwnProperty(b)) {
            if (!a) {
                return null
            }
            d[b] = {
                $length: 0
            }
        }
        return d[b]
    },
    setDispatcher: function(a) {
        var b = this.targetType;
        a.doAddListener(b, "*", "renderedchange", "onBeforeComponentRenderedChange", this, null, "before");
        a.doAddListener(b, "*", "hiddenchange", "onBeforeComponentHiddenChange", this, null, "before");
        a.doAddListener(b, "*", "renderedchange", "onComponentRenderedChange", this, null, "after");
        a.doAddListener(b, "*", "hiddenchange", "onComponentHiddenChange", this, null, "after");
        return this.callParent(arguments)
    },
    subscribe: function(e, a) {
        var b = e.match(this.idSelectorRegex),
        d,
        f;
        if (!b) {
            return false
        }
        f = b[1];
        d = this.getSubscribers(a, true);
        if (d.hasOwnProperty(f)) {
            d[f]++;
            return true
        }
        d[f] = 1;
        d.$length++;
        return true
    },
    unsubscribe: function(f, a, d) {
        var b = f.match(this.idSelectorRegex),
        e,
        g;
        if (!b || !(e = this.getSubscribers(a))) {
            return false
        }
        g = b[1];
        if (!e.hasOwnProperty(g) || (!d && --e[g] > 0)) {
            return true
        }
        delete e[g];
        if (--e.$length === 0) {
            delete this.subscribers[a]
        }
        return true
    },
    onBeforeComponentRenderedChange: function(b, e, h) {
        var g = this.eventNames,
        d = h ? g.painted: g.erased,
        f = this.getSubscribers(d),
        a;
        if (f && f.$length > 0) {
            this.renderedQueue[e.getId()] = a = [];
            this.publish(f, e, d, a)
        }
    },
    onBeforeComponentHiddenChange: function(d, e) {
        var g = this.eventNames,
        b = e ? g.erased: g.painted,
        f = this.getSubscribers(b),
        a;
        if (f && f.$length > 0) {
            this.hiddenQueue[d.getId()] = a = [];
            this.publish(f, d, b, a)
        }
    },
    onComponentRenderedChange: function(b, d) {
        var e = this.renderedQueue,
        f = d.getId(),
        a;
        if (!e.hasOwnProperty(f)) {
            return
        }
        a = e[f];
        delete e[f];
        if (a.length > 0) {
            this.dispatchQueue(a)
        }
    },
    onComponentHiddenChange: function(d) {
        var b = this.hiddenQueue,
        e = d.getId(),
        a;
        if (!b.hasOwnProperty(e)) {
            return
        }
        a = b[e];
        delete b[e];
        if (a.length > 0) {
            this.dispatchQueue(a)
        }
    },
    dispatchQueue: function(h) {
        var n = this.dispatcher,
        a = this.targetType,
        b = this.eventNames,
        f = h.slice(),
        g = f.length,
        d,
        m,
        j,
        e,
        k;
        h.length = 0;
        if (g > 0) {
            for (d = 0; d < g; d++) {
                m = f[d];
                j = m.component;
                e = m.eventName;
                k = j.isPainted();
                if ((e === b.painted && k) || e === b.erased && !k) {
                    n.doDispatchEvent(a, "#" + m.id, e, [j])
                }
            }
            f.length = 0
        }
    },
    publish: function(a, m, g, k) {
        var d = m.getId(),
        b = false,
        e,
        j,
        f,
        h,
        n;
        if (a[d]) {
            e = this.eventNames;
            n = m.isPainted();
            if ((g === e.painted && !n) || g === e.erased && n) {
                b = true
            } else {
                return this
            }
        }
        if (m.isContainer) {
            j = m.getItems().items;
            for (f = 0, h = j.length; f < h; f++) {
                this.publish(a, j[f], g, k)
            }
        } else {
            if (m.isDecorator) {
                this.publish(a, m.getComponent(), g, k)
            }
        }
        if (b) {
            k.push({
                id: d,
                eventName: g,
                component: m
            })
        }
    }
});
Ext.define("Ext.event.publisher.Dom", {
    extend: Ext.event.publisher.Publisher,
    targetType: "element",
    idOrClassSelectorRegex: /^([#|\.])([\w\-]+)$/,
    handledEvents: ["focus", "blur", "paste", "input", "change", "keyup", "keydown", "keypress", "submit", "transitionend", "animationstart", "animationend"],
    classNameSplitRegex: /\s+/,
    SELECTOR_ALL: "*",
    constructor: function() {
        var g = this.getHandledEvents(),
        f = {},
        b,
        d,
        a,
        e;
        this.doBubbleEventsMap = {
            click: true,
            submit: true,
            mousedown: true,
            mousemove: true,
            mouseup: true,
            mouseover: true,
            mouseout: true,
            transitionend: true
        };
        this.onEvent = Ext.Function.bind(this.onEvent, this);
        for (b = 0, d = g.length; b < d; b++) {
            a = g[b];
            e = this.getVendorEventName(a);
            f[e] = a;
            this.attachListener(e)
        }
        this.eventNameMap = f;
        return this.callParent()
    },
    getSubscribers: function(a) {
        var d = this.subscribers,
        b = d[a];
        if (!b) {
            b = d[a] = {
                id: {
                    $length: 0
                },
                className: {
                    $length: 0
                },
                selector: [],
                all: 0,
                $length: 0
            }
        }
        return b
    },
    getVendorEventName: function(a) {
        if (Ext.browser.is.WebKit) {
            if (a === "transitionend") {
                a = Ext.browser.getVendorProperyName("transitionEnd")
            } else {
                if (a === "animationstart") {
                    a = Ext.browser.getVendorProperyName("animationStart")
                } else {
                    if (a === "animationend") {
                        a = Ext.browser.getVendorProperyName("animationEnd")
                    }
                }
            }
        }
        return a
    },
    bindListeners: function(e, f) {
        var a = this.getHandledEvents(),
        d = a.length,
        b;
        for (b = 0; b < d; b++) {
            this.bindListener(e, this.getVendorEventName(a[b]), f)
        }
    },
    bindListener: function(b, a, d) {
        if (d) {
            this.attachListener(a, b)
        } else {
            this.removeListener(a, b)
        }
        return this
    },
    attachListener: function(a, d) {
        if (!d) {
            d = document
        }
        var b = d.defaultView;
        if (Ext.os.is.iOS && Ext.os.version.getMajor() < 5) {
            document.addEventListener(a, this.onEvent, !this.doesEventBubble(a))
        } else {
            if (b && b.addEventListener) {
                d.defaultView.addEventListener(a, this.onEvent, !this.doesEventBubble(a))
            } else {
                d.addEventListener(a, this.onEvent, !this.doesEventBubble(a))
            }
        }
        return this
    },
    removeListener: function(a, d) {
        if (!d) {
            d = document
        }
        var b = d.defaultView;
        if (Ext.os.is.iOS && Ext.os.version.getMajor() < 5) {
            document.removeEventListener(a, this.onEvent, !this.doesEventBubble(a))
        } else {
            if (b && b.addEventListener) {
                d.defaultView.removeEventListener(a, this.onEvent, !this.doesEventBubble(a))
            } else {
                d.removeEventListener(a, this.onEvent, !this.doesEventBubble(a))
            }
        }
        return this
    },
    doesEventBubble: function(a) {
        return !! this.doBubbleEventsMap[a]
    },
    subscribe: function(h, g) {
        if (!this.handles(g)) {
            return false
        }
        var f = h.match(this.idOrClassSelectorRegex),
        a = this.getSubscribers(g),
        d = a.id,
        e = a.className,
        b = a.selector,
        i,
        j;
        if (f !== null) {
            i = f[1];
            j = f[2];
            if (i === "#") {
                if (d.hasOwnProperty(j)) {
                    d[j]++;
                    return true
                }
                d[j] = 1;
                d.$length++
            } else {
                if (e.hasOwnProperty(j)) {
                    e[j]++;
                    return true
                }
                e[j] = 1;
                e.$length++
            }
        } else {
            if (h === this.SELECTOR_ALL) {
                a.all++
            } else {
                if (b.hasOwnProperty(h)) {
                    b[h]++;
                    return true
                }
                b[h] = 1;
                b.push(h)
            }
        }
        a.$length++;
        return true
    },
    unsubscribe: function(h, g, k) {
        if (!this.handles(g)) {
            return false
        }
        var f = h.match(this.idOrClassSelectorRegex),
        a = this.getSubscribers(g),
        d = a.id,
        e = a.className,
        b = a.selector,
        i,
        j;
        k = Boolean(k);
        if (f !== null) {
            i = f[1];
            j = f[2];
            if (i === "#") {
                if (!d.hasOwnProperty(j) || (!k && --d[j] > 0)) {
                    return true
                }
                delete d[j];
                d.$length--
            } else {
                if (!e.hasOwnProperty(j) || (!k && --e[j] > 0)) {
                    return true
                }
                delete e[j];
                e.$length--
            }
        } else {
            if (h === this.SELECTOR_ALL) {
                if (k) {
                    a.all = 0
                } else {
                    a.all--
                }
            } else {
                if (!b.hasOwnProperty(h) || (!k && --b[h] > 0)) {
                    return true
                }
                delete b[h];
                Ext.Array.remove(b, h)
            }
        }
        a.$length--;
        return true
    },
    getElementTarget: function(a) {
        if (a.nodeType !== 1) {
            a = a.parentNode;
            if (!a || a.nodeType !== 1) {
                return null
            }
        }
        return a
    },
    getBubblingTargets: function(b) {
        var a = [];
        if (!b) {
            return a
        }
        do {
            a[a.length] = b;
            b = b.parentNode
        } while ( b && b . nodeType === 1 );
        return a
    },
    dispatch: function(d, a, b) {
        b.push(b[0].target);
        this.callParent(arguments)
    },
    publish: function(b, a, d) {
        var e = this.getSubscribers(b),
        f;
        if (e.$length === 0 || !this.doPublish(e, b, a, d)) {
            f = this.getSubscribers("*");
            if (f.$length > 0) {
                this.doPublish(f, b, a, d)
            }
        }
        return this
    },
    doPublish: function(g, k, B, y) {
        var t = g.id,
        h = g.className,
        b = g.selector,
        r = t.$length > 0,
        a = h.$length > 0,
        n = b.length > 0,
        q = g.all > 0,
        C = {},
        f = [y],
        s = false,
        o = this.classNameSplitRegex,
        z,
        m,
        v,
        e,
        D,
        p,
        d,
        A,
        u;
        for (z = 0, m = B.length; z < m; z++) {
            D = B[z];
            y.setDelegatedTarget(D);
            if (r) {
                p = D.getAttribute("id");
                if (p) {
                    if (t.hasOwnProperty(p)) {
                        s = true;
                        this.dispatch("#" + p, k, f)
                    }
                }
            }
            if (a) {
                d = D.className;
                if (d) {
                    A = d.split(o);
                    for (v = 0, e = A.length; v < e; v++) {
                        d = A[v];
                        if (!C[d]) {
                            C[d] = true;
                            if (h.hasOwnProperty(d)) {
                                s = true;
                                this.dispatch("." + d, k, f)
                            }
                        }
                    }
                }
            }
            if (y.isStopped) {
                return s
            }
        }
        if (q && !s) {
            y.setDelegatedTarget(y.browserEvent.target);
            s = true;
            this.dispatch(this.SELECTOR_ALL, k, f);
            if (y.isStopped) {
                return s
            }
        }
        if (n) {
            for (v = 0, e = B.length; v < e; v++) {
                D = B[v];
                for (z = 0, m = b.length; z < m; z++) {
                    u = b[z];
                    if (this.matchesSelector(D, u)) {
                        y.setDelegatedTarget(D);
                        s = true;
                        this.dispatch(u, k, f)
                    }
                    if (y.isStopped) {
                        return s
                    }
                }
            }
        }
        return s
    },
    matchesSelector: function() {
        var b = Element.prototype,
        a = ("webkitMatchesSelector" in b) ? "webkitMatchesSelector": (("msMatchesSelector" in b) ? "msMatchesSelector": ("mozMatchesSelector" in b ? "mozMatchesSelector": null));
        if (a) {
            return function(e, d) {
                return e[a](d)
            }
        }
        return function(e, d) {
            Ext.DomQuery.is(e, d)
        }
    } (),
    onEvent: function(f) {
        var b = this.eventNameMap[f.type];
        Ext.frameStartTime = f.timeStamp;
        if (!b || this.getSubscribersCount(b) === 0) {
            return
        }
        var d = this.getElementTarget(f.target),
        a;
        if (!d) {
            return
        }
        if (this.doesEventBubble(b)) {
            a = this.getBubblingTargets(d)
        } else {
            a = [d]
        }
        this.publish(b, a, new Ext.event.Dom(f))
    },
    getSubscribersCount: function(a) {
        if (!this.handles(a)) {
            return 0
        }
        return this.getSubscribers(a).$length + this.getSubscribers("*").$length
    }
});
Ext.define("Ext.util.paintmonitor.Abstract", {
    config: {
        element: null,
        callback: Ext.emptyFn,
        scope: null,
        args: []
    },
    eventName: "",
    monitorClass: "",
    constructor: function(a) {
        this.onElementPainted = Ext.Function.bind(this.onElementPainted, this);
        this.initConfig(a)
    },
    bindListeners: function(a) {
        this.monitorElement[a ? "addEventListener": "removeEventListener"](this.eventName, this.onElementPainted, true)
    },
    applyElement: function(a) {
        if (a) {
            return Ext.get(a)
        }
    },
    updateElement: function(a) {
        this.monitorElement = Ext.Element.create({
            classList: ["x-paint-monitor", this.monitorClass]
        },
        true);
        a.appendChild(this.monitorElement);
        a.addCls("x-paint-monitored");
        this.bindListeners(true)
    },
    onElementPainted: function() {},
    destroy: function() {
        var b = this.monitorElement,
        a = b.parentNode,
        d = this.getElement();
        this.bindListeners(false);
        delete this.monitorElement;
        if (d && !d.isDestroyed) {
            d.removeCls("x-paint-monitored");
            delete this._element
        }
        if (a) {
            a.removeChild(b)
        }
        this.callSuper()
    }
});
Ext.define("Ext.util.paintmonitor.CssAnimation", {
    extend: Ext.util.paintmonitor.Abstract,
    eventName: Ext.browser.is.WebKit ? "webkitAnimationEnd": "animationend",
    monitorClass: "cssanimation",
    onElementPainted: function(a) {
        if (a.animationName === "x-paint-monitor-helper") {
            this.getCallback().apply(this.getScope(), this.getArgs())
        }
    }
});
Ext.define("Ext.util.paintmonitor.OverflowChange", {
    extend: Ext.util.paintmonitor.Abstract,
    eventName: Ext.browser.is.Firefox ? "overflow": "overflowchanged",
    monitorClass: "overflowchange",
    onElementPainted: function(a) {
        this.getCallback().apply(this.getScope(), this.getArgs())
    }
});
Ext.define("Ext.util.PaintMonitor", {
    constructor: function(a) {
        if (Ext.browser.is.Firefox || (Ext.browser.is.WebKit && Ext.browser.engineVersion.gtEq("536") && !Ext.os.is.Blackberry)) {
            return new Ext.util.paintmonitor.OverflowChange(a)
        } else {
            return new Ext.util.paintmonitor.CssAnimation(a)
        }
    }
});
Ext.define("Ext.event.publisher.ElementPaint", {
    extend: Ext.event.publisher.Publisher,
    targetType: "element",
    handledEvents: ["painted"],
    constructor: function() {
        this.monitors = {};
        this.callSuper(arguments)
    },
    subscribe: function(e) {
        var a = e.match(this.idSelectorRegex),
        d = this.subscribers,
        f,
        b;
        if (!a) {
            return false
        }
        f = a[1];
        if (d.hasOwnProperty(f)) {
            d[f]++;
            return true
        }
        d[f] = 1;
        b = Ext.get(f);
        this.monitors[f] = new Ext.util.PaintMonitor({
            element: b,
            callback: this.onElementPainted,
            scope: this,
            args: [e, b]
        });
        return true
    },
    unsubscribe: function(f, a, d) {
        var b = f.match(this.idSelectorRegex),
        e = this.subscribers,
        g;
        if (!b) {
            return false
        }
        g = b[1];
        if (!e.hasOwnProperty(g) || (!d && --e[g] > 0)) {
            return true
        }
        delete e[g];
        this.monitors[g].destroy();
        delete this.monitors[g];
        return true
    },
    onElementPainted: function(b, a) {
        Ext.TaskQueue.requestRead("dispatch", this, [b, "painted", [a]])
    }
});
Ext.define("Ext.mixin.Templatable", {
    extend: Ext.mixin.Mixin,
    mixinConfig: {
        id: "templatable"
    },
    referenceAttributeName: "reference",
    referenceSelector: "[reference]",
    getElementConfig: function() {
        return {
            reference: "element"
        }
    },
    getElementTemplate: function() {
        var a = document.createDocumentFragment();
        a.appendChild(Ext.Element.create(this.getElementConfig(), true));
        return a
    },
    initElement: function() {
        var a = this.self.prototype;
        a.elementTemplate = this.getElementTemplate();
        a.initElement = a.doInitElement;
        this.initElement.apply(this, arguments)
    },
    linkElement: function(a, b) {
        this.link(a, b)
    },
    doInitElement: function() {
        var h = this.referenceAttributeName,
        d, e, f, g, b, a;
        d = this.elementTemplate.cloneNode(true);
        e = d.querySelectorAll(this.referenceSelector);
        for (f = 0, g = e.length; f < g; f++) {
            b = e[f];
            a = b.getAttribute(h);
            b.removeAttribute(h);
            this.linkElement(a, b)
        }
    }
});
Ext.define("Ext.util.sizemonitor.Abstract", {
    mixins: [Ext.mixin.Templatable],
    config: {
        element: null,
        callback: Ext.emptyFn,
        scope: null,
        args: []
    },
    width: 0,
    height: 0,
    contentWidth: 0,
    contentHeight: 0,
    constructor: function(a) {
        this.refresh = Ext.Function.bind(this.refresh, this);
        this.info = {
            width: 0,
            height: 0,
            contentWidth: 0,
            contentHeight: 0,
            flag: 0
        };
        this.initElement();
        this.initConfig(a);
        this.bindListeners(true)
    },
    bindListeners: Ext.emptyFn,
    applyElement: function(a) {
        if (a) {
            return Ext.get(a)
        }
    },
    updateElement: function(a) {
        a.append(this.detectorsContainer);
        a.addCls("x-size-monitored")
    },
    applyArgs: function(a) {
        return a.concat([this.info])
    },
    refreshMonitors: Ext.emptyFn,
    forceRefresh: function() {
        Ext.TaskQueue.requestRead("refresh", this)
    },
    getContentBounds: function() {
        return this.detectorsContainer.getBoundingClientRect()
    },
    getContentWidth: function() {
        return this.detectorsContainer.offsetWidth
    },
    getContentHeight: function() {
        return this.detectorsContainer.offsetHeight
    },
    refreshSize: function() {
        var e = this.getElement();
        if (!e || e.isDestroyed) {
            return false
        }
        var b = e.getWidth(),
        k = e.getHeight(),
        a = this.getContentWidth(),
        j = this.getContentHeight(),
        i = this.contentWidth,
        g = this.contentHeight,
        d = this.info,
        f = false,
        h;
        this.width = b;
        this.height = k;
        this.contentWidth = a;
        this.contentHeight = j;
        h = ((i !== a ? 1 : 0) + (g !== j ? 2 : 0));
        if (h > 0) {
            d.width = b;
            d.height = k;
            d.contentWidth = a;
            d.contentHeight = j;
            d.flag = h;
            f = true;
            this.getCallback().apply(this.getScope(), this.getArgs())
        }
        return f
    },
    refresh: function(a) {
        if (this.refreshSize() || a) {
            Ext.TaskQueue.requestWrite("refreshMonitors", this)
        }
    },
    destroy: function() {
        var a = this.getElement();
        this.bindListeners(false);
        if (a && !a.isDestroyed) {
            a.removeCls("x-size-monitored")
        }
        delete this._element;
        this.callSuper()
    }
});
Ext.define("Ext.util.sizemonitor.Default", {
    extend: Ext.util.sizemonitor.Abstract,
    updateElement: function(a) {},
    bindListeners: function(b) {
        var a = this.getElement().dom;
        if (!a) {
            return
        }
        if (b) {
            a.onresize = this.refresh
        } else {
            delete a.onresize
        }
    },
    getContentBounds: function() {
        return this.getElement().dom.getBoundingClientRect()
    },
    getContentWidth: function() {
        return this.getElement().getWidth()
    },
    getContentHeight: function() {
        return this.getElement().getHeight()
    }
});
Ext.define("Ext.util.sizemonitor.Scroll", {
    extend: Ext.util.sizemonitor.Abstract,
    getElementConfig: function() {
        return {
            reference: "detectorsContainer",
            classList: ["x-size-monitors", "scroll"],
            children: [{
                reference: "expandMonitor",
                className: "expand"
            },
            {
                reference: "shrinkMonitor",
                className: "shrink"
            }]
        }
    },
    constructor: function(a) {
        this.onScroll = Ext.Function.bind(this.onScroll, this);
        this.callSuper(arguments)
    },
    bindListeners: function(b) {
        var a = b ? "addEventListener": "removeEventListener";
        this.expandMonitor[a]("scroll", this.onScroll, true);
        this.shrinkMonitor[a]("scroll", this.onScroll, true)
    },
    forceRefresh: function() {
        Ext.TaskQueue.requestRead("refresh", this, [true])
    },
    onScroll: function() {
        Ext.TaskQueue.requestRead("refresh", this)
    },
    refreshMonitors: function() {
        var b = this.expandMonitor,
        d = this.shrinkMonitor,
        a = 1000000;
        if (b && !b.isDestroyed) {
            b.scrollLeft = a;
            b.scrollTop = a
        }
        if (d && !d.isDestroyed) {
            d.scrollLeft = a;
            d.scrollTop = a
        }
    }
});
Ext.define("Ext.util.sizemonitor.OverflowChange", {
    extend: Ext.util.sizemonitor.Abstract,
    constructor: function(a) {
        this.onExpand = Ext.Function.bind(this.onExpand, this);
        this.onShrink = Ext.Function.bind(this.onShrink, this);
        this.callSuper(arguments)
    },
    getElementConfig: function() {
        return {
            reference: "detectorsContainer",
            classList: ["x-size-monitors", "overflowchanged"],
            children: [{
                reference: "expandMonitor",
                className: "expand",
                children: [{
                    reference: "expandHelper"
                }]
            },
            {
                reference: "shrinkMonitor",
                className: "shrink",
                children: [{
                    reference: "shrinkHelper"
                }]
            }]
        }
    },
    bindListeners: function(b) {
        var a = b ? "addEventListener": "removeEventListener";
        this.expandMonitor[a](Ext.browser.is.Firefox ? "underflow": "overflowchanged", this.onExpand, true);
        this.shrinkMonitor[a](Ext.browser.is.Firefox ? "overflow": "overflowchanged", this.onShrink, true)
    },
    onExpand: function(a) {
        if (Ext.browser.is.Webkit && a.horizontalOverflow && a.verticalOverflow) {
            return
        }
        Ext.TaskQueue.requestRead("refresh", this)
    },
    onShrink: function(a) {
        if (Ext.browser.is.Webkit && !a.horizontalOverflow && !a.verticalOverflow) {
            return
        }
        Ext.TaskQueue.requestRead("refresh", this)
    },
    refreshMonitors: function() {
        if (this.isDestroyed) {
            return
        }
        var g = this.expandHelper,
        f = this.shrinkHelper,
        b = this.getContentBounds(),
        e = b.width,
        a = b.height,
        d;
        if (g && !g.isDestroyed) {
            d = g.style;
            d.width = (e + 1) + "px";
            d.height = (a + 1) + "px"
        }
        if (f && !f.isDestroyed) {
            d = f.style;
            d.width = e + "px";
            d.height = a + "px"
        }
        Ext.TaskQueue.requestRead("refresh", this)
    }
});
Ext.define("Ext.util.SizeMonitor", {
    constructor: function(a) {
        var b = Ext.util.sizemonitor;
        if (Ext.browser.is.Firefox) {
            return new b.OverflowChange(a)
        } else {
            if (Ext.browser.is.WebKit) {
                if (!Ext.browser.is.Silk && Ext.browser.engineVersion.gtEq("535")) {
                    return new b.OverflowChange(a)
                } else {
                    return new b.Scroll(a)
                }
            } else {
                if (Ext.browser.is.IE11) {
                    return new b.Scroll(a)
                } else {
                    return new b.Default(a)
                }
            }
        }
    }
});
Ext.define("Ext.event.publisher.ElementSize", {
    extend: Ext.event.publisher.Publisher,
    targetType: "element",
    handledEvents: ["resize"],
    constructor: function() {
        this.monitors = {};
        this.callSuper(arguments)
    },
    subscribe: function(f) {
        var b = f.match(this.idSelectorRegex),
        e = this.subscribers,
        g,
        d,
        a;
        if (!b) {
            return false
        }
        g = b[1];
        if (e.hasOwnProperty(g)) {
            e[g]++;
            return true
        }
        e[g] = 1;
        d = Ext.get(g);
        this.monitors[g] = a = new Ext.util.SizeMonitor({
            element: d,
            callback: this.onElementResize,
            scope: this,
            args: [f, d]
        });
        this.dispatcher.addListener("element", f, "painted", "forceRefresh", a);
        return true
    },
    unsubscribe: function(h, a, f) {
        var d = h.match(this.idSelectorRegex),
        g = this.subscribers,
        e = this.monitors,
        i,
        b;
        if (!d) {
            return false
        }
        i = d[1];
        if (!g.hasOwnProperty(i) || (!f && --g[i] > 0)) {
            return true
        }
        delete g[i];
        b = e[i];
        this.dispatcher.removeListener("element", h, "painted", "forceRefresh", b);
        b.destroy();
        delete e[i];
        return true
    },
    onElementResize: function(d, a, b) {
        Ext.TaskQueue.requestRead("dispatch", this, [d, "resize", [a, b]])
    }
});
Ext.define("Ext.event.publisher.TouchGesture", {
    extend: Ext.event.publisher.Dom,
    isNotPreventable: /^(select|a)$/i,
    handledEvents: ["touchstart", "touchmove", "touchend", "touchcancel"],
    mouseToTouchMap: {
        mousedown: "touchstart",
        mousemove: "touchmove",
        mouseup: "touchend"
    },
    lastEventType: null,
    config: {
        moveThrottle: 0,
        recognizers: {}
    },
    constructor: function(a) {
        this.eventProcessors = {
            touchstart: this.onTouchStart,
            touchmove: this.onTouchMove,
            touchend: this.onTouchEnd,
            touchcancel: this.onTouchEnd
        };
        this.eventToRecognizerMap = {};
        this.activeRecognizers = [];
        this.touchesMap = {};
        this.currentIdentifiers = [];
        if (Ext.browser.is.Chrome && Ext.os.is.Android) {
            this.screenPositionRatio = Ext.browser.version.gt("18") ? 1 : 1 / window.devicePixelRatio
        } else {
            if (Ext.browser.is.AndroidStock4) {
                this.screenPositionRatio = 1
            } else {
                if (Ext.os.is.BlackBerry) {
                    this.screenPositionRatio = 1 / window.devicePixelRatio
                } else {
                    if (Ext.browser.engineName == "WebKit" && Ext.os.is.Desktop) {
                        this.screenPositionRatio = 1
                    } else {
                        this.screenPositionRatio = window.innerWidth / window.screen.width
                    }
                }
            }
        }
        this.initConfig(a);
        return this.callSuper()
    },
    applyRecognizers: function(b) {
        var d, a;
        for (d in b) {
            if (b.hasOwnProperty(d)) {
                a = b[d];
                if (a) {
                    this.registerRecognizer(a)
                }
            }
        }
        return b
    },
    handles: function(a) {
        return this.callSuper(arguments) || this.eventToRecognizerMap.hasOwnProperty(a)
    },
    doesEventBubble: function() {
        return true
    },
    onEvent: function(g) {
        var f = g.type,
        b = this.lastEventType,
        d = [g];
        if (this.eventProcessors[f]) {
            this.eventProcessors[f].call(this, g);
            return
        }
        if ("button" in g && g.button > 0) {
            return
        } else {
            if (f === "mousedown" && b && b !== "mouseup") {
                var a = document.createEvent("MouseEvent");
                a.initMouseEvent("mouseup", g.bubbles, g.cancelable, document.defaultView, g.detail, g.screenX, g.screenY, g.clientX, g.clientY, g.ctrlKey, g.altKey, g.shiftKey, g.metaKey, g.metaKey, g.button, g.relatedTarget);
                this.onEvent(a)
            }
            if (f !== "mousemove") {
                this.lastEventType = f
            }
            g.identifier = 1;
            g.touches = (f !== "mouseup") ? d: [];
            g.targetTouches = (f !== "mouseup") ? d: [];
            g.changedTouches = d;
            this.eventProcessors[this.mouseToTouchMap[f]].call(this, g)
        }
    },
    registerRecognizer: function(a) {
        var h = this.eventToRecognizerMap,
        f = this.activeRecognizers,
        d = a.getHandledEvents(),
        e,
        g,
        b;
        a.setOnRecognized(this.onRecognized);
        a.setCallbackScope(this);
        for (e = 0, g = d.length; e < g; e++) {
            b = d[e];
            h[b] = a
        }
        f.push(a);
        return this
    },
    onRecognized: function(g, j, f, a) {
        var m = [],
        k = f.length,
        h,
        d,
        b;
        if (k === 1) {
            return this.publish(g, f[0].targets, j, a)
        }
        for (d = 0; d < k; d++) {
            b = f[d];
            m.push(b.targets)
        }
        h = this.getCommonTargets(m);
        this.publish(g, h, j, a)
    },
    publish: function(b, a, d, e) {
        d.set(e);
        return this.callSuper([b, a, d])
    },
    getCommonTargets: function(a) {
        var k = a[0],
        g = a.length;
        if (g === 1) {
            return k
        }
        var e = [],
        f = 1,
        h,
        b,
        d;
        while (true) {
            h = k[k.length - f];
            if (!h) {
                return e
            }
            for (d = 1; d < g; d++) {
                b = a[d];
                if (b[b.length - f] !== h) {
                    return e
                }
            }
            e.unshift(h);
            f++
        }
        return e
    },
    invokeRecognizers: function(d, h) {
        var b = this.activeRecognizers,
        g = b.length,
        f, a;
        if (d === "onStart") {
            for (f = 0; f < g; f++) {
                b[f].isActive = true
            }
        }
        for (f = 0; f < g; f++) {
            a = b[f];
            if (a.isActive && a[d].call(a, h) === false) {
                a.isActive = false
            }
        }
    },
    getActiveRecognizers: function() {
        return this.activeRecognizers
    },
    updateTouch: function(g) {
        var b = g.identifier,
        e = this.touchesMap[b],
        d,
        a,
        f;
        if (!e) {
            d = this.getElementTarget(g.target);
            this.touchesMap[b] = e = {
                identifier: b,
                target: d,
                targets: this.getBubblingTargets(d)
            };
            this.currentIdentifiers.push(b)
        }
        a = g.pageX;
        f = g.pageY;
        if (a === e.pageX && f === e.pageY) {
            return false
        }
        e.pageX = a;
        e.pageY = f;
        e.timeStamp = g.timeStamp;
        e.point = new Ext.util.Point(a, f);
        return e
    },
    updateTouches: function(e) {
        var a, d, f, b = [];
        for (a = 0, d = e.length; a < d; a++) {
            f = this.updateTouch(e[a]);
            if (f) {
                b.push(f)
            }
        }
        return b
    },
    factoryEvent: function(a) {
        return new Ext.event.Touch(a, null, this.touchesMap, this.currentIdentifiers)
    },
    onTouchStart: function(j) {
        var f = j.changedTouches,
        h = j.target,
        g = f.length,
        a = this.isNotPreventable,
        b, k, d;
        this.updateTouches(f);
        j = this.factoryEvent(j);
        f = j.changedTouches;
        for (b = 0; b < g; b++) {
            k = f[b];
            this.publish("touchstart", k.targets, j, {
                touch: k
            })
        }
        if (!this.isStarted) {
            this.isStarted = true;
            this.invokeRecognizers("onStart", j)
        }
        this.invokeRecognizers("onTouchStart", j);
        d = h.parentNode || {}
    },
    onTouchMove: function(a) {
        if (!this.isStarted) {
            return
        }
        if (!this.animationQueued) {
            this.animationQueued = true;
            Ext.AnimationQueue.start("onAnimationFrame", this)
        }
        this.lastMoveEvent = a
    },
    onAnimationFrame: function() {
        var a = this.lastMoveEvent;
        if (a) {
            this.lastMoveEvent = null;
            this.doTouchMove(a)
        }
    },
    doTouchMove: function(f) {
        var b, a, d, g;
        b = this.updateTouches(f.changedTouches);
        d = b.length;
        f = this.factoryEvent(f);
        for (a = 0; a < d; a++) {
            g = b[a];
            this.publish("touchmove", g.targets, f, {
                touch: g
            })
        }
        if (d > 0) {
            this.invokeRecognizers("onTouchMove", f)
        }
    },
    onTouchEnd: function(j) {
        if (!this.isStarted) {
            return
        }
        if (this.lastMoveEvent) {
            this.onAnimationFrame()
        }
        var a = this.touchesMap,
        f = this.currentIdentifiers,
        g = j.changedTouches,
        h = g.length,
        b, d, k;
        this.updateTouches(g);
        g = j.changedTouches;
        for (d = 0; d < h; d++) {
            Ext.Array.remove(f, g[d].identifier)
        }
        j = this.factoryEvent(j);
        for (d = 0; d < h; d++) {
            b = g[d].identifier;
            k = a[b];
            delete a[b];
            this.publish("touchend", k.targets, j, {
                touch: k
            })
        }
        this.invokeRecognizers("onTouchEnd", j);
        if (j.touches.length === 1 && f.length) {
            f.length = 0;
            this.touchesMap = {}
        }
        if (f.length === 0) {
            this.isStarted = false;
            this.invokeRecognizers("onEnd", j);
            if (this.animationQueued) {
                this.animationQueued = false;
                Ext.AnimationQueue.stop("onAnimationFrame", this)
            }
        }
    }
},
function() {
    if (Ext.feature.has.Pointer) {
        this.override({
            pointerToTouchMap: {
                MSPointerDown: "touchstart",
                MSPointerMove: "touchmove",
                MSPointerUp: "touchend",
                MSPointerCancel: "touchcancel",
                pointerdown: "touchstart",
                pointermove: "touchmove",
                pointerup: "touchend",
                pointercancel: "touchcancel"
            },
            touchToPointerMap: {
                touchstart: "MSPointerDown",
                touchmove: "MSPointerMove",
                touchend: "MSPointerUp",
                touchcancel: "MSPointerCancel"
            },
            attachListener: function(a, b) {
                a = this.touchToPointerMap[a];
                if (!a) {
                    return
                }
                return this.callOverridden([a, b])
            },
            onEvent: function(b) {
                if ("button" in b && b.button > 0) {
                    return
                }
                var a = this.pointerToTouchMap[b.type];
                b.identifier = b.pointerId;
                b.changedTouches = [b];
                this.eventProcessors[a].call(this, b)
            }
        })
    } else {
        if (!Ext.browser.is.Ripple && (Ext.os.is.ChromeOS || !Ext.feature.has.Touch)) {
            this.override({
                handledEvents: ["touchstart", "touchmove", "touchend", "touchcancel", "mousedown", "mousemove", "mouseup"]
            })
        }
    }
});
Ext.define("Ext.event.recognizer.Recognizer", {
    mixins: [Ext.mixin.Identifiable],
    handledEvents: [],
    config: {
        onRecognized: Ext.emptyFn,
        onFailed: Ext.emptyFn,
        callbackScope: null
    },
    constructor: function(a) {
        this.initConfig(a);
        return this
    },
    getHandledEvents: function() {
        return this.handledEvents
    },
    onStart: Ext.emptyFn,
    onEnd: Ext.emptyFn,
    fail: function() {
        this.getOnFailed().apply(this.getCallbackScope(), arguments);
        return false
    },
    fire: function() {
        this.getOnRecognized().apply(this.getCallbackScope(), arguments)
    }
});
Ext.define("Ext.event.recognizer.Touch", {
    extend: Ext.event.recognizer.Recognizer,
    onTouchStart: Ext.emptyFn,
    onTouchMove: Ext.emptyFn,
    onTouchEnd: Ext.emptyFn
});
Ext.define("Ext.event.recognizer.SingleTouch", {
    extend: Ext.event.recognizer.Touch,
    inheritableStatics: {
        NOT_SINGLE_TOUCH: 1,
        TOUCH_MOVED: 2
    },
    onTouchStart: function(a) {
        if (a.touches.length > 1) {
            return this.fail(this.self.NOT_SINGLE_TOUCH)
        }
    }
});
Ext.define("Ext.event.recognizer.DoubleTap", {
    extend: Ext.event.recognizer.SingleTouch,
    inheritableStatics: {
        DIFFERENT_TARGET: 3
    },
    config: {
        maxDuration: 300
    },
    handledEvents: ["singletap", "doubletap"],
    singleTapTimer: null,
    startTime: 0,
    lastTapTime: 0,
    onTouchStart: function(a) {
        if (this.callParent(arguments) === false) {
            return false
        }
        this.startTime = a.time;
        clearTimeout(this.singleTapTimer)
    },
    onTouchMove: function() {
        return this.fail(this.self.TOUCH_MOVED)
    },
    onEnd: function(h) {
        var j = this,
        f = this.getMaxDuration(),
        g = h.changedTouches[0],
        a = h.time,
        i = h.target,
        k = this.lastTapTime,
        b = this.lastTarget,
        d;
        this.lastTapTime = a;
        this.lastTarget = i;
        if (k) {
            d = a - k;
            if (d <= f) {
                if (i !== b) {
                    return this.fail(this.self.DIFFERENT_TARGET)
                }
                this.lastTarget = null;
                this.lastTapTime = 0;
                this.fire("doubletap", h, [g], {
                    touch: g,
                    duration: d
                });
                return
            }
        }
        if (a - this.startTime > f) {
            this.fireSingleTap(h, g)
        } else {
            this.singleTapTimer = setTimeout(function() {
                j.fireSingleTap(h, g)
            },
            f)
        }
    },
    fireSingleTap: function(a, b) {
        this.fire("singletap", a, [b], {
            touch: b
        })
    }
});
Ext.define("Ext.event.recognizer.Drag", {
    extend: Ext.event.recognizer.SingleTouch,
    isStarted: false,
    startPoint: null,
    previousPoint: null,
    lastPoint: null,
    handledEvents: ["dragstart", "drag", "dragend"],
    config: {
        minDistance: 8
    },
    constructor: function() {
        this.callSuper(arguments);
        this.info = {
            touch: null,
            previous: {
                x: 0,
                y: 0
            },
            x: 0,
            y: 0,
            delta: {
                x: 0,
                y: 0
            },
            absDelta: {
                x: 0,
                y: 0
            },
            flick: {
                velocity: {
                    x: 0,
                    y: 0
                }
            },
            direction: {
                x: 0,
                y: 0
            },
            time: 0,
            previousTime: {
                x: 0,
                y: 0
            }
        }
    },
    onTouchStart: function(a) {
        if (this.callSuper(arguments) === false) {
            if (this.isStarted && this.lastMoveEvent !== null) {
                this.lastMoveEvent.isStopped = false;
                this.onTouchEnd(this.lastMoveEvent)
            }
            return false
        }
        this.startTime = a.time;
        this.startPoint = a.changedTouches[0].point
    },
    tryDragStart: function(g) {
        var b = this.startPoint,
        f = g.changedTouches,
        i = f[0],
        a = i.point,
        h = this.getMinDistance(),
        d = this.info;
        if (Math.abs(a.getDistanceTo(b)) >= h) {
            this.isStarted = true;
            this.previousPoint = this.lastPoint = a;
            this.resetInfo("x", g, i);
            this.resetInfo("y", g, i);
            d.time = g.time;
            this.fire("dragstart", g, f, d)
        }
    },
    onTouchMove: function(d) {
        if (!this.isStarted) {
            this.tryDragStart(d)
        }
        if (!this.isStarted) {
            return
        }
        var b = d.changedTouches,
        f = b[0],
        a = f.point;
        if (this.lastPoint) {
            this.previousPoint = this.lastPoint
        }
        this.lastPoint = a;
        this.lastMoveEvent = d;
        this.updateInfo("x", d, f, true);
        this.updateInfo("y", d, f, true);
        this.info.time = d.time;
        this.fire("drag", d, b, this.info)
    },
    onAxisDragEnd: function(a, d) {
        var b = d.time - d.previousTime[a];
        if (b > 0) {
            d.flick.velocity[a] = (d[a] - d.previous[a]) / b
        }
    },
    resetInfo: function(d, h, j) {
        var f = this.lastPoint[d],
        b = this.startPoint[d],
        i = f - b,
        a = d.toUpperCase(),
        g = this.info;
        g.touch = j;
        g.delta[d] = i;
        g.absDelta[d] = Math.abs(i);
        g.previousTime[d] = this.startTime;
        g.previous[d] = b;
        g[d] = f;
        g.direction[d] = 0;
        g["start" + a] = this.startPoint[d];
        g["previous" + a] = g.previous[d];
        g["page" + a] = g[d];
        g["delta" + a] = g.delta[d];
        g["absDelta" + a] = g.absDelta[d];
        g["previousDelta" + a] = 0;
        g.startTime = this.startTime
    },
    updateInfo: function(g, m, k, n) {
        var f = m.time,
        p = this.lastPoint[g],
        h = this.previousPoint[g],
        a = this.startPoint[g],
        q = p - a,
        d = this.info,
        o = d.direction,
        j = g.toUpperCase(),
        b = d.previous[g],
        i;
        d.touch = k;
        i = d.delta[g];
        d.delta[g] = q;
        d.absDelta[g] = Math.abs(q);
        if (n && p !== b && p !== d[g] && f - d.previousTime[g] >= 50) {
            d.previous[g] = d[g];
            d.previousTime[g] = d.time
        }
        d[g] = p;
        if (p > h) {
            o[g] = 1
        } else {
            if (p < h) {
                o[g] = -1
            }
        }
        d["start" + j] = this.startPoint[g];
        d["previous" + j] = d.previous[g];
        d["page" + j] = d[g];
        d["delta" + j] = d.delta[g];
        d["absDelta" + j] = d.absDelta[g];
        d["previousDelta" + j] = i;
        d.startTime = this.startTime
    },
    onTouchEnd: function(f) {
        if (!this.isStarted) {
            this.tryDragStart(f)
        }
        if (this.isStarted) {
            var d = f.changedTouches,
            g = d[0],
            a = g.point,
            b = this.info;
            this.isStarted = false;
            this.lastPoint = a;
            this.updateInfo("x", f, g);
            this.updateInfo("y", f, g);
            b.time = f.time;
            this.onAxisDragEnd("x", b);
            this.onAxisDragEnd("y", b);
            this.fire("dragend", f, d, b);
            this.startPoint = null;
            this.previousPoint = null;
            this.lastPoint = null;
            this.lastMoveEvent = null
        }
    }
});
Ext.define("Ext.event.recognizer.Swipe", {
    extend: Ext.event.recognizer.SingleTouch,
    handledEvents: ["swipestart", "swipe"],
    inheritableStatics: {
        MAX_OFFSET_EXCEEDED: 16,
        MAX_DURATION_EXCEEDED: 17,
        DISTANCE_NOT_ENOUGH: 18
    },
    config: {
        minDistance: 80,
        maxOffset: 35,
        maxDuration: 1000
    },
    onTouchStart: function(a) {
        if (this.callParent(arguments) === false) {
            return false
        }
        var b = a.changedTouches[0];
        this.startTime = a.time;
        this.isHorizontal = true;
        this.isVertical = true;
        this.startX = b.pageX;
        this.startY = b.pageY
    },
    onTouchMove: function(k) {
        var j = k.changedTouches[0],
        o = j.pageX,
        m = j.pageY,
        i = o - this.startX,
        h = m - this.startY,
        f = Math.abs(o - this.startX),
        d = Math.abs(m - this.startY),
        g = k.time - this.startTime,
        p = this.getMinDistance(),
        b = k.time,
        n,
        a;
        if (b - this.startTime > this.getMaxDuration()) {
            return this.fail(this.self.MAX_DURATION_EXCEEDED)
        }
        if (this.isHorizontal && d > this.getMaxOffset()) {
            this.isHorizontal = false
        }
        if (this.isVertical && f > this.getMaxOffset()) {
            this.isVertical = false
        }
        if (!this.isVertical || !this.isHorizontal) {
            if (this.isHorizontal && f < p) {
                n = (i < 0) ? "left": "right";
                a = f
            } else {
                if (this.isVertical && d < p) {
                    n = (h < 0) ? "up": "down";
                    a = d
                }
            }
        }
        if (n && !this.started) {
            this.started = true;
            this.fire("swipestart", k, [j], {
                touch: j,
                direction: n,
                distance: a,
                duration: g
            })
        }
        if (!this.isHorizontal && !this.isVertical) {
            return this.fail(this.self.MAX_OFFSET_EXCEEDED)
        }
    },
    onTouchEnd: function(j) {
        if (this.onTouchMove(j) === false) {
            return false
        }
        var i = j.changedTouches[0],
        n = i.pageX,
        k = i.pageY,
        h = n - this.startX,
        g = k - this.startY,
        d = Math.abs(h),
        b = Math.abs(g),
        o = this.getMinDistance(),
        f = j.time - this.startTime,
        m,
        a;
        if (this.isVertical && b < o) {
            this.isVertical = false
        }
        if (this.isHorizontal && d < o) {
            this.isHorizontal = false
        }
        if (this.isHorizontal) {
            m = (h < 0) ? "left": "right";
            a = d
        } else {
            if (this.isVertical) {
                m = (g < 0) ? "up": "down";
                a = b
            } else {
                return this.fail(this.self.DISTANCE_NOT_ENOUGH)
            }
        }
        this.started = false;
        this.fire("swipe", j, [i], {
            touch: i,
            direction: m,
            distance: a,
            duration: f
        })
    }
});
Ext.define("Ext.event.recognizer.EdgeSwipe", {
    extend: Ext.event.recognizer.Swipe,
    handledEvents: ["edgeswipe", "edgeswipestart", "edgeswipeend"],
    inheritableStatics: {
        NOT_NEAR_EDGE: 19
    },
    config: {
        minDistance: 60
    },
    onTouchStart: function(a) {
        if (this.callParent(arguments) === false) {
            return false
        }
        var b = a.changedTouches[0];
        this.started = false;
        this.direction = null;
        this.isHorizontal = true;
        this.isVertical = true;
        this.startX = b.pageX;
        this.startY = b.pageY
    },
    onTouchMove: function(m) {
        var j = m.changedTouches[0],
        q = j.pageX,
        n = j.pageY,
        i = q - this.startX,
        h = n - this.startY,
        b = Math.abs(n - this.startY),
        d = Math.abs(q - this.startX),
        r = this.getMinDistance(),
        g = this.getMaxOffset(),
        f = m.time - this.startTime,
        p = Ext.Viewport && Ext.Viewport.element.getWidth(),
        k = Ext.Viewport && Ext.Viewport.element.getHeight(),
        o,
        a;
        if (this.isVertical && d > g) {
            this.isVertical = false
        }
        if (this.isHorizontal && b > g) {
            this.isHorizontal = false
        }
        if (this.isVertical && this.isHorizontal) {
            if (b > d) {
                this.isHorizontal = false
            } else {
                this.isVertical = false
            }
        }
        if (this.isHorizontal) {
            o = (i < 0) ? "left": "right";
            a = i
        } else {
            if (this.isVertical) {
                o = (h < 0) ? "up": "down";
                a = h
            }
        }
        this.direction = this.direction || o;
        if (this.direction == "up") {
            a = h * -1
        } else {
            if (this.direction == "left") {
                a = i * -1
            }
        }
        this.distance = a;
        if (a == 0) {
            return this.fail(this.self.DISTANCE_NOT_ENOUGH)
        }
        if (!this.started) {
            if (this.direction == "right" && this.startX > r) {
                return this.fail(this.self.NOT_NEAR_EDGE)
            } else {
                if (this.direction == "down" && this.startY > r) {
                    return this.fail(this.self.NOT_NEAR_EDGE)
                } else {
                    if (this.direction == "left" && (p - this.startX) > r) {
                        return this.fail(this.self.NOT_NEAR_EDGE)
                    } else {
                        if (this.direction == "up" && (k - this.startY) > r) {
                            return this.fail(this.self.NOT_NEAR_EDGE)
                        }
                    }
                }
            }
            this.started = true;
            this.startTime = m.time;
            this.fire("edgeswipestart", m, [j], {
                touch: j,
                direction: this.direction,
                distance: this.distance,
                duration: f
            })
        } else {
            this.fire("edgeswipe", m, [j], {
                touch: j,
                direction: this.direction,
                distance: this.distance,
                duration: f
            })
        }
    },
    onTouchEnd: function(b) {
        if (this.onTouchMove(b) !== false) {
            var d = b.changedTouches[0],
            a = b.time - this.startTime;
            this.fire("edgeswipeend", b, [d], {
                touch: d,
                direction: this.direction,
                distance: this.distance,
                duration: a
            })
        }
    }
});
Ext.define("Ext.event.recognizer.LongPress", {
    extend: Ext.event.recognizer.SingleTouch,
    inheritableStatics: {
        DURATION_NOT_ENOUGH: 32
    },
    config: {
        minDuration: 1000
    },
    handledEvents: ["longpress"],
    fireLongPress: function(a) {
        var b = a.changedTouches[0];
        this.fire("longpress", a, [b], {
            touch: b,
            duration: this.getMinDuration()
        });
        this.isLongPress = true
    },
    onTouchStart: function(b) {
        var a = this;
        if (this.callParent(arguments) === false) {
            return false
        }
        this.isLongPress = false;
        this.timer = setTimeout(function() {
            a.fireLongPress(b)
        },
        this.getMinDuration())
    },
    onTouchMove: function() {
        return this.fail(this.self.TOUCH_MOVED)
    },
    onTouchEnd: function() {
        if (!this.isLongPress) {
            return this.fail(this.self.DURATION_NOT_ENOUGH)
        }
    },
    fail: function() {
        clearTimeout(this.timer);
        return this.callParent(arguments)
    }
},
function() {
    this.override({
        handledEvents: ["longpress", "taphold"],
        fire: function(a) {
            if (a === "longpress") {
                var b = Array.prototype.slice.call(arguments);
                b[0] = "taphold";
                this.fire.apply(this, b)
            }
            return this.callOverridden(arguments)
        }
    })
});
Ext.define("Ext.event.recognizer.MultiTouch", {
    extend: Ext.event.recognizer.Touch,
    requiredTouchesCount: 2,
    isTracking: false,
    isStarted: false,
    onTouchStart: function(f) {
        var a = this.requiredTouchesCount,
        d = f.touches,
        b = d.length;
        if (b === a) {
            this.start(f)
        } else {
            if (b > a) {
                this.end(f)
            }
        }
    },
    onTouchEnd: function(a) {
        this.end(a)
    },
    start: function() {
        if (!this.isTracking) {
            this.isTracking = true;
            this.isStarted = false
        }
    },
    end: function(a) {
        if (this.isTracking) {
            this.isTracking = false;
            if (this.isStarted) {
                this.isStarted = false;
                this.fireEnd(a)
            }
        }
    }
});
Ext.define("Ext.event.recognizer.Pinch", {
    extend: Ext.event.recognizer.MultiTouch,
    requiredTouchesCount: 2,
    handledEvents: ["pinchstart", "pinch", "pinchend"],
    startDistance: 0,
    lastTouches: null,
    onTouchMove: function(d) {
        if (!this.isTracking) {
            return
        }
        var b = Array.prototype.slice.call(d.touches),
        f,
        a,
        g;
        f = b[0].point;
        a = b[1].point;
        g = f.getDistanceTo(a);
        if (g === 0) {
            return
        }
        if (!this.isStarted) {
            this.isStarted = true;
            this.startDistance = g;
            this.fire("pinchstart", d, b, {
                touches: b,
                distance: g,
                scale: 1
            })
        } else {
            this.fire("pinch", d, b, {
                touches: b,
                distance: g,
                scale: g / this.startDistance
            })
        }
        this.lastTouches = b
    },
    fireEnd: function(a) {
        this.fire("pinchend", a, this.lastTouches)
    },
    fail: function() {
        return this.callParent(arguments)
    }
});
Ext.define("Ext.event.recognizer.Rotate", {
    extend: Ext.event.recognizer.MultiTouch,
    requiredTouchesCount: 2,
    handledEvents: ["rotatestart", "rotate", "rotateend"],
    startAngle: 0,
    lastTouches: null,
    lastAngle: null,
    onTouchMove: function(i) {
        if (!this.isTracking) {
            return
        }
        var h = Array.prototype.slice.call(i.touches),
        b = this.lastAngle,
        f,
        g,
        d,
        a,
        j,
        k;
        f = h[0].point;
        g = h[1].point;
        d = f.getAngleTo(g);
        if (b !== null) {
            k = Math.abs(b - d);
            a = d + 360;
            j = d - 360;
            if (Math.abs(a - b) < k) {
                d = a
            } else {
                if (Math.abs(j - b) < k) {
                    d = j
                }
            }
        }
        this.lastAngle = d;
        if (!this.isStarted) {
            this.isStarted = true;
            this.startAngle = d;
            this.fire("rotatestart", i, h, {
                touches: h,
                angle: d,
                rotation: 0
            })
        } else {
            this.fire("rotate", i, h, {
                touches: h,
                angle: d,
                rotation: d - this.startAngle
            })
        }
        this.lastTouches = h
    },
    fireEnd: function(a) {
        this.lastAngle = null;
        this.fire("rotateend", a, this.lastTouches)
    }
});
Ext.define("Ext.event.recognizer.Tap", {
    extend: Ext.event.recognizer.SingleTouch,
    handledEvents: ["tap", "tapcancel"],
    config: {
        moveDistance: 8
    },
    onTouchStart: function(a) {
        if (this.callSuper(arguments) === false) {
            return false
        }
        this.startPoint = a.changedTouches[0].point
    },
    onTouchMove: function(b) {
        var d = b.changedTouches[0],
        a = d.point;
        if (Math.abs(a.getDistanceTo(this.startPoint)) >= this.getMoveDistance()) {
            this.fire("tapcancel", b, [d], {
                touch: d
            });
            return this.fail(this.self.TOUCH_MOVED)
        }
    },
    onTouchEnd: function(a) {
        var b = a.changedTouches[0];
        this.fire("tap", a, [b], {
            touch: b
        })
    }
});
Ext.define("Ext.field.Checkbox", {
    extend: Ext.field.Field,
    alternateClassName: "Ext.form.Checkbox",
    xtype: "checkboxfield",
    qsaLeftRe: /[\[]/g,
    qsaRightRe: /[\]]/g,
    isCheckbox: true,
    config: {
        ui: "checkbox",
        value: "",
        checked: false,
        tabIndex: -1,
        component: {
            xtype: "input",
            type: "checkbox",
            useMask: true,
            cls: Ext.baseCSSPrefix + "input-checkbox"
        }
    },
    platformConfig: [{
        theme: ["Windows", "Blackberry", "Tizen"],
        labelAlign: "left"
    }],
    initialize: function() {
        var b = this,
        a = b.getComponent();
        b.callParent();
        a.on({
            scope: b,
            order: "before",
            masktap: "onMaskTap"
        });
        a.doMaskTap = Ext.emptyFn;
        b.label.on({
            scope: b,
            tap: "onMaskTap"
        })
    },
    doInitValue: function() {
        var a = this,
        b = a.getInitialConfig();
        if (b.hasOwnProperty("value")) {
            a.originalState = b.value
        }
        if (b.hasOwnProperty("checked")) {
            a.originalState = b.checked
        }
        a.callParent(arguments)
    },
    updateInputType: function(a) {
        var b = this.getComponent();
        if (b) {
            b.setType(a)
        }
    },
    updateName: function(a) {
        var b = this.getComponent();
        if (b) {
            b.setName(a)
        }
    },
    getChecked: function() {
        this._checked = this.getComponent().getChecked();
        return this._checked
    },
    getSubmitValue: function() {
        return (this.getChecked()) ? Ext.isEmpty(this._value) ? true: this._value: null
    },
    setChecked: function(a) {
        this.updateChecked(a);
        this._checked = a
    },
    updateChecked: function(a) {
        this.getComponent().setChecked(a);
        if (this.initialized) {
            this.onChange()
        }
    },
    onMaskTap: function(a, d) {
        var b = this,
        f = b.getComponent().input.dom;
        if (b.getDisabled()) {
            return false
        }
        f.checked = !f.checked;
        b.onChange(d);
        return false
    },
    onChange: function(f) {
        var d = this,
        b = d._checked,
        a = d.getChecked();
        if (b != a) {
            if (a) {
                d.fireEvent("check", d, f)
            } else {
                d.fireEvent("uncheck", d, f)
            }
            d.fireEvent("change", d, a, b)
        }
    },
    doChecked: Ext.emptyFn,
    doUnChecked: Ext.emptyFn,
    isChecked: function() {
        return this.getChecked()
    },
    check: function() {
        return this.setChecked(true)
    },
    uncheck: function() {
        return this.setChecked(false)
    },
    getSameGroupFields: function() {
        var m = this,
        n = m.up("formpanel") || m.up("fieldset"),
        b = m.getName(),
        j = m.qsaLeftRe,
        d = m.qsaRightRe,
        g = m.getBaseCls().split(" ").join("."),
        h = [],
        a,
        f,
        e,
        k;
        if (!n) {
            n = Ext.Viewport
        }
        b = b.replace(j, "\\[");
        b = b.replace(d, "\\]");
        a = Ext.query("[name=" + b + "]", n.element.dom);
        k = a.length;
        for (e = 0; e < k; e++) {
            f = a[e];
            f = Ext.fly(f).up("." + g);
            if (f && f.id) {
                h.push(Ext.getCmp(f.id))
            }
        }
        return h
    },
    getGroupValues: function() {
        var a = [];
        this.getSameGroupFields().forEach(function(b) {
            if (b.getChecked()) {
                a.push(b.getValue())
            }
        });
        return a
    },
    setGroupValues: function(a) {
        this.getSameGroupFields().forEach(function(b) {
            b.setChecked((a.indexOf(b.getValue()) !== -1))
        });
        return this
    },
    resetGroupValues: function() {
        this.getSameGroupFields().forEach(function(a) {
            a.setChecked(a.originalState)
        });
        return this
    },
    reset: function() {
        this.setChecked(this.originalState);
        return this
    }
});
Ext.define("Ext.slider.Thumb", {
    extend: Ext.Component,
    xtype: "thumb",
    config: {
        baseCls: Ext.baseCSSPrefix + "thumb",
        draggable: {
            direction: "horizontal"
        }
    },
    platformConfig: [{
        platform: ["ie10"],
        draggable: {
            translatable: {
                translationMethod: "csstransform"
            }
        }
    }],
    elementWidth: 0,
    initialize: function() {
        this.callParent();
        this.getDraggable().onBefore({
            dragstart: "onDragStart",
            drag: "onDrag",
            dragend: "onDragEnd",
            scope: this
        });
        this.element.on("resize", "onElementResize", this)
    },
    onDragStart: function() {
        if (this.isDisabled()) {
            return false
        }
        this.relayEvent(arguments)
    },
    onDrag: function() {
        if (this.isDisabled()) {
            return false
        }
        this.relayEvent(arguments)
    },
    onDragEnd: function() {
        if (this.isDisabled()) {
            return false
        }
        this.relayEvent(arguments)
    },
    onElementResize: function(a, b) {
        this.elementWidth = b.width
    },
    getElementWidth: function() {
        return this.elementWidth
    }
});
Ext.define("Ext.slider.Slider", {
    extend: Ext.Container,
    xtype: "slider",
    config: {
        baseCls: "x-slider",
        thumbConfig: {
            draggable: {
                translatable: {
                    easingX: {
                        duration: 300,
                        type: "ease-out"
                    }
                }
            }
        },
        increment: 1,
        value: 0,
        minValue: 0,
        maxValue: 100,
        allowThumbsOverlapping: false,
        animation: true,
        readOnly: false
    },
    elementWidth: 0,
    offsetValueRatio: 0,
    activeThumb: null,
    constructor: function(a) {
        a = a || {};
        if (a.hasOwnProperty("values")) {
            a.value = a.values
        }
        this.callParent([a])
    },
    initialize: function() {
        var b = this.element;
        this.callParent();
        b.on({
            scope: this,
            tap: "onTap",
            resize: "onResize"
        });
        this.on({
            scope: this,
            delegate: "> thumb",
            tap: "onTap",
            dragstart: "onThumbDragStart",
            drag: "onThumbDrag",
            dragend: "onThumbDragEnd"
        });
        var a = this.getThumb(0);
        if (a) {
            a.on("resize", "onThumbResize", this)
        }
    },
    factoryThumb: function() {
        return Ext.factory(this.getThumbConfig(), Ext.slider.Thumb)
    },
    getThumbs: function() {
        return this.innerItems
    },
    getThumb: function(a) {
        if (typeof a != "number") {
            a = 0
        }
        return this.innerItems[a]
    },
    refreshOffsetValueRatio: function() {
        var b = this.getMaxValue() - this.getMinValue(),
        a = this.elementWidth - this.thumbWidth;
        this.offsetValueRatio = a / b
    },
    onThumbResize: function() {
        var a = this.getThumb(0);
        if (a) {
            this.thumbWidth = a.getElementWidth()
        }
        this.refresh()
    },
    onResize: function(a, b) {
        this.elementWidth = b.width;
        this.refresh()
    },
    refresh: function() {
        this.refreshValue()
    },
    setActiveThumb: function(b) {
        var a = this.activeThumb;
        if (a && a !== b) {
            a.setZIndex(null)
        }
        this.activeThumb = b;
        b.setZIndex(2);
        return this
    },
    onThumbDragStart: function(a, b) {
        if (b.absDeltaX <= b.absDeltaY || this.getReadOnly()) {
            return false
        } else {
            b.stopPropagation()
        }
        if (this.getAllowThumbsOverlapping()) {
            this.setActiveThumb(a)
        }
        this.dragStartValue = this.getValue()[this.getThumbIndex(a)];
        this.fireEvent("dragstart", this, a, this.dragStartValue, b)
    },
    onThumbDrag: function(d, h, a) {
        var f = this.getThumbIndex(d),
        g = this.offsetValueRatio,
        b = this.constrainValue(this.getMinValue() + a / g);
        h.stopPropagation();
        this.setIndexValue(f, b);
        this.fireEvent("drag", this, d, this.getValue(), h);
        return false
    },
    setIndexValue: function(e, g, b) {
        var a = this.getThumb(e),
        i = this.getValue(),
        f = this.getMinValue(),
        d = this.offsetValueRatio,
        h = this.getIncrement(),
        j = a.getDraggable();
        j.setOffset((g - f) * d, null, b);
        i[e] = f + Math.round((j.offset.x / d) / h) * h
    },
    onThumbDragEnd: function(a, g) {
        this.refreshThumbConstraints(a);
        var d = this.getThumbIndex(a),
        f = this.getValue()[d],
        b = this.dragStartValue;
        this.fireEvent("dragend", this, a, this.getValue(), g);
        if (b !== f) {
            this.fireEvent("change", this, a, f, b)
        }
    },
    getThumbIndex: function(a) {
        return this.getThumbs().indexOf(a)
    },
    refreshThumbConstraints: function(e) {
        var b = this.getAllowThumbsOverlapping(),
        a = e.getDraggable().getOffset().x,
        d = this.getThumbs(),
        f = this.getThumbIndex(e),
        h = d[f - 1],
        i = d[f + 1],
        g = this.thumbWidth;
        if (h) {
            h.getDraggable().addExtraConstraint({
                max: {
                    x: a - ((b) ? 0 : g)
                }
            })
        }
        if (i) {
            i.getDraggable().addExtraConstraint({
                min: {
                    x: a + ((b) ? 0 : g)
                }
            })
        }
    },
    onTap: function(k) {
        if (this.isDisabled()) {
            return
        }
        var m = Ext.get(k.target);
        if (!m || (Ext.browser.engineName == "WebKit" && m.hasCls("x-thumb"))) {
            return
        }
        var p = k.touch.point.x,
        j = this.element,
        d = j.getX(),
        f = p - d - (this.thumbWidth / 2),
        q = this.constrainValue(this.getMinValue() + f / this.offsetValueRatio),
        t = this.getValue(),
        s = Infinity,
        o = t.length,
        h,
        g,
        n,
        r,
        b,
        a;
        if (o === 1) {
            r = 0
        } else {
            for (h = 0; h < o; h++) {
                n = t[h];
                g = Math.abs(n - q);
                if (g < s) {
                    s = g;
                    r = h
                }
            }
        }
        b = t[r];
        a = this.getThumb(r);
        this.setIndexValue(r, q, this.getAnimation());
        this.refreshThumbConstraints(a);
        if (b !== q) {
            this.fireEvent("change", this, a, q, b)
        }
    },
    updateThumbs: function(a) {
        this.add(a)
    },
    applyValue: function(h) {
        var e = Ext.Array.from(h || 0),
        b = [],
        d = this.getMinValue(),
        a,
        f,
        g;
        for (f = 0, g = e.length; f < g; f++) {
            a = this.constrainValue(e[f]);
            if (a < d) {
                a = d
            }
            b.push(a);
            d = a
        }
        return b
    },
    updateValue: function(g, b) {
        var a = this.getThumbs(),
        e = g.length,
        f = this.getMinValue(),
        h = this.offsetValueRatio,
        d;
        this.setThumbsCount(e);
        for (d = 0; d < e; d++) {
            a[d].getDraggable().setExtraConstraint(null).setOffset((g[d] - f) * h)
        }
        for (d = 0; d < e; d++) {
            this.refreshThumbConstraints(a[d])
        }
    },
    refreshValue: function() {
        this.refreshOffsetValueRatio();
        this.setValue(this.getValue())
    },
    constrainValue: function(f) {
        var b = this,
        e = b.getMinValue(),
        g = b.getMaxValue(),
        a = b.getIncrement(),
        d;
        f = parseFloat(f);
        if (isNaN(f)) {
            f = e
        }
        d = (f - e) % a;
        f -= d;
        if (Math.abs(d) >= (a / 2)) {
            f += (d > 0) ? a: -a
        }
        f = Math.max(e, f);
        f = Math.min(g, f);
        return f
    },
    setThumbsCount: function(f) {
        var a = this.getThumbs(),
        g = a.length,
        d,
        e,
        b;
        if (g > f) {
            for (d = 0, e = g - f; d < e; d++) {
                b = a[a.length - 1];
                b.destroy()
            }
        } else {
            if (g < f) {
                for (d = 0, e = f - g; d < e; d++) {
                    this.add(this.factoryThumb())
                }
            }
        }
        return this
    },
    setValues: function(a) {
        this.setValue(a)
    },
    getValues: function() {
        return this.getValue()
    },
    applyIncrement: function(a) {
        if (a === 0) {
            a = 1
        }
        return Math.abs(a)
    },
    updateAllowThumbsOverlapping: function(b, a) {
        if (typeof a != "undefined") {
            this.refreshValue()
        }
    },
    updateMinValue: function(b, a) {
        if (typeof a != "undefined") {
            this.refreshValue()
        }
    },
    updateMaxValue: function(b, a) {
        if (typeof a != "undefined") {
            this.refreshValue()
        }
    },
    updateIncrement: function(b, a) {
        if (typeof a != "undefined") {
            this.refreshValue()
        }
    },
    doSetDisabled: function(d) {
        this.callParent(arguments);
        var a = this.getItems().items,
        e = a.length,
        b;
        for (b = 0; b < e; b++) {
            a[b].setDisabled(d)
        }
    }
},
function() {});
Ext.define("Ext.field.Slider", {
    extend: Ext.field.Field,
    xtype: "sliderfield",
    alternateClassName: "Ext.form.Slider",
    config: {
        cls: Ext.baseCSSPrefix + "slider-field",
        tabIndex: -1,
        readOnly: false
    },
    proxyConfig: {
        increment: 1,
        value: 0,
        minValue: 0,
        maxValue: 100
    },
    constructor: function(a) {
        a = a || {};
        if (a.hasOwnProperty("values")) {
            a.value = a.values
        }
        this.callParent([a]);
        this.updateMultipleState()
    },
    initialize: function() {
        this.callParent();
        this.getComponent().on({
            scope: this,
            change: "onSliderChange",
            dragstart: "onSliderDragStart",
            drag: "onSliderDrag",
            dragend: "onSliderDragEnd"
        })
    },
    applyComponent: function(a) {
        return Ext.factory(a, Ext.slider.Slider)
    },
    updateComponent: function(a) {
        this.callSuper(arguments);
        a.setMinValue(this.getMinValue());
        a.setMaxValue(this.getMaxValue())
    },
    onSliderChange: function() {
        this.fireEvent.apply(this, [].concat("change", this, Array.prototype.slice.call(arguments)))
    },
    onSliderDragStart: function() {
        this.fireEvent.apply(this, [].concat("dragstart", this, Array.prototype.slice.call(arguments)))
    },
    onSliderDrag: function() {
        this.fireEvent.apply(this, [].concat("drag", this, Array.prototype.slice.call(arguments)))
    },
    onSliderDragEnd: function() {
        this.fireEvent.apply(this, [].concat("dragend", this, Array.prototype.slice.call(arguments)))
    },
    setValues: function(a) {
        this.setValue(a);
        this.updateMultipleState()
    },
    getValues: function() {
        return this.getValue()
    },
    reset: function() {
        var b = this.config,
        a = (this.config.hasOwnProperty("values")) ? b.values: b.value;
        this.setValue(a)
    },
    doSetDisabled: function(a) {
        this.callParent(arguments);
        this.getComponent().setDisabled(a)
    },
    updateReadOnly: function(a) {
        this.getComponent().setReadOnly(a)
    },
    isDirty: function() {
        if (this.getDisabled()) {
            return false
        }
        return this.getValue() !== this.originalValue
    },
    updateMultipleState: function() {
        var a = this.getValue();
        if (a && a.length > 1) {
            this.addCls(Ext.baseCSSPrefix + "slider-multiple")
        }
    }
});
Ext.define("Ext.fx.runner.Css", {
    extend: Ext.Evented,
    prefixedProperties: {
        transform: true,
        "transform-origin": true,
        perspective: true,
        "transform-style": true,
        transition: true,
        "transition-property": true,
        "transition-duration": true,
        "transition-timing-function": true,
        "transition-delay": true,
        animation: true,
        "animation-name": true,
        "animation-duration": true,
        "animation-iteration-count": true,
        "animation-direction": true,
        "animation-timing-function": true,
        "animation-delay": true
    },
    lengthProperties: {
        top: true,
        right: true,
        bottom: true,
        left: true,
        width: true,
        height: true,
        "max-height": true,
        "max-width": true,
        "min-height": true,
        "min-width": true,
        "margin-bottom": true,
        "margin-left": true,
        "margin-right": true,
        "margin-top": true,
        "padding-bottom": true,
        "padding-left": true,
        "padding-right": true,
        "padding-top": true,
        "border-bottom-width": true,
        "border-left-width": true,
        "border-right-width": true,
        "border-spacing": true,
        "border-top-width": true,
        "border-width": true,
        "outline-width": true,
        "letter-spacing": true,
        "line-height": true,
        "text-indent": true,
        "word-spacing": true,
        "font-size": true,
        translate: true,
        translateX: true,
        translateY: true,
        translateZ: true,
        translate3d: true
    },
    durationProperties: {
        "transition-duration": true,
        "transition-delay": true,
        "animation-duration": true,
        "animation-delay": true
    },
    angleProperties: {
        rotate: true,
        rotateX: true,
        rotateY: true,
        rotateZ: true,
        skew: true,
        skewX: true,
        skewY: true
    },
    lengthUnitRegex: /([a-z%]*)$/,
    DEFAULT_UNIT_LENGTH: "px",
    DEFAULT_UNIT_ANGLE: "deg",
    DEFAULT_UNIT_DURATION: "ms",
    formattedNameCache: {},
    constructor: function() {
        var a = Ext.feature.has.Css3dTransforms;
        if (a) {
            this.transformMethods = ["translateX", "translateY", "translateZ", "rotate", "rotateX", "rotateY", "rotateZ", "skewX", "skewY", "scaleX", "scaleY", "scaleZ"]
        } else {
            this.transformMethods = ["translateX", "translateY", "rotate", "skewX", "skewY", "scaleX", "scaleY"]
        }
        this.vendorPrefix = Ext.browser.getStyleDashPrefix();
        this.ruleStylesCache = {};
        return this
    },
    getStyleSheet: function() {
        var d = this.styleSheet,
        a, b;
        if (!d) {
            a = document.createElement("style");
            a.type = "text/css"; (document.head || document.getElementsByTagName("head")[0]).appendChild(a);
            b = document.styleSheets;
            this.styleSheet = d = b[b.length - 1]
        }
        return d
    },
    applyRules: function(j) {
        var h = this.getStyleSheet(),
        m = this.ruleStylesCache,
        k = h.cssRules,
        d,
        f,
        i,
        b,
        e,
        a,
        g;
        for (d in j) {
            f = j[d];
            i = m[d];
            if (i === undefined) {
                e = k.length;
                h.insertRule(d + "{}", e);
                i = m[d] = k.item(e).style
            }
            b = i.$cache;
            if (!b) {
                b = i.$cache = {}
            }
            for (a in f) {
                g = this.formatValue(f[a], a);
                a = this.formatName(a);
                if (b[a] !== g) {
                    b[a] = g;
                    if (g === null) {
                        i.removeProperty(a)
                    } else {
                        i.setProperty(a, g, "important")
                    }
                }
            }
        }
        return this
    },
    applyStyles: function(e) {
        var h, d, g, b, a, f;
        for (h in e) {
            if (e.hasOwnProperty(h)) {
                d = document.getElementById(h);
                if (!d) {
                    return this
                }
                g = d.style;
                b = e[h];
                for (a in b) {
                    if (b.hasOwnProperty(a)) {
                        f = this.formatValue(b[a], a);
                        a = this.formatName(a);
                        if (f === null) {
                            g.removeProperty(a)
                        } else {
                            g.setProperty(a, f, "important")
                        }
                    }
                }
            }
        }
        return this
    },
    formatName: function(b) {
        var a = this.formattedNameCache,
        d = a[b];
        if (!d) {
            if ((Ext.os.is.Tizen || !Ext.feature.has.CssTransformNoPrefix) && this.prefixedProperties[b]) {
                d = this.vendorPrefix + b
            } else {
                d = b
            }
            a[b] = d
        }
        return d
    },
    formatValue: function(k, b) {
        var h = typeof k,
        n = this.DEFAULT_UNIT_LENGTH,
        f, a, e, g, d, m, j;
        if (k === null) {
            return ""
        }
        if (h == "string") {
            if (this.lengthProperties[b]) {
                j = k.match(this.lengthUnitRegex)[1];
                if (j.length > 0) {} else {
                    return k + n
                }
            }
            return k
        } else {
            if (h == "number") {
                if (k == 0) {
                    return "0"
                }
                if (this.lengthProperties[b]) {
                    return k + n
                }
                if (this.angleProperties[b]) {
                    return k + this.DEFAULT_UNIT_ANGLE
                }
                if (this.durationProperties[b]) {
                    return k + this.DEFAULT_UNIT_DURATION
                }
            } else {
                if (b === "transform") {
                    f = this.transformMethods;
                    d = [];
                    for (e = 0, g = f.length; e < g; e++) {
                        a = f[e];
                        d.push(a + "(" + this.formatValue(k[a], a) + ")")
                    }
                    return d.join(" ")
                } else {
                    if (Ext.isArray(k)) {
                        m = [];
                        for (e = 0, g = k.length; e < g; e++) {
                            m.push(this.formatValue(k[e], b))
                        }
                        return (m.length > 0) ? m.join(", ") : "none"
                    }
                }
            }
        }
        return k
    }
});
Ext.define("Ext.fx.runner.CssTransition", {
    extend: Ext.fx.runner.Css,
    listenersAttached: false,
    constructor: function() {
        this.runningAnimationsData = {};
        return this.callParent(arguments)
    },
    attachListeners: function() {
        this.listenersAttached = true;
        this.getEventDispatcher().addListener("element", "*", "transitionend", "onTransitionEnd", this)
    },
    onTransitionEnd: function(b) {
        var a = b.target,
        d = a.id;
        if (d && this.runningAnimationsData.hasOwnProperty(d)) {
            this.refreshRunningAnimationsData(Ext.get(a), [b.browserEvent.propertyName])
        }
    },
    onAnimationEnd: function(h, g, e, k, p) {
        var d = h.getId(),
        m = this.runningAnimationsData[d],
        q = {},
        o = {},
        b,
        j,
        f,
        n,
        a;
        e.un("stop", "onAnimationStop", this);
        if (m) {
            b = m.nameMap
        }
        q[d] = o;
        if (g.onBeforeEnd) {
            g.onBeforeEnd.call(g.scope || this, h, k)
        }
        e.fireEvent("animationbeforeend", e, h, k);
        this.fireEvent("animationbeforeend", this, e, h, k);
        if (p || (!k && !g.preserveEndState)) {
            j = g.toPropertyNames;
            for (f = 0, n = j.length; f < n; f++) {
                a = j[f];
                if (b && !b.hasOwnProperty(a)) {
                    o[a] = null
                }
            }
        }
        if (g.after) {
            Ext.merge(o, g.after)
        }
        this.applyStyles(q);
        if (g.onEnd) {
            g.onEnd.call(g.scope || this, h, k)
        }
        e.fireEvent("animationend", e, h, k);
        this.fireEvent("animationend", this, e, h, k);
        Ext.AnimationQueue.stop(Ext.emptyFn, e)
    },
    onAllAnimationsEnd: function(b) {
        var d = b.getId(),
        a = {};
        delete this.runningAnimationsData[d];
        a[d] = {
            "transition-property": null,
            "transition-duration": null,
            "transition-timing-function": null,
            "transition-delay": null
        };
        this.applyStyles(a);
        this.fireEvent("animationallend", this, b)
    },
    hasRunningAnimations: function(a) {
        var d = a.getId(),
        b = this.runningAnimationsData;
        return b.hasOwnProperty(d) && b[d].sessions.length > 0
    },
    refreshRunningAnimationsData: function(e, m, v, r) {
        var h = e.getId(),
        s = this.runningAnimationsData,
        a = s[h];
        if (!a) {
            return
        }
        var o = a.nameMap,
        u = a.nameList,
        b = a.sessions,
        g, k, f, y, n, d, t, q, p = false;
        v = Boolean(v);
        r = Boolean(r);
        if (!b) {
            return this
        }
        g = b.length;
        if (g === 0) {
            return this
        }
        if (r) {
            a.nameMap = {};
            u.length = 0;
            for (n = 0; n < g; n++) {
                d = b[n];
                this.onAnimationEnd(e, d.data, d.animation, v, r)
            }
            b.length = 0
        } else {
            for (n = 0; n < g; n++) {
                d = b[n];
                t = d.map;
                q = d.list;
                for (k = 0, f = m.length; k < f; k++) {
                    y = m[k];
                    if (t[y]) {
                        delete t[y];
                        Ext.Array.remove(q, y);
                        d.length--;
                        if (--o[y] == 0) {
                            delete o[y];
                            Ext.Array.remove(u, y)
                        }
                    }
                }
                if (d.length == 0) {
                    b.splice(n, 1);
                    n--;
                    g--;
                    p = true;
                    this.onAnimationEnd(e, d.data, d.animation, v)
                }
            }
        }
        if (!r && !v && b.length == 0 && p) {
            this.onAllAnimationsEnd(e)
        }
    },
    getRunningData: function(b) {
        var a = this.runningAnimationsData;
        if (!a.hasOwnProperty(b)) {
            a[b] = {
                nameMap: {},
                nameList: [],
                sessions: []
            }
        }
        return a[b]
    },
    getTestElement: function() {
        var d = this.testElement,
        b, e, a;
        if (!d) {
            b = document.createElement("iframe");
            a = b.style;
            a.setProperty("visibility", "hidden", "important");
            a.setProperty("width", "0px", "important");
            a.setProperty("height", "0px", "important");
            a.setProperty("position", "absolute", "important");
            a.setProperty("border", "0px", "important");
            a.setProperty("zIndex", "-1000", "important");
            document.body.appendChild(b);
            e = b.contentDocument;
            e.open();
            e.writeln("</body>");
            e.close();
            this.testElement = d = e.createElement("div");
            d.style.setProperty("position", "absolute", "important");
            e.body.appendChild(d);
            this.testElementComputedStyle = window.getComputedStyle(d)
        }
        return d
    },
    getCssStyleValue: function(b, f) {
        var e = this.getTestElement(),
        a = this.testElementComputedStyle,
        d = e.style;
        d.setProperty(b, f);
        if (Ext.browser.is.Firefox) {
            e.offsetHeight
        }
        f = a.getPropertyValue(b);
        d.removeProperty(b);
        return f
    },
    run: function(s) {
        var K = this,
        k = this.lengthProperties,
        C = {},
        J = {},
        L = {},
        e, v, D, f, z, N, A, t, u, a, p, F, E, r, G, n, y, h, H, M, m, g, B, q, d, I, b, o;
        if (!this.listenersAttached) {
            this.attachListeners()
        }
        s = Ext.Array.from(s);
        for (F = 0, r = s.length; F < r; F++) {
            G = s[F];
            G = Ext.factory(G, Ext.fx.Animation);
            e = G.getElement();
            Ext.AnimationQueue.start(Ext.emptyFn, G);
            h = window.getComputedStyle(e.dom);
            v = e.getId();
            L = Ext.merge({},
            G.getData());
            if (G.onBeforeStart) {
                G.onBeforeStart.call(G.scope || this, e)
            }
            G.fireEvent("animationstart", G);
            this.fireEvent("animationstart", this, G);
            L[v] = L;
            z = L.before;
            D = L.from;
            f = L.to;
            L.fromPropertyNames = N = [];
            L.toPropertyNames = A = [];
            for (M in f) {
                if (f.hasOwnProperty(M)) {
                    f[M] = m = this.formatValue(f[M], M);
                    H = this.formatName(M);
                    q = k.hasOwnProperty(M);
                    if (!q) {
                        m = this.getCssStyleValue(H, m)
                    }
                    if (D.hasOwnProperty(M)) {
                        D[M] = B = this.formatValue(D[M], M);
                        if (!q) {
                            B = this.getCssStyleValue(H, B)
                        }
                        if (m !== B) {
                            N.push(H);
                            A.push(H)
                        }
                    } else {
                        g = h.getPropertyValue(H);
                        if (m !== g) {
                            A.push(H)
                        }
                    }
                }
            }
            n = A.length;
            if (n === 0) {
                this.onAnimationEnd(e, L, G);
                continue
            }
            a = this.getRunningData(v);
            b = a.sessions;
            if (b.length > 0) {
                this.refreshRunningAnimationsData(e, Ext.Array.merge(N, A), true, L.replacePrevious)
            }
            d = a.nameMap;
            I = a.nameList;
            y = {};
            for (E = 0; E < n; E++) {
                M = A[E];
                y[M] = true;
                if (!d.hasOwnProperty(M)) {
                    d[M] = 1;
                    I.push(M)
                } else {
                    d[M]++
                }
            }
            o = {
                element: e,
                map: y,
                list: A.slice(),
                length: n,
                data: L,
                animation: G
            };
            b.push(o);
            G.on("stop", "onAnimationStop", this);
            p = Ext.apply({},
            z);
            Ext.apply(p, D);
            if (I.length > 0) {
                N = Ext.Array.difference(I, N);
                A = Ext.Array.merge(N, A);
                p["transition-property"] = N
            }
            C[v] = p;
            J[v] = Ext.apply({},
            f);
            J[v]["transition-property"] = A;
            J[v]["transition-duration"] = L.duration;
            J[v]["transition-timing-function"] = L.easing;
            J[v]["transition-delay"] = L.delay;
            G.startTime = Date.now()
        }
        u = this.$className;
        this.applyStyles(C);
        t = function(i) {
            if (i.data === u && i.source === window) {
                window.removeEventListener("message", t, false);
                K.applyStyles(J)
            }
        };
        if (Ext.browser.is.IE) {
            window.requestAnimationFrame(function() {
                window.addEventListener("message", t, false);
                window.postMessage(u, "*")
            })
        } else {
            window.addEventListener("message", t, false);
            window.postMessage(u, "*")
        }
    },
    onAnimationStop: function(e) {
        var g = this.runningAnimationsData,
        j, a, h, b, d, f;
        for (j in g) {
            if (g.hasOwnProperty(j)) {
                a = g[j];
                h = a.sessions;
                for (b = 0, d = h.length; b < d; b++) {
                    f = h[b];
                    if (f.animation === e) {
                        this.refreshRunningAnimationsData(f.element, f.list.slice(), false)
                    }
                }
            }
        }
    }
});
Ext.define("Ext.fx.Runner", {
    constructor: function() {
        return new Ext.fx.runner.CssTransition()
    }
});
Ext.define("Ext.plugin.ListPaging", {
    extend: Ext.Component,
    alias: "plugin.listpaging",
    config: {
        autoPaging: false,
        loadMoreText: "Load More...",
        noMoreRecordsText: "No More Records",
        loadTpl: ['<div class="{cssPrefix}loading-spinner" style="font-size: 180%; margin: 10px auto;">', '<span class="{cssPrefix}loading-top"></span>', '<span class="{cssPrefix}loading-right"></span>', '<span class="{cssPrefix}loading-bottom"></span>', '<span class="{cssPrefix}loading-left"></span>', "</div>", '<div class="{cssPrefix}list-paging-msg">{message}</div>'].join(""),
        loadMoreCmp: {
            xtype: "component",
            baseCls: Ext.baseCSSPrefix + "list-paging",
            scrollDock: "bottom",
            hidden: true
        },
        loadMoreCmpAdded: false,
        loadingCls: Ext.baseCSSPrefix + "loading",
        list: null,
        scroller: null,
        loading: false
    },
    init: function(d) {
        var a = d.getScrollable().getScroller(),
        b = d.getStore();
        this.setList(d);
        this.setScroller(a);
        this.bindStore(d.getStore());
        this.addLoadMoreCmp();
        d.updateStore = Ext.Function.createInterceptor(d.updateStore, this.bindStore, this);
        if (this.getAutoPaging()) {
            a.on({
                scrollend: this.onScrollEnd,
                scope: this
            })
        }
    },
    bindStore: function(a, b) {
        if (b) {
            b.un({
                beforeload: this.onStoreBeforeLoad,
                load: this.onStoreLoad,
                filter: this.onFilter,
                scope: this
            })
        }
        if (a) {
            a.on({
                beforeload: this.onStoreBeforeLoad,
                load: this.onStoreLoad,
                filter: this.onFilter,
                scope: this
            })
        }
    },
    disableDataViewMask: function() {
        var a = this.getList();
        this._listMask = a.getLoadingText();
        a.setLoadingText(null)
    },
    enableDataViewMask: function() {
        if (this._listMask) {
            var a = this.getList();
            a.setLoadingText(this._listMask);
            delete this._listMask
        }
    },
    applyLoadTpl: function(a) {
        return (Ext.isObject(a) && a.isTemplate) ? a: new Ext.XTemplate(a)
    },
    applyLoadMoreCmp: function(a) {
        a = Ext.merge(a, {
            html: this.getLoadTpl().apply({
                cssPrefix: Ext.baseCSSPrefix,
                message: this.getLoadMoreText()
            }),
            scrollDock: "bottom",
            listeners: {
                tap: {
                    fn: this.loadNextPage,
                    scope: this,
                    element: "element"
                }
            }
        });
        return Ext.factory(a, Ext.Component, this.getLoadMoreCmp())
    },
    onScrollEnd: function(b, a, e) {
        var d = this.getList();
        if (!this.getLoading() && e >= b.maxPosition.y) {
            this.currentScrollToTopOnRefresh = d.getScrollToTopOnRefresh();
            d.setScrollToTopOnRefresh(false);
            this.loadNextPage()
        }
    },
    updateLoading: function(a) {
        var b = this.getLoadMoreCmp(),
        d = this.getLoadingCls();
        if (a) {
            b.addCls(d)
        } else {
            b.removeCls(d)
        }
    },
    onStoreBeforeLoad: function(a) {
        if (a.getCount() === 0) {
            this.getLoadMoreCmp().hide()
        }
    },
    onStoreLoad: function(a) {
        var e = this.getLoadMoreCmp(),
        b = this.getLoadTpl(),
        d = this.storeFullyLoaded() ? this.getNoMoreRecordsText() : this.getLoadMoreText();
        if (a.getCount()) {
            e.show()
        }
        this.setLoading(false);
        e.setHtml(b.apply({
            cssPrefix: Ext.baseCSSPrefix,
            message: d
        }));
        if (this.currentScrollToTopOnRefresh !== undefined) {
            this.getList().setScrollToTopOnRefresh(this.currentScrollToTopOnRefresh);
            delete this.currentScrollToTopOnRefresh
        }
        this.enableDataViewMask()
    },
    onFilter: function(a) {
        if (a.getCount() === 0) {
            this.getLoadMoreCmp().hide()
        } else {
            this.getLoadMoreCmp().show()
        }
    },
    addLoadMoreCmp: function() {
        var b = this.getList(),
        a = this.getLoadMoreCmp();
        if (!this.getLoadMoreCmpAdded()) {
            b.add(a);
            b.fireEvent("loadmorecmpadded", this, b);
            this.setLoadMoreCmpAdded(true)
        }
        return a
    },
    storeFullyLoaded: function() {
        var a = this.getList().getStore(),
        b = a.getTotalCount();
        return b !== null ? a.getTotalCount() <= (a.currentPage * a.getPageSize()) : false
    },
    loadNextPage: function() {
        var a = this;
        if (!a.storeFullyLoaded()) {
            a.disableDataViewMask();
            a.setLoading(true);
            a.getList().getStore().nextPage({
                addRecords: true
            })
        }
    }
});
Ext.define("Ext.plugin.PullRefresh", {
    extend: Ext.Component,
    alias: "plugin.pullrefresh",
    config: {
        list: null,
        pullText: "Pull down to refresh...",
        releaseText: "Release to refresh...",
        loadingText: "Loading...",
        loadedText: "Loaded.",
        lastUpdatedText: "Last Updated:&nbsp;",
        scrollerAutoRefresh: false,
        autoSnapBack: true,
        snappingAnimationDuration: 300,
        lastUpdatedDateFormat: "m/d/Y h:iA",
        overpullSnapBackDuration: 300,
        pullTpl: ['<div class="x-list-pullrefresh-arrow"></div>', '<div class="x-loading-spinner">', '<span class="x-loading-top"></span>', '<span class="x-loading-right"></span>', '<span class="x-loading-bottom"></span>', '<span class="x-loading-left"></span>', "</div>", '<div class="x-list-pullrefresh-wrap">', '<h3 class="x-list-pullrefresh-message">{message}</h3>', '<div class="x-list-pullrefresh-updated">{updated}</div>', "</div>"].join(""),
        translatable: true
    },
    $state: "pull",
    getState: function() {
        return this.$state
    },
    setState: function(a) {
        this.$state = a;
        this.updateView()
    },
    $isSnappingBack: false,
    getIsSnappingBack: function() {
        return this.$isSnappingBack
    },
    setIsSnappingBack: function(a) {
        this.$isSnappingBack = a
    },
    init: function(b) {
        var a = this;
        a.setList(b);
        a.initScrollable()
    },
    getElementConfig: function() {
        return {
            reference: "element",
            classList: ["x-unsized"],
            children: [{
                reference: "innerElement",
                className: Ext.baseCSSPrefix + "list-pullrefresh"
            }]
        }
    },
    initScrollable: function() {
        var b = this,
        e = b.getList(),
        d = e.getScrollable(),
        a;
        if (!d) {
            return
        }
        a = d.getScroller();
        a.setAutoRefresh(this.getScrollerAutoRefresh());
        b.lastUpdated = new Date();
        e.insert(0, b);
        a.on({
            scroll: b.onScrollChange,
            scope: b
        });
        this.updateView()
    },
    applyPullTpl: function(a) {
        if (a instanceof Ext.XTemplate) {
            return a
        } else {
            return new Ext.XTemplate(a)
        }
    },
    updateList: function(a, d) {
        var b = this;
        if (a && a != d) {
            a.on({
                order: "after",
                scrollablechange: b.initScrollable,
                scope: b
            })
        } else {
            if (d) {
                d.un({
                    order: "after",
                    scrollablechange: b.initScrollable,
                    scope: b
                })
            }
        }
    },
    getPullHeight: function() {
        return this.innerElement.getHeight()
    },
    fetchLatest: function() {
        var b = this.getList().getStore(),
        d = b.getProxy(),
        a;
        a = Ext.create("Ext.data.Operation", {
            page: 1,
            start: 0,
            model: b.getModel(),
            limit: b.getPageSize(),
            action: "read",
            sorters: b.getSorters(),
            filters: b.getRemoteFilter() ? b.getFilters() : []
        });
        d.read(a, this.onLatestFetched, this)
    },
    onLatestFetched: function(e) {
        var k = this.getList().getStore(),
        b = k.getData(),
        d = e.getRecords(),
        a = d.length,
        h = [],
        j,
        g,
        f;
        for (f = 0; f < a; f++) {
            j = d[f];
            g = b.getByKey(j.getId());
            if (g) {
                g.set(j.getData())
            } else {
                h.push(j)
            }
            g = undefined
        }
        k.insert(0, h);
        this.setState("loaded");
        this.fireEvent("latestfetched", this, h);
        if (this.getAutoSnapBack()) {
            this.snapBack()
        }
    },
    snapBack: function(d) {
        if (this.getState() !== "loaded" && d !== true) {
            return
        }
        var b = this.getList(),
        a = b.getScrollable().getScroller();
        a.refresh();
        a.minPosition.y = 0;
        a.on({
            scrollend: this.onSnapBackEnd,
            single: true,
            scope: this
        });
        this.setIsSnappingBack(true);
        a.scrollTo(null, 0, {
            duration: this.getSnappingAnimationDuration()
        })
    },
    onSnapBackEnd: function() {
        this.setState("pull");
        this.setIsSnappingBack(false)
    },
    onScrollChange: function(b, a, f) {
        if (f <= 0) {
            var e = this.getPullHeight(),
            d = this.getIsSnappingBack();
            if (this.getState() === "loaded" && !d) {
                this.snapBack()
            }
            if (this.getState() !== "loading" && this.getState() !== "loaded") {
                if ( - f >= e + 10) {
                    this.setState("release");
                    b.getContainer().onBefore({
                        dragend: "onScrollerDragEnd",
                        single: true,
                        scope: this
                    })
                } else {
                    if ((this.getState() === "release") && ( - f < e + 10)) {
                        this.setState("pull");
                        b.getContainer().unBefore({
                            dragend: "onScrollerDragEnd",
                            single: true,
                            scope: this
                        })
                    }
                }
            }
            this.getTranslatable().translate(0, -f)
        }
    },
    onScrollerDragEnd: function() {
        if (this.getState() !== "loading") {
            var d = this.getList(),
            a = d.getScrollable().getScroller(),
            b = a.getTranslatable();
            this.setState("loading");
            b.setEasingY({
                duration: this.getOverpullSnapBackDuration()
            });
            a.minPosition.y = -this.getPullHeight();
            a.on({
                scrollend: "fetchLatest",
                single: true,
                scope: this
            })
        }
    },
    updateView: function() {
        var f = this.getState(),
        e = this.getLastUpdatedText() + Ext.util.Format.date(this.lastUpdated, this.getLastUpdatedDateFormat()),
        d = {
            state: f,
            updated: e
        },
        b = f.charAt(0).toUpperCase() + f.slice(1).toLowerCase(),
        a = "get" + b + "Text";
        if (this[a] && Ext.isFunction(this[a])) {
            d.message = this[a].call(this)
        }
        this.innerElement.removeCls(["loaded", "loading", "release", "pull"], Ext.baseCSSPrefix + "list-pullrefresh");
        this.innerElement.addCls(this.getState(), Ext.baseCSSPrefix + "list-pullrefresh");
        this.getPullTpl().overwrite(this.innerElement, d)
    }
},
function() {
    Ext.deprecateClassMethod(this, "setPullRefreshText", "setPullText");
    Ext.deprecateClassMethod(this, "setReleaseRefreshText", "setReleaseText");
    this.override({
        constructor: function(a) {
            if (a) {
                if (a.hasOwnProperty("pullReleaseText")) {
                    a.releaseText = a.pullReleaseText;
                    delete a.pullReleaseText
                }
                if (a.hasOwnProperty("pullRefreshText")) {
                    a.pullText = a.pullRefreshText;
                    delete a.pullRefreshText
                }
            }
            this.callParent([a])
        }
    })
});
Ext.define("Ext.viewport.Default", {
    extend: Ext.Container,
    xtype: "viewport",
    PORTRAIT: "portrait",
    LANDSCAPE: "landscape",
    config: {
        autoMaximize: false,
        autoBlurInput: true,
        preventPanning: true,
        preventZooming: false,
        autoRender: true,
        layout: "card",
        width: "100%",
        height: "100%",
        useBodyElement: true,
        menus: {}
    },
    isReady: false,
    isViewport: true,
    isMaximizing: false,
    id: "ext-viewport",
    isInputRegex: /^(input|textarea|select|a)$/i,
    focusedElement: null,
    fullscreenItemCls: Ext.baseCSSPrefix + "fullscreen",
    constructor: function(a) {
        var b = Ext.Function.bind;
        this.doPreventPanning = b(this.doPreventPanning, this);
        this.doPreventZooming = b(this.doPreventZooming, this);
        this.doBlurInput = b(this.doBlurInput, this);
        this.maximizeOnEvents = ["ready", "orientationchange"];
        window.devicePixelRatio = window.devicePixelRatio || 1;
        this.callSuper([a]);
        this.orientation = this.determineOrientation();
        this.windowWidth = this.getWindowWidth();
        this.windowHeight = this.getWindowHeight();
        this.windowOuterHeight = this.getWindowOuterHeight();
        if (!this.stretchHeights) {
            this.stretchHeights = {}
        }
        if (!Ext.os.is.Android || Ext.browser.is.ChromeMobile) {
            if (this.supportsOrientation()) {
                this.addWindowListener("orientationchange", b(this.onOrientationChange, this))
            } else {
                this.addWindowListener("resize", b(this.onResize, this))
            }
        }
        document.addEventListener("focus", b(this.onElementFocus, this), true);
        document.addEventListener("blur", b(this.onElementBlur, this), true);
        Ext.onDocumentReady(this.onDomReady, this);
        this.on("ready", this.onReady, this, {
            single: true
        });
        this.getEventDispatcher().addListener("component", "*", "fullscreen", "onItemFullscreenChange", this);
        return this
    },
    onDomReady: function() {
        this.isReady = true;
        this.updateSize();
        this.fireEvent("ready", this)
    },
    onReady: function() {
        if (this.getAutoRender()) {
            this.render()
        }
        if (Ext.browser.name == "ChromeiOS") {
            this.setHeight("-webkit-calc(100% - " + ((window.outerHeight - window.innerHeight) / 2) + "px)")
        }
    },
    onElementFocus: function(a) {
        this.focusedElement = a.target
    },
    onElementBlur: function() {
        this.focusedElement = null
    },
    render: function() {
        if (!this.rendered) {
            var a = Ext.getBody(),
            b = Ext.baseCSSPrefix,
            i = [],
            e = Ext.os,
            h = e.name.toLowerCase(),
            g = Ext.browser.name.toLowerCase(),
            f = e.version.getMajor(),
            d = this.getOrientation();
            this.renderTo(a);
            i.push(b + e.deviceType.toLowerCase());
            if (e.is.iPad) {
                i.push(b + "ipad")
            }
            i.push(b + h);
            i.push(b + g);
            if (f) {
                i.push(b + h + "-" + f)
            }
            if (e.is.BlackBerry) {
                i.push(b + "bb")
            }
            if (Ext.browser.is.WebKit) {
                i.push(b + "webkit")
            }
            if (Ext.browser.is.Standalone) {
                i.push(b + "standalone")
            }
            if (Ext.browser.is.AndroidStock) {
                i.push(b + "android-stock")
            }
            i.push(b + d);
            a.addCls(i)
        }
    },
    applyAutoBlurInput: function(a) {
        var b = (Ext.feature.has.Touch) ? "touchstart": "mousedown";
        if (a) {
            this.addWindowListener(b, this.doBlurInput, false)
        } else {
            this.removeWindowListener(b, this.doBlurInput, false)
        }
        return a
    },
    applyAutoMaximize: function(a) {
        if (Ext.browser.is.WebView) {
            a = false
        }
        if (a) {
            this.on("ready", "doAutoMaximizeOnReady", this, {
                single: true
            });
            this.on("orientationchange", "doAutoMaximizeOnOrientationChange", this)
        } else {
            this.un("ready", "doAutoMaximizeOnReady", this);
            this.un("orientationchange", "doAutoMaximizeOnOrientationChange", this)
        }
        return a
    },
    applyPreventPanning: function(a) {
        if (a) {
            this.addWindowListener("touchmove", this.doPreventPanning, false)
        } else {
            this.removeWindowListener("touchmove", this.doPreventPanning, false)
        }
        return a
    },
    applyPreventZooming: function(a) {
        var b = (Ext.feature.has.Touch) ? "touchstart": "mousedown";
        if (a) {
            this.addWindowListener(b, this.doPreventZooming, false)
        } else {
            this.removeWindowListener(b, this.doPreventZooming, false)
        }
        return a
    },
    doAutoMaximizeOnReady: function() {
        var a = arguments[arguments.length - 1];
        a.pause();
        this.isMaximizing = true;
        this.on("maximize",
        function() {
            this.isMaximizing = false;
            this.updateSize();
            a.resume();
            this.fireEvent("ready", this)
        },
        this, {
            single: true
        });
        this.maximize()
    },
    doAutoMaximizeOnOrientationChange: function() {
        var a = arguments[arguments.length - 1],
        b = a.firingArguments;
        a.pause();
        this.isMaximizing = true;
        this.on("maximize",
        function() {
            this.isMaximizing = false;
            this.updateSize();
            b[2] = this.windowWidth;
            b[3] = this.windowHeight;
            a.resume()
        },
        this, {
            single: true
        });
        this.maximize()
    },
    doBlurInput: function(b) {
        var a = b.target,
        d = this.focusedElement;
        if (d && d.nodeName.toUpperCase() != "BODY" && !this.isInputRegex.test(a.tagName)) {
            delete this.focusedElement;
            d.blur()
        }
    },
    doPreventPanning: function(a) {
        a.preventDefault()
    },
    doPreventZooming: function(b) {
        if ("button" in b && b.button !== 0) {
            return
        }
        var a = b.target;
        if (a && a.nodeType === 1 && !this.isInputRegex.test(a.tagName)) {
            b.preventDefault()
        }
    },
    addWindowListener: function(b, d, a) {
        window.addEventListener(b, d, Boolean(a))
    },
    removeWindowListener: function(b, d, a) {
        window.removeEventListener(b, d, Boolean(a))
    },
    doAddListener: function(a, e, d, b) {
        if (a === "ready" && this.isReady && !this.isMaximizing) {
            e.call(d);
            return this
        }
        return this.callSuper(arguments)
    },
    supportsOrientation: function() {
        return Ext.feature.has.Orientation
    },
    onResize: function() {
        var d = this.windowWidth,
        g = this.windowHeight,
        f = this.getWindowWidth(),
        a = this.getWindowHeight(),
        e = this.getOrientation(),
        b = this.determineOrientation();
        if ((d !== f && g !== a) && e !== b) {
            this.fireOrientationChangeEvent(b, e)
        }
    },
    onOrientationChange: function() {
        var b = this.getOrientation(),
        a = this.determineOrientation();
        if (a !== b) {
            this.fireOrientationChangeEvent(a, b)
        }
    },
    fireOrientationChangeEvent: function(b, d) {
        var a = Ext.baseCSSPrefix;
        Ext.getBody().replaceCls(a + d, a + b);
        this.orientation = b;
        this.updateSize();
        this.fireEvent("orientationchange", this, b, this.windowWidth, this.windowHeight)
    },
    updateSize: function(b, a) {
        this.windowWidth = b !== undefined ? b: this.getWindowWidth();
        this.windowHeight = a !== undefined ? a: this.getWindowHeight();
        return this
    },
    waitUntil: function(i, f, h, a, g) {
        if (!a) {
            a = 50
        }
        if (!g) {
            g = 2000
        }
        var d = this,
        b = 0;
        setTimeout(function e() {
            b += a;
            if (i.call(d) === true) {
                if (f) {
                    f.call(d)
                }
            } else {
                if (b >= g) {
                    if (h) {
                        h.call(d)
                    }
                } else {
                    setTimeout(e, a)
                }
            }
        },
        a)
    },
    maximize: function() {
        this.fireMaximizeEvent()
    },
    fireMaximizeEvent: function() {
        this.updateSize();
        this.fireEvent("maximize", this)
    },
    doSetHeight: function(a) {
        Ext.getBody().setHeight(a);
        this.callParent(arguments)
    },
    doSetWidth: function(a) {
        Ext.getBody().setWidth(a);
        this.callParent(arguments)
    },
    scrollToTop: function() {
        window.scrollTo(0, -1)
    },
    getWindowWidth: function() {
        return window.innerWidth
    },
    getWindowHeight: function() {
        return window.innerHeight
    },
    getWindowOuterHeight: function() {
        return window.outerHeight
    },
    getWindowOrientation: function() {
        return window.orientation
    },
    getOrientation: function() {
        return this.orientation
    },
    getSize: function() {
        return {
            width: this.windowWidth,
            height: this.windowHeight
        }
    },
    determineOrientation: function() {
        var b = this.PORTRAIT,
        a = this.LANDSCAPE;
        if (!Ext.os.is.Android && this.supportsOrientation()) {
            if (this.getWindowOrientation() % 180 === 0) {
                return b
            }
            return a
        } else {
            if (this.getWindowHeight() >= this.getWindowWidth()) {
                return b
            }
            return a
        }
    },
    onItemFullscreenChange: function(a) {
        a.addCls(this.fullscreenItemCls);
        this.add(a)
    },
    setMenu: function(f, a) {
        var b = this;
        a = a || {};
        if (Ext.os.is.iOS && !this.hasiOSOrientationFix) {
            this.hasiOSOrientationFix = true;
            this.on("orientationchange",
            function() {
                window.scrollTo(0, 0)
            },
            this)
        }
        if (!f) {
            return
        }
        if (!a.side) {
            return
        }
        if (["left", "right", "top", "bottom"].indexOf(a.side) == -1) {
            return
        }
        var e = b.getMenus();
        if (!e) {
            e = {}
        }
        if (!b.addedSwipeListener) {
            b.addedSwipeListener = true;
            b.element.on({
                tap: b.onTap,
                swipestart: b.onSwipeStart,
                edgeswipestart: b.onEdgeSwipeStart,
                edgeswipe: b.onEdgeSwipe,
                edgeswipeend: b.onEdgeSwipeEnd,
                scope: b
            });
            if (window.blackberry) {
                var d = function() {
                    var g = b.getMenus(),
                    h = g.top;
                    if (!h) {
                        return
                    }
                    if (h.isHidden()) {
                        b.showMenu("top")
                    } else {
                        b.hideMenu("top")
                    }
                };
                if (blackberry.app && blackberry.app.event && blackberry.app.event.onSwipeDown) {
                    blackberry.app.event.onSwipeDown(d)
                } else {
                    if (blackberry.event && blackberry.event.addEventListener) {
                        blackberry.event.addEventListener("swipedown", d)
                    }
                }
            }
        }
        e[a.side] = f;
        f.$reveal = Boolean(a.reveal);
        f.$cover = a.cover !== false && !f.$reveal;
        f.$side = a.side;
        b.fixMenuSize(f, a.side);
        if (a.side == "left") {
            f.setLeft(0);
            f.setRight(null);
            f.setTop(0);
            f.setBottom(0)
        } else {
            if (a.side == "right") {
                f.setLeft(null);
                f.setRight(0);
                f.setTop(0);
                f.setBottom(0)
            } else {
                if (a.side == "top") {
                    f.setLeft(0);
                    f.setRight(0);
                    f.setTop(0);
                    f.setBottom(null)
                } else {
                    if (a.side == "bottom") {
                        f.setLeft(0);
                        f.setRight(0);
                        f.setTop(null);
                        f.setBottom(0)
                    }
                }
            }
        }
        b.setMenus(e)
    },
    removeMenu: function(a) {
        var b = this.getMenus() || {},
        d = b[a];
        if (d) {
            this.hideMenu(a)
        }
        delete b[a];
        this.setMenus(b)
    },
    fixMenuSize: function(b, a) {
        if (a == "top" || a == "bottom") {
            b.setWidth("100%")
        } else {
            if (a == "left" || a == "right") {
                b.setHeight("100%")
            }
        }
    },
    showMenu: function(b) {
        var f = this.getMenus(),
        i = f[b],
        e,
        h,
        g,
        d;
        if (!i || i.isAnimating) {
            return
        }
        this.hideOtherMenus(b);
        e = {
            translateX: 0,
            translateY: 0
        };
        h = {
            translateX: 0,
            translateY: 0
        };
        g = {
            translateX: 0,
            translateY: 0
        };
        d = {
            translateX: 0,
            translateY: 0
        };
        if (i.$reveal) {
            Ext.getBody().insertFirst(i.element)
        } else {
            Ext.Viewport.add(i)
        }
        i.show();
        i.addCls("x-" + b);
        var a = (b == "left" || b == "right") ? i.element.getWidth() : i.element.getHeight();
        if (b == "left") {
            e.translateX = -a;
            d.translateX = a
        } else {
            if (b == "right") {
                e.translateX = a;
                d.translateX = -a
            } else {
                if (b == "top") {
                    e.translateY = -a;
                    d.translateY = a
                } else {
                    if (b == "bottom") {
                        e.translateY = a;
                        d.translateY = -a
                    }
                }
            }
        }
        if (i.$reveal) {
            if (Ext.browser.getPreferredTranslationMethod() != "scrollposition") {
                i.translate(0, 0)
            }
        } else {
            i.translate(e.translateX, e.translateY)
        }
        if (i.$cover) {
            i.getTranslatable().on("animationend",
            function() {
                i.isAnimating = false
            },
            this, {
                single: true
            });
            i.translate(h.translateX, h.translateY, {
                preserveEndState: true,
                duration: 200
            })
        } else {
            this.translate(g.translateX, g.translateY);
            this.getTranslatable().on("animationend",
            function() {
                i.isAnimating = false
            },
            this, {
                single: true
            });
            this.translate(d.translateX, d.translateY, {
                preserveEndState: true,
                duration: 200
            })
        }
        i.isAnimating = true
    },
    hideMenu: function(d, a) {
        var f = this.getMenus(),
        h = f[d],
        g,
        e,
        b;
        a = (a === false) ? false: true;
        if (!h || (h.isHidden() || h.isAnimating)) {
            return
        }
        g = {
            translateX: 0,
            translateY: 0
        };
        e = {
            translateX: 0,
            translateY: 0
        };
        b = (d == "left" || d == "right") ? h.element.getWidth() : h.element.getHeight();
        if (d == "left") {
            g.translateX = -b
        } else {
            if (d == "right") {
                g.translateX = b
            } else {
                if (d == "top") {
                    g.translateY = -b
                } else {
                    if (d == "bottom") {
                        g.translateY = b
                    }
                }
            }
        }
        if (h.$cover) {
            if (a) {
                h.getTranslatable().on("animationend",
                function() {
                    h.isAnimating = false;
                    h.hide()
                },
                this, {
                    single: true
                });
                h.translate(g.translateX, g.translateY, {
                    preserveEndState: true,
                    duration: 200
                })
            } else {
                h.translate(g.translateX, g.translateY);
                h.hide()
            }
        } else {
            if (a) {
                this.getTranslatable().on("animationend",
                function() {
                    h.isAnimating = false;
                    h.hide()
                },
                this, {
                    single: true
                });
                this.translate(e.translateX, e.translateY, {
                    preserveEndState: true,
                    duration: 200
                })
            } else {
                this.translate(e.translateX, e.translateY);
                h.hide()
            }
        }
    },
    hideAllMenus: function(d) {
        var b = this.getMenus();
        for (var a in b) {
            this.hideMenu(a, d)
        }
    },
    hideOtherMenus: function(a, d) {
        var b = this.getMenus();
        for (var e in b) {
            if (a != e) {
                this.hideMenu(e, d)
            }
        }
    },
    toggleMenu: function(a) {
        var b = this.getMenus(),
        d;
        if (b[a]) {
            d = b[a];
            if (d.isHidden()) {
                this.showMenu(a)
            } else {
                this.hideMenu(a)
            }
        }
    },
    sideForDirection: function(a) {
        if (a == "left") {
            return "right"
        } else {
            if (a == "right") {
                return "left"
            } else {
                if (a == "up") {
                    return "bottom"
                } else {
                    if (a == "down") {
                        return "top"
                    }
                }
            }
        }
    },
    sideForSwipeDirection: function(a) {
        if (a == "up") {
            return "top"
        } else {
            if (a == "down") {
                return "bottom"
            }
        }
        return a
    },
    onTap: function(a) {},
    onSwipeStart: function(b) {
        var a = this.sideForSwipeDirection(b.direction);
        this.hideMenu(a)
    },
    onEdgeSwipeStart: function(i) {
        var k = this.sideForDirection(i.direction),
        f = this.getMenus(),
        b = f[k],
        m,
        j;
        if (!b || !b.isHidden()) {
            return
        }
        for (m in f) {
            j = f[m];
            if (j.isHidden() !== false) {
                return
            }
        }
        this.$swiping = true;
        this.hideAllMenus(false);
        if (b.$reveal) {
            Ext.getBody().insertFirst(b.element)
        } else {
            Ext.Viewport.add(b)
        }
        b.show();
        var n = (k == "left" || k == "right") ? b.element.getWidth() : b.element.getHeight(),
        a,
        h;
        a = {
            translateX: 0,
            translateY: 0
        };
        h = {
            translateX: 0,
            translateY: 0
        };
        if (k == "left") {
            a.translateX = -n
        } else {
            if (k == "right") {
                a.translateX = n
            } else {
                if (k == "top") {
                    a.translateY = -n
                } else {
                    if (k == "bottom") {
                        a.translateY = n
                    }
                }
            }
        }
        var d = "webkitTransform" in document.createElement("div").style ? "webkitTransform": "transform",
        g = b.element.dom.style[d];
        if (g) {
            b.element.dom.style[d] = ""
        }
        if (b.$reveal) {
            if (Ext.browser.getPreferredTranslationMethod() != "scrollposition") {
                b.translate(0, 0)
            }
        } else {
            b.translate(a.translateX, a.translateY)
        }
        if (!b.$cover) {
            if (g) {
                this.innerElement.dom.style[d] = ""
            }
            this.translate(h.translateX, h.translateY)
        }
    },
    onEdgeSwipe: function(h) {
        var d = this.sideForDirection(h.direction),
        j = this.getMenus()[d];
        if (!j || !this.$swiping) {
            return
        }
        var b = (d == "left" || d == "right") ? j.element.getWidth() : j.element.getHeight(),
        i,
        g,
        a = Math.min(h.distance - b, 0),
        f = Math.min(h.distance, b);
        i = {
            translateX: 0,
            translateY: 0
        };
        g = {
            translateX: 0,
            translateY: 0
        };
        if (d == "left") {
            i.translateX = a;
            g.translateX = f
        } else {
            if (d == "right") {
                i.translateX = -a;
                g.translateX = -f
            } else {
                if (d == "top") {
                    i.translateY = a;
                    g.translateY = f
                } else {
                    if (d == "bottom") {
                        i.translateY = -a;
                        g.translateY = -f
                    }
                }
            }
        }
        if (j.$cover) {
            j.translate(i.translateX, i.translateY)
        } else {
            this.translate(g.translateX, g.translateY)
        }
    },
    onEdgeSwipeEnd: function(j) {
        var k = this.sideForDirection(j.direction),
        b = this.getMenus()[k],
        i = false;
        if (!b) {
            return
        }
        var m = (k == "left" || k == "right") ? b.element.getWidth() : b.element.getHeight(),
        g = (j.flick) ? j.flick.velocity: 0;
        if (k == "right") {
            if (g.x > 0) {
                i = true
            }
        } else {
            if (k == "left") {
                if (g.x < 0) {
                    i = true
                }
            } else {
                if (k == "top") {
                    if (g.y < 0) {
                        i = true
                    }
                } else {
                    if (k == "bottom") {
                        if (g.y > 0) {
                            i = true
                        }
                    }
                }
            }
        }
        var d = (i) ? m: 0,
        f = (i) ? 0 : -m,
        a,
        h;
        a = {
            translateX: 0,
            translateY: 0
        };
        h = {
            translateX: 0,
            translateY: 0
        };
        if (k == "left") {
            a.translateX = -d;
            h.translateX = -f
        } else {
            if (k == "right") {
                a.translateX = d;
                h.translateX = f
            } else {
                if (k == "top") {
                    a.translateY = -d;
                    h.translateY = -f
                } else {
                    if (k == "bottom") {
                        a.translateY = d;
                        h.translateY = f
                    }
                }
            }
        }
        if (b.$cover) {
            b.getTranslatable().on("animationend",
            function() {
                if (i) {
                    b.hide()
                }
            },
            this, {
                single: true
            });
            b.translate(a.translateX, a.translateY, {
                preserveEndState: true,
                duration: 200
            })
        } else {
            this.getTranslatable().on("animationend",
            function() {
                if (i) {
                    b.hide()
                }
            },
            this, {
                single: true
            });
            this.translate(h.translateX, h.translateY, {
                preserveEndState: true,
                duration: 200
            })
        }
        this.$swiping = false
    }
});
Ext.define("Ext.viewport.Android", {
    extend: Ext.viewport.Default,
    config: {
        translatable: {
            translationMethod: "csstransform"
        }
    },
    constructor: function() {
        this.on("orientationchange", "hideKeyboardIfNeeded", this, {
            prepend: true
        });
        this.callSuper(arguments);
        this.bodyElement.on("resize", this.onResize, this, {
            buffer: 1
        })
    },
    getWindowWidth: function() {
        return this.element.getWidth()
    },
    getWindowHeight: function() {
        return this.element.getHeight()
    },
    getDummyInput: function() {
        var a = this.dummyInput,
        d = this.focusedElement,
        b = Ext.fly(d).getPageBox();
        if (!a) {
            this.dummyInput = a = document.createElement("input");
            a.style.position = "absolute";
            a.style.opacity = "0";
            a.style.pointerEvents = "none";
            document.body.appendChild(a)
        }
        a.style.left = b.left + "px";
        a.style.top = b.top + "px";
        a.style.display = "";
        return a
    },
    doBlurInput: function(d) {
        var b = d.target,
        f = this.focusedElement,
        a;
        if (f && !this.isInputRegex.test(b.tagName)) {
            a = this.getDummyInput();
            delete this.focusedElement;
            a.focus();
            setTimeout(function() {
                a.style.display = "none"
            },
            100)
        }
    },
    hideKeyboardIfNeeded: function() {
        var a = arguments[arguments.length - 1],
        b = this.focusedElement;
        if (b) {
            delete this.focusedElement;
            a.pause();
            if (Ext.os.version.lt("4")) {
                b.style.display = "none"
            } else {
                b.blur()
            }
            setTimeout(function() {
                b.style.display = "";
                a.resume()
            },
            1000)
        }
    },
    doFireOrientationChangeEvent: function() {
        var a = arguments[arguments.length - 1];
        this.orientationChanging = true;
        a.pause();
        this.waitUntil(function() {
            return this.getWindowOuterHeight() !== this.windowOuterHeight
        },
        function() {
            this.windowOuterHeight = this.getWindowOuterHeight();
            this.updateSize();
            a.firingArguments[2] = this.windowWidth;
            a.firingArguments[3] = this.windowHeight;
            a.resume();
            this.orientationChanging = false
        },
        function() {});
        return this
    },
    determineOrientation: function() {
        return (this.getWindowHeight() >= this.getWindowWidth()) ? this.PORTRAIT: this.LANDSCAPE
    },
    getActualWindowOuterHeight: function() {
        return Math.round(this.getWindowOuterHeight() / window.devicePixelRatio)
    },
    maximize: function() {
        var d = this.stretchHeights,
        b = this.orientation,
        a;
        a = d[b];
        if (!a) {
            d[b] = a = this.getActualWindowOuterHeight()
        }
        if (!this.addressBarHeight) {
            this.addressBarHeight = a - this.getWindowHeight()
        }
        this.setHeight(a);
        var e = Ext.Function.bind(this.isHeightMaximized, this, [a]);
        this.scrollToTop();
        this.waitUntil(e, this.fireMaximizeEvent, this.fireMaximizeEvent)
    },
    isHeightMaximized: function(a) {
        this.scrollToTop();
        return this.getWindowHeight() === a
    },
    supportsOrientation: function() {
        return false
    },
    onResize: function() {
        this.waitUntil(function() {
            var d = this.windowWidth,
            g = this.windowHeight,
            f = this.getWindowWidth(),
            a = this.getWindowHeight(),
            e = this.getOrientation(),
            b = this.determineOrientation();
            return ((d !== f && g !== a) && e !== b)
        },
        function() {
            var b = this.getOrientation(),
            a = this.determineOrientation();
            this.fireOrientationChangeEvent(a, b)
        },
        Ext.emptyFn, 250)
    },
    doPreventZooming: function(b) {
        if ("button" in b && b.button !== 0) {
            return
        }
        var a = b.target;
        if (a && a.nodeType === 1 && !this.isInputRegex.test(a.tagName) && !this.focusedElement) {
            b.preventDefault()
        }
    }
},
function() {
    if (!Ext.os.is.Android) {
        return
    }
    var a = Ext.os.version,
    b = Ext.browser.userAgent,
    d = /(htc|desire|incredible|ADR6300)/i.test(b) && a.lt("2.3");
    if (d) {
        this.override({
            constructor: function(e) {
                if (!e) {
                    e = {}
                }
                e.autoMaximize = false;
                this.watchDogTick = Ext.Function.bind(this.watchDogTick, this);
                setInterval(this.watchDogTick, 1000);
                return this.callParent([e])
            },
            watchDogTick: function() {
                this.watchDogLastTick = Ext.Date.now()
            },
            doPreventPanning: function() {
                var f = Ext.Date.now(),
                g = this.watchDogLastTick,
                e = f - g;
                if (e >= 2000) {
                    return
                }
                return this.callParent(arguments)
            },
            doPreventZooming: function() {
                var f = Ext.Date.now(),
                g = this.watchDogLastTick,
                e = f - g;
                if (e >= 2000) {
                    return
                }
                return this.callParent(arguments)
            }
        })
    }
    if (a.match("2")) {
        this.override({
            onReady: function() {
                this.addWindowListener("resize", Ext.Function.bind(this.onWindowResize, this));
                this.callParent(arguments)
            },
            scrollToTop: function() {
                document.body.scrollTop = 100
            },
            onWindowResize: function() {
                var f = this.windowWidth,
                h = this.windowHeight,
                g = this.getWindowWidth(),
                e = this.getWindowHeight();
                if (this.getAutoMaximize() && !this.isMaximizing && !this.orientationChanging && window.scrollY === 0 && f === g && e < h && ((e >= h - this.addressBarHeight) || !this.focusedElement)) {
                    this.scrollToTop()
                }
            }
        })
    } else {
        if (a.gtEq("3.1")) {
            this.override({
                isHeightMaximized: function(e) {
                    this.scrollToTop();
                    return this.getWindowHeight() === e - 1
                }
            })
        } else {
            if (a.match("3")) {
                this.override({
                    isHeightMaximized: function() {
                        this.scrollToTop();
                        return true
                    }
                })
            }
        }
    }
    if (a.gtEq("4")) {
        this.override({
            doBlurInput: Ext.emptyFn
        })
    }
});
Ext.define("Ext.viewport.Ios", {
    extend: Ext.viewport.Default,
    isFullscreen: function() {
        return this.isHomeScreen()
    },
    isHomeScreen: function() {
        return window.navigator.standalone === true
    },
    constructor: function() {
        this.callParent(arguments);
        if (this.getAutoMaximize() && !this.isFullscreen()) {
            this.addWindowListener("touchstart", Ext.Function.bind(this.onTouchStart, this))
        }
    },
    maximize: function() {
        if (this.isFullscreen()) {
            return this.callParent()
        }
        var d = this.stretchHeights,
        b = this.orientation,
        e = this.getWindowHeight(),
        a = d[b];
        if (window.scrollY > 0) {
            this.scrollToTop();
            if (!a) {
                d[b] = a = this.getWindowHeight()
            }
            this.setHeight(a);
            this.fireMaximizeEvent()
        } else {
            if (!a) {
                a = this.getScreenHeight()
            }
            this.setHeight(a);
            this.waitUntil(function() {
                this.scrollToTop();
                return e !== this.getWindowHeight()
            },
            function() {
                if (!d[b]) {
                    a = d[b] = this.getWindowHeight();
                    this.setHeight(a)
                }
                this.fireMaximizeEvent()
            },
            function() {
                a = d[b] = this.getWindowHeight();
                this.setHeight(a);
                this.fireMaximizeEvent()
            },
            50, 1000)
        }
    },
    getScreenHeight: function() {
        return window.screen[this.orientation === this.PORTRAIT ? "height": "width"]
    },
    onElementFocus: function() {
        if (this.getAutoMaximize() && !this.isFullscreen()) {
            clearTimeout(this.scrollToTopTimer)
        }
        this.callParent(arguments)
    },
    onElementBlur: function() {
        if (this.getAutoMaximize() && !this.isFullscreen()) {
            this.scrollToTopTimer = setTimeout(this.scrollToTop, 500)
        }
        this.callParent(arguments)
    },
    onTouchStart: function() {
        if (this.focusedElement === null) {
            this.scrollToTop()
        }
    },
    scrollToTop: function() {
        window.scrollTo(0, 0)
    }
},
function() {
    if (!Ext.os.is.iOS) {
        return
    }
    if (Ext.os.version.lt("3.2")) {
        this.override({
            constructor: function() {
                var a = this.stretchHeights = {};
                a[this.PORTRAIT] = 416;
                a[this.LANDSCAPE] = 268;
                return this.callOverridden(arguments)
            }
        })
    }
    if (Ext.os.version.lt("5")) {
        this.override({
            fieldMaskClsTest: "-field-mask",
            doPreventZooming: function(b) {
                var a = b.target;
                if (a && a.nodeType === 1 && !this.isInputRegex.test(a.tagName) && a.className.indexOf(this.fieldMaskClsTest) == -1) {
                    b.preventDefault()
                }
            }
        })
    }
    if (Ext.os.is.iPad) {
        this.override({
            isFullscreen: function() {
                return true
            }
        })
    }
    if (Ext.os.version.gtEq("7")) {
        if (Ext.os.deviceType === "Tablet" || !Ext.browser.is.Safari || window.navigator.standalone) {
            this.override({
                constructor: function() {
                    var e = {},
                    b = {},
                    a = this.determineOrientation(),
                    g = window.screen.height,
                    d = window.screen.width,
                    f = a === this.PORTRAIT ? g - window.innerHeight: d - window.innerHeight;
                    e[this.PORTRAIT] = g - f;
                    e[this.LANDSCAPE] = d - f;
                    b[this.PORTRAIT] = d;
                    b[this.LANDSCAPE] = g;
                    this.stretchHeights = e;
                    this.stretchWidths = b;
                    this.callOverridden(arguments);
                    this.on("ready", this.setViewportSizeToAbsolute, this);
                    this.on("orientationchange", this.setViewportSizeToAbsolute, this)
                },
                getWindowHeight: function() {
                    return this.stretchHeights[this.orientation]
                },
                getWindowWidth: function() {
                    return this.stretchWidths[this.orientation]
                },
                setViewportSizeToAbsolute: function() {
                    this.setWidth(this.getWindowWidth());
                    this.setHeight(this.getWindowHeight())
                }
            })
        }
        if (Ext.os.deviceType === "Tablet") {
            this.override({
                constructor: function() {
                    this.callOverridden(arguments);
                    window.addEventListener("scroll",
                    function() {
                        if (window.scrollX !== 0) {
                            window.scrollTo(0, window.scrollY)
                        }
                    },
                    false)
                },
                setViewportSizeToAbsolute: function() {
                    window.scrollTo(0, 0);
                    this.callOverridden(arguments)
                },
                onElementBlur: function() {
                    this.callOverridden(arguments);
                    if (window.scrollY !== 0) {
                        window.scrollTo(0, 0)
                    }
                }
            })
        }
    }
});
Ext.define("Ext.viewport.WindowsPhone", {
    requires: [],
    alternateClassName: "Ext.viewport.WP",
    extend: Ext.viewport.Default,
    config: {
        translatable: {
            translationMethod: "csstransform"
        }
    },
    initialize: function() {
        var a = function(f) {
            var d = f.srcElement.nodeName.toUpperCase(),
            b = ["INPUT", "TEXTAREA"];
            if (b.indexOf(d) == -1) {
                return false
            }
        };
        document.body.addEventListener("onselectstart", a);
        this.callParent(arguments)
    },
    supportsOrientation: function() {
        return false
    },
    onResize: function() {
        this.waitUntil(function() {
            var d = this.windowWidth,
            g = this.windowHeight,
            f = this.getWindowWidth(),
            a = this.getWindowHeight(),
            e = this.getOrientation(),
            b = this.determineOrientation();
            return ((d !== f && g !== a) && e !== b)
        },
        function() {
            var b = this.getOrientation(),
            a = this.determineOrientation();
            this.fireOrientationChangeEvent(a, b)
        },
        Ext.emptyFn, 250)
    }
});
Ext.define("Ext.viewport.Viewport", {
    constructor: function(b) {
        var d = Ext.os.name,
        e, a;
        switch (d) {
        case "Android":
            e = (Ext.browser.name == "ChromeMobile") ? "Default": "Android";
            break;
        case "iOS":
            e = "Ios";
            break;
        case "Windows":
            e = (Ext.browser.name == "IE") ? "WindowsPhone": "Default";
            break;
        case "WindowsPhone":
            e = "WindowsPhone";
            break;
        default:
            e = "Default";
            break
        }
        a = Ext.create("Ext.viewport." + e, b);
        return a
    }
});
Ext.define("IBase.store.BaseStore", {
    extend: Ext.data.Store,
    config: {
        proxy: {
            timeout: 100000
        },
        listeners: {
            beforeload: function(a, d, b) {
                if (!a.getAutoLoad()) {
                    Ext.Viewport.setMasked({
                        xtype: "loadmask",
                        message: "加载中……",
                        indicator: true
                    })
                }
            },
            load: function(a, d, b) {
                Ext.Viewport.unmask()
            }
        }
    }
});
Ext.define("IBase.view.BaseView", {
    extend: Ext.Container,
    xtype: "baseview",
    config: {
        showAnimation: "fadeIn",
        hideAnimation: "fadeOut",
        tabBarPosition: "bottom",
        style: "width:95%"
    }
});
Ext.define("IBase.controller.BaseController", {
    extend: Ext.app.Controller,
    config: {},
    isNotOverride: function(a) {
        console.info(this.$className + "类中" + a + "函数未被实现，请确实是否需要实现！")
    },
    loadData: function(a) {
        console.log("base:" + arguments);
        this.isNotOverride("loadData")
    },
    refreshData: function() {
        this.isNotOverride("refreshData")
    },
    editData: function() {
        this.isNotOverride("editData")
    },
    removeData: function() {
        this.isNotOverride("removeData")
    },
    saveData: function(a) {
        this.isNotOverride("saveData")
    },
    initView: function(a) {
        this.isNotOverride("initView")
    },
    destroyView: function(a) {
        this.isNotOverride("destroyView")
    },
    isMeEvent: function(a) {
        this.isNotOverride("isMeEvent")
    },
    onScaned: function(a) {
        this.isNotOverride("onScaned")
    }
});
Ext.define("PacsClient.local.Global", {
    statics: {
        pacsPatientName: undefined,
        pacsPid: undefined,
        pacsStudyUid: undefined,
        pacsAccessNumber: undefined,
        pacsDataTime: undefined,
        currentSeriseUID: undefined,
        BufferArray: undefined,
        pacsOffLine: null,
        pacsBedNum: null,
        wsStr: null,
        recordsSuccess: [],
        writing: [],
        settingINI: null,
        useStudy: null,
        useAccessnumber: null,
        useStudyDateTime: true,
        iscover: null
    }
});
Ext.define("PacsClient.view.dicomviewer.PacsMainView", {
    extend: IBase.view.BaseView,
    xtype: "pacsmainview",
    config: {
        layout: "hbox",
        items: [{
            id: "pacsmaincanvas",
            cls: "pacsmainpanel",
            zIndex: 20,
            html: ["<canvas width=" + window.innerWidth + " height=" + (window.innerHeight - 5) + ">"].join(" ")
        },
        {
            id: "magnifierCanvas",
            cls: "magnifierCanvas",
            hidden: true,
            zIndex: 101,
            html: ["<canvas width=200 height=200 >"]
        },
        {
            xtype: "dataview",
            itemId: "pacscontrolpanel",
            baseCls: "pacs-tool",
            width: "5%",
            selectedCls: "pacs-item-selected",
            store: "pacsfnstore",
            zIndex: 100,
            itemTpl: ['<div class="pacs-tool-img"><image width="100%" src="{imagesrc}"></image></div>'].join("")
        },
        {
            xtype: "dataview",
            itemId: "smallPicStore",
            width: "10%",
            store: "thumbnaillist",
            baseCls: "pacs-list-main",
            scrollable: "vertical",
            itemCls: "pacsListItemSmall",
            zIndex: 21,
            itemTpl: ['<div class="pacs-tool-img-small"><image width="100%" src="data:image/png;base64,{ImgData}"></image><div color=write>{SeriesDateTime}</div></div>'].join(""),
            selectedCls: "pacs-canvas-selected",
            emptyText: "没有此病人的相关信息",
            loadingText: undefined
        },
        {
            xtype: "sliderfield",
            itemId: "sliderfieldPacs",
            minValue: 0,
            maxValue: 66,
            increment: 1,
            height: "50px",
            value: 0,
            hidden: true,
            zIndex: 21,
            cls: "pacs-slider-lucency"
        },
        {
            itemId: "btnRemove",
            xtype: "button",
            left: "95%",
            top: "88%",
            width: "30px",
            height: "30px",
            padding: "0px",
            zIndex: 21,
            icon: "resources/images/pacs/remove.png",
            hidden: true
        },
        {
            xtype: "sliderfield",
            itemId: "sliderScale",
            minValue: 50,
            maxValue: 200,
            increment: 1,
            value: 100,
            hidden: true,
            cls: "pacs-slider-lucency",
            height: "50px"
        }]
    }
});
Ext.define("PacsClient.controller.PacsWorkTools", {
    config: {},
    getPallet: function(b, a, h, f, g) {
        var i = [];
        var j = f - h;
        j = 256 / j;
        var e = 0;
        var d = h < b ? h: b;
        for (x = 0; x < d; x++) {
            i.push(0)
        }
        if (h < 0) {
            e = -j * h
        }
        d = f < b ? f: b;
        for (x = Math.max(h, 0); x < d; x++) {
            i.push(e | 0);
            e += j
        }
        for (x = Math.max(f, 0); x < b; x++) {
            i.push(255)
        }
        for (x = b; x < a; x++) {
            i.push(0)
        }
        if (g >= 0) {
            i[g] = 0
        }
        return i
    },
    getImg: function(d, h, b, f) {
        var k = b.length - 1;
        var e = d.height * d.width;
        var m;
        var j;
        if (d.data[3] == 255) {
            if (f) {
                for (var g = 0; g < e; ++g) {
                    j = g << 2;
                    m = 255 ^ b[k & h[g]];
                    d.data[j] = m;
                    d.data[j + 1] = m;
                    d.data[j + 2] = m
                }
            } else {
                for (var g = 0; g < e; ++g) {
                    j = g << 2;
                    if (h[g] < 0) {
                        console.log(g + "-----" + h[g])
                    }
                    m = b[k & h[g]];
                    d.data[j] = m;
                    d.data[j + 1] = m;
                    d.data[j + 2] = m
                }
            }
        } else {
            if (f) {
                for (var g = 0; g < e; ++g) {
                    j = g << 2;
                    m = 255 ^ b[k & h[g]];
                    d.data[j] = m;
                    d.data[j + 1] = m;
                    d.data[j + 2] = m;
                    d.data[j + 3] = 255
                }
            } else {
                for (var g = 0; g < e; ++g) {
                    j = g << 2;
                    m = b[k & h[g]];
                    d.data[j] = m;
                    d.data[j + 1] = m;
                    d.data[j + 2] = m;
                    d.data[j + 3] = 255
                }
            }
        }
        return d
    },
    getImgData: function(d, b) {
        for (var a = 0; a < d.data.length; a += 2) {
            b[a >> 1] = (d.data[a] << 8) + d.data[a + 1]
        }
        return b
    }
});
function setFileMetadataPath(b) {
    if (PacsClient.local.Global.pacsOffLine == "2") {
        return
    }
    var e = function(j) {
        j.createWriter(a, i)
    };
    var i = function() {};
    var h = function(j) {
        j.getFile("Msg.txt", {
            create: true,
            exclusive: false
        },
        e, i);
        j.getDirectory(b.PATIENT_ID, {
            create: true,
            exclusive: false
        })
    };
    var f = function(j) {};
    var a = function(j) {
        j.write(b.PATIENT_ID)
    };
    var d = function(j) {
        j.getDirectory(b.BED_NO, {
            create: true,
            exclusive: false
        },
        h, f)
    };
    var g = function(j) {
        j.root.getDirectory("pacs", {
            create: true,
            exclusive: false
        },
        d, f)
    };
    window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, g, f)
}
function findPatient(e) {
    if (PacsClient.local.Global.pacsOffLine == "2") {
        return
    }
    var g = function(h) {
        h.root.getFile("pacs/" + e.BED_NO + "/Msg.txt", null, f, d)
    };
    var f = function(h) {
        h.file(b, d)
    };
    var b = function(h) {
        a(h)
    };
    var a = function(i) {
        var h = new FileReader();
        h.onloadend = function(j) {
            if (j.target.result != e.PATIENT_ID) {
                setFileMetadataPath(e);
                removePatient(e.BED_NO + "/" + j.target.result)
            }
        };
        h.readAsText(i)
    };
    var d = function(h) {
        setFileMetadataPath(e)
    };
    window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, g, d)
}
function getFile() {
    function e(f) {
        var g;
        for (g = 0; g < f.length; g++) {
            alert(f[g].name)
        }
    }
    function a(f) {
        alert("Failed to list directory contents: " + f.code)
    }
    var b = function(g) {
        var f = g.createReader();
        f.readEntries(e, a)
    };
    var d = function(f) {
        entry = f.root.getDirectory("pacs", {
            create: true,
            exclusive: false
        },
        b, a)
    };
    window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, d, a)
}
function removePatient(h) {
    if (PacsClient.local.Global.pacsOffLine == "2") {
        return
    }
    function g(i) {}
    function a(i) {}
    var f = function(i) {
        i.removeRecursively(g, a)
    };
    var d = function(i) {
        console.log(i.code)
    };
    var b = function(i) {
        i.getDirectory(h, {
            create: true,
            exclusive: false
        },
        f, d)
    };
    var e = function(i) {
        newFile = i.root.getDirectory("pacs", {
            create: true,
            exclusive: false
        },
        b, d)
    };
    window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, e, d)
}
function writePacsData(a, d, e, b, j) {
    if (PacsClient.local.Global.pacsOffLine == "2") {
        return
    }
    var g = function(r) {
        r.createWriter(m, o)
    };
    var h = function(r) {
        r.createWriter(f, o)
    };
    var o = function() {};
    var n = function(r) {
        r.getFile(d + ".txt", {
            create: true,
            exclusive: false
        },
        g, o);
        r.getFile(d, {
            create: true,
            exclusive: false
        },
        h, o)
    };
    var i = function(r) {};
    var m = function(r) {
        r.onerror = function() {
            PacsClient.local.Global.writing[j] = false
        };
        r.onwriteend = function() {
            c = new Date()
        };
        r.write(b)
    };
    var f = function(r) {
        r.onerror = function() {
            PacsClient.local.Global.writing[j] = false
        };
        r.write(e)
    };
    var q = function(r) {
        r.getDirectory(a.PATIENT_ID, {
            create: true,
            exclusive: false
        },
        n, i)
    };
    var p = function(r) {
        r.getDirectory(a.BED_NO, {
            create: true,
            exclusive: false
        },
        q, i)
    };
    var k = function(r) {
        r.root.getDirectory("pacs", {
            create: true,
            exclusive: false
        },
        p, i)
    };
    window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, k, i)
}
function writePacsDataBlob(a, b, p, o, g) {
    if (PacsClient.local.Global.pacsOffLine == "2") {
        return
    }
    var d = function(q) {
        q.createWriter(i, k)
    };
    var e = function(q) {
        q.createWriter(gotFileDcm, k)
    };
    var k = function() {};
    var j = function(q) {
        q.getFile(b + ".txt", {
            create: true,
            exclusive: false
        },
        d, k)
    };
    var f = function(q) {};
    var i = function(q) {
        q.onerror = function() {
            PacsClient.local.Global.writing[g] = false
        };
        q.onwriteend = function() {
            var r = [];
            r[0] = "/pacs/" + a.BED_NO + "/" + a.PATIENT_ID;
            r[1] = b;
            r[2] = p;
            kyeeFileOperation.writeAsArrayBuffer(function() {},
            function() {
                PacsClient.local.Global.writing[g] = false
            },
            r)
        };
        q.write(o)
    };
    var n = function(q) {
        q.getDirectory(a.PATIENT_ID, {
            create: true,
            exclusive: false
        },
        j, f)
    };
    var m = function(q) {
        q.getDirectory(a.BED_NO, {
            create: true,
            exclusive: false
        },
        n, f)
    };
    var h = function(q) {
        q.root.getDirectory("pacs", {
            create: true,
            exclusive: false
        },
        m, f)
    };
    window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, h, f)
}
function deleJsonE(g, f) {
    var d = f.split(".");
    var h = 0,
    a = 0;
    for (var b = 0; b < d.length; b++) {
        h = g.indexOf(d[b], h + 1)
    }
    a = g.indexOf("]", h + d[d.length - 1].length + 3);
    return g.substring(0, h - 1) + g.substring(a + 2)
}
function readPacsDataBlob(b, e, h, a, k) {
    if (PacsClient.local.Global.pacsOffLine == "2") {
        k(h, e);
        return
    }
    var f = function(m) {
        m.root.getFile("pacs/" + b.BED_NO + "/" + b.PATIENT_ID + "/" + e, null, g, d)
    };
    var g = function(m) {
        m.file(j, d)
    };
    var i = function(m) {
        j(m)
    };
    var j = function(n) {
        var m = new FileReader();
        m.onloadend = function(o) {
            var p = PacsClient.local.Global.BufferArray[h].BitsAllocated;
            if (p == 8) {
                PacsClient.local.Global.BufferArray[h].ByteData = new Uint8Array(o.target.result)
            } else {
                PacsClient.local.Global.BufferArray[h].ByteData = new Uint16Array(o.target.result)
            }
            a(null, h)
        };
        m.readAsArrayBuffer(n)
    };
    var d = function(m) {
        k(h, e)
    };
    window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, f, d)
}
function readPacsData(b, e, i, a, k) {
    if (PacsClient.local.Global.pacsOffLine == "2") {
        k(i, e);
        return
    }
    var f = function(m) {
        m.root.getFile("pacs/" + b.BED_NO + "/" + b.PATIENT_ID + "/" + e, null, h, d)
    };
    var h = function(m) {
        m.file(j, d)
    };
    var j = function(m) {
        g(m)
    };
    var g = function(n) {
        var m = new FileReader();
        m.onloadend = function(q) {
            if (q.target.result != "") {
                var v = q.target.result;
                var u = PacsClient.local.Global.BufferArray[i].BitsAllocated;
                var p = PacsClient.local.Global.BufferArray[i].Height;
                var s = PacsClient.local.Global.BufferArray[i].Width;
                var t = p * s;
                if (u == 8) {
                    var o = new ArrayBuffer(t);
                    PacsClient.local.Global.BufferArray[i].ByteData = new Uint8Array(o);
                    for (var r = 0; r < t; r++) {
                        PacsClient.local.Global.BufferArray[i].ByteData[r] = v.charCodeAt(r)
                    }
                } else {
                    var o = new ArrayBuffer(t << 1);
                    PacsClient.local.Global.BufferArray[i].ByteData = new Uint16Array(o);
                    for (var r = 0; r < t; r++) {
                        PacsClient.local.Global.BufferArray[i].ByteData[r] = v.charCodeAt(r << 1) | (v.charCodeAt(r << 1 | 1) << 8)
                    }
                }
                a(q.target.result, i)
            } else {
                k(i, e)
            }
            q = null
        };
        m.readAsText(n)
    };
    var d = function(m) {
        k(i, e)
    };
    window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, f, d)
}
function findPacsFile(b, e, i, a, k) {
    if (PacsClient.local.Global.pacsOffLine == "2") {
        k(i, e);
        return
    }
    if (PacsClient.local.Global.writing[i]) {
        a(null, i);
        return
    }
    var f = function(m) {
        m.root.getFile("pacs/" + b.BED_NO + "/" + b.PATIENT_ID + "/" + e + ".txt", null, h, d)
    };
    var h = function(m) {
        m.file(j, d)
    };
    var j = function(m) {
        g(m)
    };
    var g = function(n) {
        var m = new FileReader();
        m.onloadend = function(o) {
            if (o.target.result != "") {
                setData(JSON.parse(o.target.result));
                a(o.target.result, i)
            } else {
                k(i, e)
            }
            o = null
        };
        m.readAsText(n)
    };
    var d = function(m) {
        k(i, e)
    };
    window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, f, d)
}
function readBlob(e, g, d) {
    var b;
    var h;
    var f;
    if (g.data instanceof Blob) {
        var a = new FileReader();
        a.onload = function(m) {
            var o = new Int32Array(m.target.result, 0, 1);
            var i = o[0];
            var j = g.data.slice(4, 4 + i);
            var n = g.data.slice(4 + i);
            var k = new FileReader();
            k.onload = function(r) {
                f = r.target.result;
                h = JSON.parse(f);
                b = h.PictureNumber;
                var q = h.SamplesPerPixel;
                if (e.seriesUID != h.SeriesUID) {
                    return
                }
                setData(h);
                if (q == 1) {
                    var p = new FileReader();
                    p.onload = function(s) {
                        PacsClient.local.Global.writing[b] = true;
                        if (PacsClient.local.Global.pacsOffLine == "1") {
                            writePacsDataBlob(e.patientMsg, h.InstanceUID, s.target.result, f, b)
                        }
                        if (PacsClient.local.Global.pacsOffLine == "2" || e.sliderIndex == b) {
                            if (PacsClient.local.Global.BufferArray[b].BitsAllocated == 8) {
                                PacsClient.local.Global.BufferArray[b].ByteData = new Uint8Array(s.target.result)
                            } else {
                                PacsClient.local.Global.BufferArray[b].ByteData = new Uint16Array(s.target.result)
                            }
                        }
                        setTimeout(function() {
                            d(b)
                        },
                        100)
                    };
                    p.readAsArrayBuffer(n)
                } else {
                    if (PacsClient.local.Global.pacsOffLine == "1") {
                        writePacsData(e.patientMsg, h.InstanceUID, null, f, b)
                    }
                    PacsClient.local.Global.BufferArray[b].ByteData = null;
                    setTimeout(function() {
                        d(b)
                    },
                    100)
                }
            };
            k.readAsText(j)
        };
        a.readAsArrayBuffer(g.data)
    }
}
function readString(d, e) {
    var a = JSON.parse(e.data);
    if (d.seriesUID != a.SeriesUID) {
        return
    }
    var b = a.PictureNumber;
    setData(a);
    PacsClient.local.Global.BufferArray[b] = a.RawPixels
}
function setData(d) {
    var b = d.PictureNumber;
    PacsClient.local.Global.recordsSuccess[b] = true;
    var a = [];
    if (d.PixelSpacing == null) {
        a[0] = 0;
        a[1] = 0
    } else {
        a = d.PixelSpacing
    }
    PacsClient.local.Global.BufferArray[b] = {
        Base64Img: d.Base64String,
        DcmLevel: d.WindowLevel,
        DcmWidth: d.WindowWidth,
        Height: d.Height,
        Width: d.Width,
        PatName: d.Name,
        Sex: d.Sex,
        SeriesUid: d.SeriesUID,
        InstanceUid: d.InstanceUID,
        StudyUid: d.StudyUID,
        BitsAllocated: d.BitsAllocated,
        HighBit: d.HighBit,
        BitsStored: d.BitsStored,
        RescaleIntercept: d.RescaleIntercept,
        RescaleSlope: d.RescaleSlope,
        PixelSpacingX: a[0],
        PixelSpacingY: a[1],
        LargestImagePixelValue: d.LargestImagePixelValue,
        SamplesPerPixel: d.SamplesPerPixel,
        PixelPaddingValue: d.PixelPaddingValue
    };
    a = null
}
function findMaxPiex(d) {
    var b = d.length;
    var a = 0;
    while (b--) {
        if (d[b] > a) {
            a = d[b]
        }
    }
    console.log(a);
    return a
}
function findMinPiex(d) {
    var b = d.length;
    var a = 3333;
    while (b--) {
        if (d[b] < a) {
            a = d[b]
        }
    }
    console.log(a);
    return a
}
Ext.define("PacsClient.controller.PacsController", {
    extend: IBase.controller.BaseController,
    config: {
        refs: {
            pacsMain: "pacsmainview",
            pacsImg: "#pacsmaincanvas",
            dataview: "pacsmainview #pacscontrolpanel",
            silderBtn: "pacsmainview #sliderfieldPacs",
            pacsPicList: "pacsmainview #smallPicStore",
            btnRemove: "pacsmainview #btnRemove",
            sliderSize: "pacsmainview #sliderScale",
            setButton: "pacsmainview #setButton",
            magnifier: "#magnifierCanvas"
        },
        studyUidNum: 0,
        seriecCount: -1,
        studyStore: [],
        lineDrawing: false,
        angleDrawing: false,
        magnifierleft: 0,
        magnifiertop: 0,
        magnifiercxt: null,
        MagnifierR: 0,
        useMagnifier: false,
        angleScale: null,
        angleX: null,
        angleY: null,
        angleSelected: null,
        angleSelectedPoint: null,
        angleArray: [],
        angleArrayL: [],
        angleTmpArray: null,
        angletmp: [],
        angleUsing: false,
        useSliderScale: false,
        padding: null,
        toolBarCanuse: true,
        sliderIndex: 0,
        doubleT: null,
        densityLength: 0,
        removePng: null,
        density: [],
        pixelSpacingX: 0,
        pixelSpacingY: 0,
        lineStrokeL: [],
        lineStroke: [],
        linetmp: [],
        imgTemp: null,
        winListView2: null,
        newPallet: false,
        calc: true,
        scale: 1,
        xMove: 0,
        yMove: 0,
        scaleX: 1,
        xX: 0,
        yX: 0,
        startX: 0,
        startY: 0,
        canvasHeight: 0,
        canvasWidth: 0,
        imageHeight: 0,
        imageWidth: 0,
        currentImageWidth: 0,
        currentImageHeight: 0,
        canvas: null,
        cxt: null,
        canvasTemp: null,
        cxtTemp: null,
        imgData: null,
        reverFlag: false,
        instanceJson: null,
        smallPic: null,
        seriesUID: "",
        instanceUIDList: null,
        currentW: 0,
        currentC: 0,
        bitsStored: 8,
        highBit: 8,
        rescaleIntercept: 0,
        rescaleSlope: 1,
        pallet: null,
        pacsWorkTools: null,
        temp: null,
        pacsStart: false,
        patientMsg: null,
        ws: [],
        sPicNum: null,
        adj: false,
        selectLine: -1,
        control: {
            sliderSize: {
                drag: "onSizeChanging",
                change: "onSizeChanging",
                show: "SliderSizeShow"
            },
            dataview: {
                itemtap: "itemtap"
            },
            silderBtn: {
                drag: "onSliderChange",
                dragstart: "onDragStart",
                change: "onChange",
                dragend: "onDragEnd"
            },
            pacsImg: {
                initialize: "initPacsImg"
            },
            magnifier: {
                initialize: "initMagnifier"
            },
            pacsPicList: {
                select: "onPacsPicListSelect"
            },
            btnRemove: {
                tap: function() {
                    if (this.selectLine >= 0) {
                        this.lineStroke.splice(this.selectLine, 4);
                        this.lineStrokeL.splice(this.selectLine, 4);
                        this.selectLine = -1;
                        this.drawImgMsg()
                    }
                    if (this.angleSelected.selected > -1) {
                        this.angleArray.splice(this.angleSelected.selected, 1);
                        this.angleSelected.selected = -1;
                        this.angleSelected.pos = -1;
                        this.drawImgMsg()
                    }
                }
            },
            setButton: {
                tap: function() {
                    var a = Ext.create("PacsClient.view.dicomviewer.PacsSetView", {
                        centered: true,
                        height: "50%",
                        width: "50%"
                    });
                    a.setZIndex(100);
                    Ext.Viewport.add(a);
                    a.show()
                }
            }
        }
    },
    dStart: function(f, b, h, a, g, d) {
        this.startX = g.pageX
    },
    itemtouchmove: function(g, d, i, b, h, f) {
        var a = h.pageX - this.startX;
        this.startX = h.pageX;
        this.startY = h.pageY;
        this.getDataview().setLeft(this.getDataview().getLeft() + a)
    },
    PacsMainInit: function() {
        this.doubleT = 0;
        if (false && PacsClient.local.Global.iscover != 0) {
            PacsClient.local.Global.pacsOffLine = 1;
            setTimeout(function() {
                kyeeCloseView.openSucceed(function(b) {
                    console.log("关闭PACS页面成功")
                },
                function(b) {
                    console.error("关闭PACS页面失败")
                },
                [])
            },
            2000)
        } else {
            PacsClient.local.Global.pacsOffLine = 2
        }
        if (PacsClient.local.Global.pacsOffLine == null) {
            var a = this;
            Ext.Msg.confirm("操作提示", "是否使用离线版本！",
            function(e, d, b) {
                if (e == "yes") {
                    PacsClient.local.Global.pacsOffLine = "1"
                } else {
                    PacsClient.local.Global.pacsOffLine = "2"
                }
                a.PacsStart()
            })
        } else {
            this.PacsStart()
        }
    },
    WSonOpenGet: function(b) {
        console.log("WSonOpen.OK " + b.currentTarget.socketnum);
        Ext.Viewport.setMasked({
            xtype: "loadmask",
            message: "影像资料转存中，请稍后！"
        });
        this.toolBarCanuse = false;
        var a = new Object();
        a.type = "getList";
        a.deviceAET = "";
        a.patientID = PacsClient.local.Global.pacsPid;
        if (PacsClient.local.Global.pacsStudyUid == null || PacsClient.local.Global.pacsStudyUid.length == 0) {
            a.studyUID = ""
        } else {
            a.studyUID = PacsClient.local.Global.pacsStudyUid
        }
        a.accessionNumber = PacsClient.local.Global.pacsAccessNumber;
        a.dateTime = PacsClient.local.Global.pacsDataTime;
        b.currentTarget.type = "getList";
        b.currentTarget.send(JSON.stringify(a));
        b.currentTarget.used = true
    },
    WSonOpen: function(f) {
        console.log("WSonOpen.OK " + f.target.socketnum);
        var a = f.target.canvas;
        if (a.studyStore == null || a.studyStore.length == 0) {
            return
        }
        if (f.target.socketnum == 0 && PacsClient.local.Global.BufferArray[a.sliderIndex] == null) {
            var d = new Object();
            var b = a.instanceUIDList[a.sliderIndex];
            d.pictureNumber = a.sliderIndex;
            d.devuid = "";
            d.patientID = PacsClient.local.Global.pacsPid;
            d.studyUID = a.studyStore[a.studyUidNum].StudyUID;
            d.seriesUID = b.Item1;
            d.instanceUID = b.Item2;
            PacsClient.local.Global.recordsSuccess[a.sliderIndex] = true;
            if (a.ws[0].binaryType == "blob") {
                d.type = "getDcm";
                a.ws[0].type = "getDcm"
            } else {
                d.type = "getDcmStr";
                a.ws[0].type = "getDcmStr"
            }
            a.ws[0].picNum = a.sliderIndex;
            a.ws[0].used = true;
            a.ws[0].send(JSON.stringify(d));
            a.ws[0].time = new Date()
        } else {
            if (a.instanceUIDList == null) {
                return
            }
            a.makeBufferRequest(a.sliderIndex)
        }
    },
    WSonMessage: function(d) {
        if (!d.target.canvas.pacsStart) {
            return
        }
        switch (d.target.type) {
        case "getList":
            var a = Ext.JSON.decode(d.data, true);
            if (a == null) {
                console.error("(getList) " + d.data + "---具体错误请查看后台日志！");
                Ext.Msg.alert("操作提示", "该报告影像不存在！",
                function(g, f, e) {
                    d.target.canvas.closePacs()
                });
                return
            }
            d.target.canvas.SendSMP1(a);
            break;
        case "getPic":
            var a = Ext.JSON.decode(d.data, true);
            d.target.canvas.SendSMP2(a);
            break;
        case "getDcm":
            if (d.data instanceof Blob) {
                if (d.target.socketnum == 0) {
                    readBlob(d.target.canvas, d,
                    function(e) {
                        d.target.canvas.makeBufferRequest(d.target.canvas.sliderIndex);
                        d.target.canvas.temp = PacsClient.local.Global.BufferArray[e].ByteData;
                        d.target.canvas.padding = PacsClient.local.Global.BufferArray[e].PixelPaddingValue;
                        d.target.canvas.putPicToCan(e, false)
                    })
                } else {
                    readBlob(d.target.canvas, d,
                    function(e) {
                        d.target.canvas.makeBufferRequest(d.target.canvas.sliderIndex);
                        d.target.canvas.drawProgressOne(e);
                        if (e == d.target.canvas.sliderIndex) {
                            d.target.canvas.putPicToCan(e, true)
                        } else {
                            d.target.canvas.putPicToCan(e, false)
                        }
                    })
                }
            } else {
                d.target.used = false
            }
            break;
        case "getDcmStr":
            var a = JSON.parse(d.data);
            if (d.target.canvas.seriesUID != a.SeriesUID) {
                return
            }
            var b = a.PictureNumber;
            setData(a);
            if (a.BitsAllocated == 8) {
                PacsClient.local.Global.BufferArray[b].ByteData = new Uint8Array(a.RawPixels)
            } else {
                PacsClient.local.Global.BufferArray[b].ByteData = new Uint16Array(a.RawPixels)
            }
            if (d.target.socketnum == 0) {
                d.target.canvas.makeBufferRequest(d.target.canvas.sliderIndex);
                d.target.canvas.temp = PacsClient.local.Global.BufferArray[b].ByteData;
                d.target.canvas.padding = PacsClient.local.Global.BufferArray[b].PixelPaddingValue
            } else {
                d.target.canvas.makeBufferRequest(d.target.canvas.sliderIndex);
                d.target.canvas.drawProgressOne(b)
            }
            d.target.canvas.putPicToCan(b, false);
            break
        }
        d.target.used = false
    },
    WSonClose: function(b) {
        if (this.ws === undefined) {
            this.ws = []
        }
        this.ws[b.target.socketnum] = b.target;
        console.log("Disconnect.", "OK");
        if (!b.target.canvas.pacsStart) {
            return
        }
        b.target.used = false;
        var a = b.target.canvas;
        setTimeout(function() {
            var e = b.target.socketnum;
            try {
                a.ws[e] = new WebSocket(PacsClient.local.Global.wsStr)
            } catch(d) {
                console.log(d, "ERROR " + e)
            }
            a.ws[e].canvas = a;
            a.ws[e].socketnum = e;
            a.ws[e].onopen = a.WSonOpen;
            a.ws[e].onmessage = a.WSonMessage;
            a.ws[e].onclose = a.WSonClose;
            a.ws[e].onerror = a.WSonError;
            a.ws[e].used = false;
            PacsClient.local.Global.recordsSuccess[b.target.picNum] = false
        },
        15000)
    },
    WSonError: function(a) {
        console.error("Disconnect", "ERROR");
        if (!a.target.canvas.pacsStart) {
            return
        }
        a.target.used = false
    },
    PacsStart: function() {
        this.ws = new Array();
        this.sPicNum = -1;
        try {
            this.ws[0] = new WebSocket(PacsClient.local.Global.wsStr)
        } catch(b) {
            console.log(b, "ERROR")
        }
        this.ws[0].canvas = this;
        this.ws[0].socketnum = 0;
        this.ws[0].onopen = this.WSonOpenGet;
        this.ws[0].onmessage = this.WSonMessage;
        this.ws[0].onclose = this.WSonClose;
        this.ws[0].onerror = this.WSonError;
        this.ws[0].used = false;
        for (var a = 1; a < 5; a++) {
            try {
                this.ws[a] = new WebSocket(PacsClient.local.Global.wsStr)
            } catch(b) {
                console.log(b, "ERROR " + a)
            }
            this.ws[a].canvas = this;
            this.ws[a].socketnum = a;
            this.ws[a].onopen = this.WSonOpen;
            this.ws[a].onmessage = this.WSonMessage;
            this.ws[a].onclose = this.WSonClose;
            this.ws[a].onerror = this.WSonError;
            this.ws[a].used = false
        }
        var d = this;
        var e = window.setInterval(function() {
            if (d.ws[0].time) {
                if (PacsClient.local.Global.BufferArray[d.sliderIndex] == null && new Date() - d.ws[0].time > 30000) {
                    d.ws[0].close()
                }
            }
        },
        10000)
    },
    SendSMP1: function(n) {
        var m = this;
        this.seriecCount = -1;
        this.studyStore = n;
        var k = this.getPacsPicList().getStore();
        for (var f = 0; f < this.studyStore.length; f++) {
            var a = this.studyStore[f];
            if (a.PatientID != "" && PacsClient.local.Global.pacsPid != a.PatientID) {
                PacsClient.local.Global.pacsPid = a.PatientID
            }
            var b = a.Thumbnails;
            for (var d = 0; d < b.length; d++) {
                k.add({
                    StudyUidNum: f,
                    SeriesUid: b[d].Item1,
                    InstanceUid: b[d].Item2
                })
            }
        }
        this.seriecCount++;
        if (k.getCount() == 0) {
            Ext.Msg.alert("操作提示", "该报告影像不存在！",
            function(o, j, i) {
                m.closePacs()
            });
            return
        }
        var h = k.getAt(this.seriecCount);
        var e = new Object();
        e.type = "getPic";
        e.devuid = "";
        e.patientID = PacsClient.local.Global.pacsPid;
        e.studyUID = this.studyStore[h.get("StudyUidNum")].StudyUID;
        e.seriesUID = h.get("SeriesUid");
        e.instanceUID = h.get("InstanceUid");
        this.ws[0].picNum = this.seriecCount;
        this.ws[0].type = "getPic";
        Ext.Viewport.setMasked({
            xtype: "loadmask",
            message: "缩略图列表加载中,请稍候!"
        });
        this.toolBarCanuse = false;
        var g = "";
        if (usePatient) {
            g = PacsClient.local.Global.pacsPid + "v1.032"
        } else {
            g = PacsClient.local.Global.pacsStudyUid[0] + "v1.032"
        }
        this.patientMsg = {
            PATIENT_ID: g,
            BED_NO: PacsClient.local.Global.pacsBedNum
        };
        findPatient(this.patientMsg);
        this.ws[0].send(JSON.stringify(e))
    },
    SendSMP2: function(a) {
        this.seriecCount++;
        var b = this.getPacsPicList().getStore();
        b.getAt(this.seriecCount - 1).set("ImgData", a.Data);
        if (seriesTimeVisiable) {
            b.getAt(this.seriecCount - 1).set("SeriesDateTime", a.DateTime)
        }
        if (this.seriecCount < b.data.length) {
            var d = b.getAt(this.seriecCount);
            var e = new Object();
            e.type = "getPic";
            e.picnum = this.seriecCount;
            e.devuid = "";
            e.patientID = PacsClient.local.Global.pacsPid;
            e.studyUID = this.studyStore[d.get("StudyUidNum")].StudyUID;
            e.seriesUID = d.get("SeriesUid");
            e.instanceUID = d.get("InstanceUid");
            this.ws[0].type = "getPic";
            this.ws[0].picNum = this.seriecCount;
            this.ws[0].used = true;
            this.ws[0].send(JSON.stringify(e))
        } else {
            if (b.data.length > 1) {
                this.makeBufferRequest(this.sliderIndex)
            }
        }
        if (this.seriecCount == 1) {
            this.getPacsPicList().select(0)
        }
    },
    SendINS: function(a, b) {
        Ext.Viewport.setMasked({
            xtype: "loadmask",
            message: "影像初始化中"
        });
        this.toolBarCanuse = false;
        if (this.ws[0].used) {
            return
        }
        PacsClient.local.Global.recordsSuccess[b] = true;
        var d = this;
        findPacsFile(d.patientMsg, a.Item2, b,
        function(e) {
            d.drawProgressOne(b);
            d.makeBufferRequest(d.sliderIndex);
            d.putPicToCan(b, true);
            e = null;
            result = null
        },
        function(g, e) {
            var f = new Object();
            f.pictureNumber = g;
            f.devuid = "";
            f.patientID = PacsClient.local.Global.pacsPid;
            f.studyUID = d.studyStore[d.studyUidNum].StudyUID;
            f.seriesUID = a.Item1;
            f.instanceUID = e;
            PacsClient.local.Global.recordsSuccess[g] = true;
            if (d.ws[0].binaryType == "blob") {
                f.type = "getDcm";
                d.ws[0].type = "getDcm"
            } else {
                f.type = "getDcmStr";
                d.ws[0].type = "getDcmStr"
            }
            d.ws[0].picNum = g;
            d.ws[0].used = true;
            d.ws[0].send(JSON.stringify(f));
            d.ws[0].time = new Date()
        })
    },
    initPacsImg: function() {
        this.angleUsing = false;
        this.angleArray = [];
        this.angleArrayL = [];
        this.angleTmpArray = [];
        this.pacsStart = true;
        var d = this.getPacsImg().innerElement.dom.querySelector("canvas");
        this.canvas = d;
        var e = d.height;
        var a = d.width;
        this.canvasHeight = e;
        this.canvasWidth = a;
        this.cxt = d.getContext("2d");
        this.cxt.strokeStyle = "white";
        this.cxt.lineWidth = 1;
        this.cxt.font = "1.2em sans-serif ";
        this.currentC = 128;
        this.currentW = 256;
        this.reverFlag = false;
        this.bitsStored = 8;
        this.highBit = 8;
        this.pacsWorkTools = Ext.create("PacsClient.controller.PacsWorkTools");
        var b = Ext.create("Ext.draw.engine.Canvas", {});
        this.canvasTemp = b.innerElement.dom.querySelector("canvas");
        this.cxtTemp = this.canvasTemp.getContext("2d");
        this.canvasTemp.height = e;
        this.canvasTemp.width = a;
        this.newPallet = true;
        this.removePng = new Image();
        this.removePng.src = "resources/images/pacs/remove.png";
        this.imgTemp = new Image();
        this.density = [];
        this.calc = true;
        this.useMagnifier = false;
        this.lineDrawing = false;
        this.angleDrawing = false;
        this.selectLine = -1;
        this.angleSelected = {
            selected: -1
        };
        this.angleSelected = {
            selected: -1,
            pos: -1
        };
        this.angleSelectedPoint = {
            x: -1,
            y: -1
        };
        if (navigator.userAgent.indexOf("Safari/534.57.2") > -1) {
            this.useSliderScale = true
        }
        this.PacsMainInit()
    },
    initMagnifier: function() {
        var a = window.innerHeight < window.innerWidth ? window.innerHeight: window.innerWidth;
        this.MagnifierR = a >> 2;
        var b = this.getMagnifier().innerElement.dom.querySelector("canvas");
        b.width = this.MagnifierR << 1;
        b.height = this.MagnifierR << 1;
        this.magnifierleft = 0;
        this.magnifiertop = 0;
        this.magnifiercxt = b.getContext("2d");
        this.magnifiercxt.lineWidth = 1.5;
        this.magnifiercxt.strokeStyle = "rgba(32,73,106,1)";
        this.magnifiercxt.clearRect(0, 0, b.width, b.height);
        this.magnifiercxt.beginPath();
        this.magnifiercxt.arc(this.MagnifierR, this.MagnifierR, this.MagnifierR, 0, 2 * Math.PI);
        this.magnifiercxt.stroke();
        this.magnifiercxt.clip();
        this.magnifiercxt.closePath();
        this.magnifiercxt.scale(2, 2)
    },
    onPacsPicListSelect: function(b, a) {
        if (this.useSliderScale) {
            this.getSliderSize().setHidden(true)
        }
        this.getDataview().select(0);
        var d = this.getPacsImg();
        this.toolNum = 0;
        d.element.clearListeners();
        d.element.on({
            touchstart: {
                fn: this.pageStart,
                scope: this
            },
            touchmove: {
                fn: this.pageMove,
                scope: this
            },
            touchend: {
                fn: this.pageMoveEnd,
                scope: this
            }
        });
        this.newPallet = true;
        this.reverFlag = false;
        this.studyUidNum = a.get("StudyUidNum");
        this.selectList(a.get("SeriesUid"))
    },
    selectList: function(a) {
        this.seriesUID = a;
        this.getInstanceUIDList(this.seriesUID);
        if (this.seriecCount == this.getPacsPicList().getStore().data.length) {
            this.SendINS(this.instanceUIDList[0], 0)
        } else {
            this.makeBufferRequest(0)
        }
    },
    getInstanceUIDList: function(a) {
        this.instanceUIDList = Ext.Array.filter(this.studyStore[this.studyUidNum].Instances,
        function(e) {
            if (e.Item1 == a) {
                return e
            }
        },
        this);
        this.instanceUIDList.sort(function(f, e) {
            if (f.Item2.length == e.Item2.length) {
                return f.Item2 < e.Item2 ? -1 : 1
            } else {
                if (f.Item2.length < e.Item2.length) {
                    return - 1
                } else {
                    return 1
                }
            }
        });
        var d = this.instanceUIDList.length;
        this.getSilderBtn().setMinValue(0);
        this.getSilderBtn().setMaxValue(d - 1);
        if (d > 1) {
            this.getSilderBtn().setHidden(false)
        } else {
            this.getSilderBtn().setHidden(true)
        }
        this.getSilderBtn().setValue(0);
        this.sliderIndex = 0;
        if (PacsClient.local.Global.BufferArray != null) {
            for (var b = 0; b < PacsClient.local.Global.BufferArray.length; b++) {
                PacsClient.local.Global.BufferArray[b] = null;
                PacsClient.local.Global.recordsSuccess[b] = null
            }
        }
        PacsClient.local.Global.BufferArray = null;
        PacsClient.local.Global.BufferArray = new Array();
        PacsClient.local.Global.BufferArray.length = d;
        PacsClient.local.Global.recordsSuccess = null;
        PacsClient.local.Global.recordsSuccess = new Array();
        PacsClient.local.Global.recordsSuccess.length = d;
        PacsClient.local.Global.writing = null;
        PacsClient.local.Global.writing = new Array();
        PacsClient.local.Global.writing.length = d
    },
    itemtap: function(j, f, g, d, h, i) {
        if (d.get("fnname") == "buttonExit") {
          
            var name = GetQueryString("fromurl");
			 window.location.href = name;
			
           // var reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)', 'i');
            //var r = window.location.search.substr(1).match(reg);
           // if (r != null&&r[2] == 3) {
			//	var j = window.location.search.substr(1).split('&')[1].split('=')[1];
            //}
            //if (r != null) {
            //    if(r[2]==3)
            //    {
            //        window.location.href = "http://10.0.0.105:8180/Web/Check.aspx?STARTTIME=" + j;
            //    }
//
            //else { window.location.href = "http://10.0.0.2:803/Web/Check.aspx"; }
           // }
           // else
           // {
        
           //     window.location.href = "http://10.0.0.2:803/Web/PationtInfos.aspx";
            //}


           
         

            //window.close();
            return;
         
            this.getSliderSize().setHidden(true);
            this.closePacs();
            
            return
        }
        if (this.winListView2 != null && this.winListView2.innerItems.length > 0) {
            this.winListView2.destroy()
        }
        var k = this.getPacsPicList().getStore();
        if (this.imgTemp == null) {
            Ext.Msg.alert("操作提示", "请先加载图片");
            return 0
        }
        this.calc = true;
        this.newPallet = false;
        this.selectLine = -1;
        this.angleSelected.selected = -1;
        this.getBtnRemove().setHidden(true);
        var b = this.getPacsImg();
        b.element.clearListeners();
        if (d.get("fnname") == "buttonPage") {
            this.outMsg(g, "翻页");
            this.toolNum = 0;
            this.drawProgress();
            var a = this.instanceUIDList.length;
            if (a > 1) {
                this.getSilderBtn().setHidden(false)
            } else {
                this.getSilderBtn().setHidden(true)
            }
            this.getSliderSize().setHidden(true);
            b.element.on({
                dragstart: {
                    fn: this.pageStart,
                    scope: this
                },
                drag: {
                    fn: this.pageMove,
                    scope: this
                },
                dragend: {
                    fn: this.pageMoveEnd,
                    scope: this
                }
            })
        } else {
            if (d.get("fnname") == "buttonReverse") {
                if (this.imgData == null) {
                    return
                }
                this.outMsg(g, "反色");
                this.toolNum = 1;
                this.getSliderSize().setHidden(true);
                this.getSilderBtn().setHidden(true);
                var b = this.getPacsImg();
                b.element.clearListeners();
                this.reverFlag = !this.reverFlag;
                this.invertImage()
            } else {
                if (d.get("fnname") == "buttonAdj") {
                    if (this.imgData == null) {
                        return
                    }
                    this.outSetWin(g);
                    this.toolNum = 2;
                    this.getSliderSize().setHidden(true);
                    this.getSilderBtn().setHidden(true);
                    this.newPallet = true;
                    b.element.on({
                        dragstart: {
                            fn: this.imageAdjStart,
                            scope: this
                        },
                        drag: {
                            fn: this.imageAdj,
                            scope: this
                        },
                        dragend: {
                            fn: this.imageAdjEnd,
                            scope: this
                        }
                    })
                } else {
                    if (d.get("fnname") == "buttonMeasure") {
                        if (PacsClient.local.Global.BufferArray[this.sliderIndex].PixelSpacingX == 0 || PacsClient.local.Global.BufferArray[this.sliderIndex].PixelSpacingY == 0) {
                            return
                        }
                        this.outLine(g);
                        this.angleUsing = false;
                        var j = this;
                        this.toolNum = 3;
                        this.getSliderSize().setHidden(true);
                        this.getSilderBtn().setHidden(true);
                        b.element.on({
                            dragstart: {
                                fn: j.drawStartFun,
                                scope: j
                            },
                            dragend: {
                                fn: j.drawEndFun,
                                scope: j
                            },
                            drag: {
                                fn: j.drawFun,
                                scope: j
                            }
                        })
                    } else {
                        if (d.get("fnname") == "buttonReset") {
                            this.outMsg(g, "刷新");
                            this.newPallet = true;
                            this.reverFlag = false;
                            this.getSliderSize().setHidden(true);
                            this.changePicBuffer(this.sliderIndex);
                            this.drawImgMsg()
                        } else {
                            if (d.get("fnname") == "buttonScale") {
                                this.outMsg(g, "移动<br/>缩放");
                                this.toolNum = 5;
                                if (this.useSliderScale) {
                                    this.getSliderSize().setHidden(false)
                                }
                                this.getSilderBtn().setHidden(true);
                                var j = this;
                                b.element.on({
                                    pinchstart: {
                                        fn: this.pinchStartFun,
                                        scope: this
                                    },
                                    pinch: {
                                        fn: this.pinchFun,
                                        scope: this
                                    },
                                    pinchend: {
                                        fn: this.pinchEndFun,
                                        scope: this
                                    },
                                    dragstart: {
                                        fn: this.dragStartFun,
                                        scope: this
                                    },
                                    dragend: {
                                        fn: this.dragEndFun,
                                        scope: this
                                    },
                                    drag: {
                                        fn: this.dragFun,
                                        scope: this
                                    }
                                })
                            } else {
                                if (d.get("fnname") == "buttonAngle") {
                                    this.outLineAngle(g);
                                    this.toolNum = 6;
                                    var j = this;
                                    this.getSliderSize().setHidden(true);
                                    this.getSilderBtn().setHidden(true);
                                    b.element.on({
                                        dragstart: {
                                            fn: j.angleDragStart,
                                            scope: j
                                        },
                                        drag: {
                                            fn: j.angleDraging,
                                            scope: j
                                        },
                                        dragend: {
                                            fn: j.angleDragEnd,
                                            scope: j
                                        }
                                    })
                                }
                            }
                        }
                    }
                }
            }
        }
        if (window.innerHeight != this.canvasHeight || window.innerWidth != this.canvasWidth) {
            this.reStarCanvans();
            this.drawImgMsg()
        }
    },
    angleDragStart: function(g, d, f) {
        var a = this.cxt;
        if (this.winListView2.innerItems.length > 0) {
            this.winListView2.destroy()
        }
        this.startX = g.startX;
        this.startY = g.startY;
        this.cxt.beginPath();
        a.strokeStyle = "rgba(0,255,255,1)";
        a.lineWidth = 3;
        this.cxt.moveTo(this.startX, this.startY);
        var b = new Object();
        b.X = g.startX;
        b.Y = g.startY;
        this.angleTmpArray = [];
        this.angleTmpArray.push(b);
        this.angleDrawing = true;
        this.angletmp = [(this.startX - this.xMove) / this.scale, (this.startY - this.yMove) / this.scale]
    },
    angleDraging: function(d, a, b) {
        this.angleTmpArray.push({
            X: d.pageX,
            Y: d.pageY
        });
        this.cxt.lineTo(d.pageX, d.pageY);
        this.cxt.stroke();
        this.angletmp.push((d.pageX - this.xMove) / this.scale, (d.pageY - this.yMove) / this.scale);
        this.drawMagnifier(d.pageX, d.pageY)
    },
    angleDragEnd: function(j, b, f) {
        this.angleDrawing = false;
        var p = this.cxt;
        p.closePath();
        this.removeShake();
        var k = 0;
        var r = 0;
        var a = this.angleTmpArray.length - 1;
        if (this.angleTmpArray.length < 6) {
            this.angleTmpArray = [];
            this.getMagnifier().setHidden(true);
            this.drawImgMsg();
            return
        }
        for (var g = 1; g < a; g++) {
            var n = this.angleTmpArray[g - 1];
            var m = this.angleTmpArray[g];
            var h = this.angleTmpArray[g + 1];
            var o = (m.X - j.pageX) * (m.X - j.pageX) + (m.Y - j.pageY) * (m.Y - j.pageY);
            if (o < 625) {
                continue
            }
            var o = (m.X - this.angleTmpArray[0].X) * (m.X - this.angleTmpArray[0].X) + (m.Y - this.angleTmpArray[0].Y) * (m.Y - this.angleTmpArray[0].Y);
            if (o < 625) {
                continue
            }
            var t = this.getAngleValue(m.X - n.X, n.Y - m.Y);
            var s = this.getAngleValue(h.X - m.X, m.Y - h.Y);
            var q = s - t;
            q = q > 0 ? q: -q;
            if (q > Math.PI) {
                q = Math.PI * 2 - q
            }
            if (q > k) {
                k = q;
                r = g
            }
        }
        if (r == 0) {
            this.angleTmpArray = [];
            this.drawImgMsg();
            return
        }
        var d = [this.angleTmpArray[0].X, this.angleTmpArray[0].Y, this.angleTmpArray[r].X, this.angleTmpArray[r].Y, j.pageX, j.pageY];
        this.angleArray.push(d);
        this.angleArrayL.push([(d[0] - this.xMove) / this.scale, (d[1] - this.yMove) / this.scale, (d[2] - this.xMove) / this.scale, (d[3] - this.yMove) / this.scale, (d[4] - this.xMove) / this.scale, (d[5] - this.yMove) / this.scale]);
        this.getMagnifier().setHidden(true);
        this.drawImgMsg()
    },
    removeShake: function() {
        var e = 0;
        var f = 50;
        while (e < this.angleTmpArray.length - 1) {
            var b = this.angleTmpArray[e];
            for (var d = e + 1; d < this.angleTmpArray.length; d++) {
                var a = this.angleTmpArray[d];
                if (b.X - f < a.X && b.X + f > a.X && b.Y - f < a.Y && b.Y + f > a.Y) {
                    this.angleTmpArray.splice(d, 1)
                }
            }
            e++
        }
    },
    drawAngle: function() {
        var a = this.cxt;
        a.strokeStyle = "rgba(0,255,255,1)";
        a.fillStyle = "rgba(255,0,120,1)";
        a.lineWidth = 3;
        a.lineCap = "round";
        a.font = "1.2em sans-serif";
        var e = false;
        a.beginPath();
        for (var d = 0; d < this.angleArray.length; d++) {
            if (d != this.angleSelected.selected) {
                this.drawOneAngle(a, d)
            }
        }
        a.stroke();
        a.closePath();
        a.beginPath();
        a.strokeStyle = "rgba(55,255,0,1)";
        if (this.angleSelected.selected > -1) {
            this.drawOneAngle(a, this.angleSelected.selected);
            var b = this.angleArray[this.angleSelected.selected];
            for (var d = 0; d < b.length; d += 2) {
                a.moveTo(b[d] + 5, b[d + 1]);
                a.arc(b[d], b[d + 1], 5, 0, Math.PI * 2, false)
            }
        }
        a.stroke();
        a.closePath();
        a.lineCap = "butt";
        a = null
    },
    drawOneAngle: function(p, n) {
        var g = this.angleArray[n];
        var b, a, o, k, h, d;
        var j = this.getAngleValue(g[0] - g[2], g[3] - g[1]);
        b = j;
        j = Math.PI * 2 - j;
        var f = this.getAngleValue(g[4] - g[2], g[3] - g[5]);
        a = f;
        f = Math.PI * 2 - f;
        if (j > f) {
            var m = f;
            f = j;
            j = m
        }
        if ((f - j) > Math.PI) {
            var m = f;
            f = j;
            j = m
        }
        if (b > a) {
            var m = b;
            b = a;
            a = m
        }
        o = (a - b) / 2 + b;
        if ((a - b) < Math.PI) {
            o = o > Math.PI ? o - Math.PI: o + Math.PI
        }
        k = Math.cos(o) * 15 + g[2];
        h = g[3] - Math.sin(o) * 15;
        d = a - b;
        if (d > Math.PI) {
            d = 2 * Math.PI - d
        }
        d /= (Math.PI * 2);
        d *= 360;
        if (o > Math.PI * 0.75 && o < Math.PI * 1.25) {
            k -= 30
        }
        for (var e = 2; e < g.length - 2; e += 2) {
            p.moveTo(g[e], g[e + 1]);
            p.arc(g[e], g[e + 1], 20, j, f, false)
        }
        p.moveTo(g[0], g[1]);
        p.lineTo(g[2], g[3]);
        p.lineTo(g[4], g[5]);
        p.fillText(Math.floor(d) + "°", k, h)
    },
    getAngleValue: function(b, g) {
        var f = 1.57;
        var e = 3.14;
        var d = 4.71;
        var a = Math.abs(g) / Math.sqrt(b * b + g * g);
        a = Math.asin(a);
        if (b == 0) {
            a = g > 0 ? f: d
        } else {
            if (g == 0) {
                a = b > 0 ? 0 : e
            } else {
                if (b < 0 && g > 0) {
                    a = e - a
                } else {
                    if (b < 0 && g < 0) {
                        a = e + a
                    } else {
                        if (b > 0 && g < 0) {
                            a = 6.28 - a
                        }
                    }
                }
            }
        }
        return a
    },
    moveAngle: function(b, a) {
        for (var f = 0; f < this.angleArray.length; f++) {
            var e = this.angleArray[f];
            for (var d = 0; d < e.length; d += 2) {
                e[d] += b;
                e[d + 1] += a
            }
        }
    },
    scaleAngle: function() {
        for (var e = 0; e < this.angleArrayL.length; e++) {
            var d = this.angleArray[e];
            var a = this.angleArrayL[e];
            for (var b = 0; b < d.length; b += 2) {
                d[b] = a[b] * this.scale + this.xMove;
                d[b + 1] = a[b + 1] * this.scale + this.yMove
            }
        }
    },
    outLineAngle: function(d) {
        var b = this;
        this.angleUsing = false;
        var a = Ext.create("Ext.DataView", {
            store: {
                fields: ["name", "msg"],
                data: [{
                    name: "绘制量角器"
                },
                {
                    name: "修改量角器"
                }]
            },
            height: "100%",
            itemTpl: '<div class="winList">{name}</div>',
            selectedCls: "winList-Select",
            listeners: {
                select: function(f, e) {
                    switch (e.get("name")) {
                    case "绘制量角器":
                        break;
                    case "修改量角器":
                        var g = b.getPacsImg();
                        g.element.clearListeners();
                        g.element.on({
                            touchstart: {
                                fn: b.angleTouchS,
                                scope: b
                            },
                            touchmove: {
                                fn: b.angleTouchM,
                                scope: b
                            },
                            touchend: {
                                fn: b.angleTouchE,
                                scope: b
                            }
                        });
                        break
                    }
                    setTimeout(function() {
                        b.winListView2.destroy()
                    },
                    500)
                }
            }
        });
        this.winListView2 = Ext.create("Ext.Panel", {
            width: 75,
            height: 62
        });
        this.winListView2.add(a);
        this.winListView2.showBy(d, "tr-cl")
    },
    angleTouchS: function(d) {
        this.startX = d.pageX;
        this.startY = d.pageY;
        if (this.angleSelected.selected > -1 && this.beforeAngle(this.angleSelected.selected, this.startX, this.startY)) {
            var b = this.angleArray[this.angleSelected.selected];
            this.angleSelected.pos = b.length >> 1;
            for (var a = 0; a < b.length >> 1; a++) {
                if ((d.pageX - b[a << 1]) * (d.pageX - b[a << 1]) + (d.pageY - b[a * 2 + 1]) * (d.pageY - b[a * 2 + 1]) < 625) {
                    this.angleSelected.pos = a
                }
            }
        } else {
            this.findAngle(d.pageX, d.pageY)
        }
        this.drawImgMsg()
    },
    beforeAngle: function(b, a, f) {
        var e = this.angleArray[b];
        for (var d = 0; d < e.length - 2; d += 2) {
            if (this.scalcDistance(e[d], e[d + 1], e[d + 2], e[d + 3], a, f)) {
                return true
            }
        }
        return false
    },
    findAngle: function(a, g) {
        this.angleSelected = {
            selected: -1,
            pos: -1
        };
        for (var e = 0; e < this.angleArray.length; e++) {
            var d = this.angleArray[e];
            var f = false;
            for (var b = 0; b < d.length - 2; b += 2) {
                if (this.scalcDistance(d[b], d[b + 1], d[b + 2], d[b + 3], a, g)) {
                    this.angleSelected = {
                        selected: e,
                        pos: d.length >> 1
                    }
                }
            }
            for (var b = 0; b < d.length; b += 2) {
                if ((a - d[b]) * (a - d[b]) + (g - d[b + 1]) * (g - d[b + 1]) < 625) {
                    this.angleSelected = {
                        selected: e,
                        pos: b >> 1
                    };
                    return
                }
            }
        }
    },
    angleTouchM: function(g) {
        var a = this.angleSelected.selected;
        var h = this.angleSelected.pos;
        if (this.angleSelected.selected != -1) {
            if (h < this.angleArray[a].length >> 1) {
                this.angleArray[a][h * 2 + 1] = g.pageY;
                this.angleArray[a][h * 2] = g.pageX;
                this.angleArrayL[a][h * 2] = (g.pageX - this.xMove) / this.scale;
                this.angleArrayL[a][h * 2 + 1] = (g.pageY - this.yMove) / this.scale
            } else {
                var d = this.startX - g.pageX;
                var b = this.startY - g.pageY;
                for (var f = 0; f < this.angleArray[a].length; f += 2) {
                    this.angleArray[a][f] -= d;
                    this.angleArray[a][f + 1] -= b;
                    this.angleArrayL[a][f] = (this.angleArray[a][f] - this.xMove) / this.scale;
                    this.angleArrayL[a][f + 1] = (this.angleArray[a][f + 1] - this.yMove) / this.scale
                }
                this.startX = g.pageX;
                this.startY = g.pageY
            }
            this.drawImgMsg();
            this.drawMagnifier(g.pageX, g.pageY)
        }
    },
    angleTouchE: function(a) {
        this.getMagnifier().setHidden(true)
    },
    outMsg: function(b, d) {
        var a = Ext.create("Ext.Panel", {
            html: d
        });
        a.showBy(b, "cr-cl");
        setTimeout(function() {
            a.destroy()
        },
        2000)
    },
    outSetWin: function(d) {
        var b = this;
        var a = Ext.create("Ext.DataView", {
            store: {
                fields: ["name", "msg", "W", "L"],
                data: [{
                    name: "默认",
                    msg: "",
                    W: -1,
                    L: 1
                },
                {
                    name: "LUNG",
                    msg: "窗宽:1500 窗位:-600",
                    W: 1500,
                    L: -600
                },
                {
                    name: "LIECER",
                    msg: "窗宽:150 窗位:88",
                    W: 150,
                    L: 88
                },
                {
                    name: "SOFT",
                    msg: "窗宽:350 窗位:70",
                    W: 350,
                    L: 70
                },
                {
                    name: "BONE",
                    msg: "窗宽:2000 窗位:500",
                    W: 2000,
                    L: 500
                },
                {
                    name: "111",
                    msg: "窗宽:800 窗位:300",
                    W: 800,
                    L: 300
                }]
            },
            height: "100%",
            itemTpl: '<div class="winList">{name}:{msg}</div>',
            selectedCls: "winList-Select",
            listeners: {
                select: function(f, e) {
                    w = e.get("W");
                    l = e.get("L");
                    if (w > 0) {
                        b.currentW = w;
                        b.currentC = l;
                        b.imageDataConvert(b.temp)
                    } else {
                        if (l == 1) {
                            b.currentW = PacsClient.local.Global.BufferArray[b.sliderIndex].DcmWidth;
                            b.currentC = PacsClient.local.Global.BufferArray[b.sliderIndex].DcmLevel;
                            b.imageDataConvert(b.temp)
                        } else {
                            b.currentW = PacsClient.local.Global.BufferArray[b.sliderIndex].LargestImagePixelValue;
                            b.currentC = PacsClient.local.Global.BufferArray[b.sliderIndex].LargestImagePixelValue >> 1;
                            b.imageDataConvert(b.temp)
                        }
                    }
                    setTimeout(function() {
                        b.winListView2.destroy()
                    },
                    500)
                }
            }
        });
        this.winListView2 = Ext.create("Ext.Panel", {
            width: 160,
            height: 204
        });
        this.winListView2.add(a);
        this.winListView2.showBy(d, "tr-cl")
    },
    outLine: function(d) {
        var b = this;
        var a = Ext.create("Ext.DataView", {
            store: {
                fields: ["name", "msg"],
                data: [{
                    name: "绘制测量线"
                },
                {
                    name: "修改测量线"
                }]
            },
            height: "100%",
            itemTpl: '<div class="winList">{name}</div>',
            selectedCls: "winList-Select",
            listeners: {
                select: function(f, e) {
                    switch (e.get("name")) {
                    case "绘制测量线":
                        break;
                    case "修改测量线":
                        var g = b.getPacsImg();
                        g.element.clearListeners();
                        g.element.on({
                            touchstart: {
                                fn: b.modifyStartFun,
                                scope: b
                            },
                            touchend: {
                                fn: b.modifyEndFun,
                                scope: b
                            },
                            touchmove: {
                                fn: b.modifyFun,
                                scope: b
                            }
                        })
                    }
                    setTimeout(function() {
                        b.winListView2.destroy()
                    },
                    500)
                }
            }
        });
        this.winListView2 = Ext.create("Ext.Panel", {
            width: 75,
            height: 62
        });
        this.winListView2.add(a);
        this.winListView2.showBy(d, "tr-cl")
    },
    pageStart: function(b, a) {
        this.startX = b.pageX
    },
    pageMove: function(b, a) {
        this.currentX = b.pageX
    },
    pagetTap: function(b, a) {
        console.log(b)
    },
    pageMoveEnd: function(b, a) {
        if (this.currentX > this.startX + 20) {
            this.pageMoveLeft()
        } else {
            if (this.currentX < this.startX - 20) {
                this.pageMoveRight()
            } else {
                if (b.pageX >= this.canvasWidth / 2) {
                    this.pageMoveRight()
                } else {
                    this.pageMoveLeft()
                }
            }
        }
    },
    play: function() {
        var a = this;
        this.calc = false;
        this.time = window.setInterval(function() {
            a.pageMoveRight()
        },
        40)
    },
    pageMoveLeft: function() {
        this.calc = true;
        this.sliderIndex = this.sliderIndex - 1;
        if (this.sliderIndex < 0) {
            this.sliderIndex = 0
        } else {
            this.getSilderBtn().setValue(this.sliderIndex);
            this.changePicBuffer(this.sliderIndex)
        }
    },
    pageMoveRight: function() {
        this.calc = true;
        this.sliderIndex = this.sliderIndex + 1;
        if (this.sliderIndex > this.instanceUIDList.length - 1) {
            this.sliderIndex = this.instanceUIDList.length - 1
        } else {
            this.getSilderBtn().setValue(this.sliderIndex);
            this.changePicBuffer(this.sliderIndex)
        }
    },
    changePicBuffer: function(a) {
        var b = PacsClient.local.Global.BufferArray[a];
        if (b == null) {
            if (this.seriecCount == this.getPacsPicList().getStore().data.length) {
                this.SendINS(this.instanceUIDList[a], a)
            } else {
                this.makeBufferRequest(this.sliderIndex)
            }
        } else {
            this.putPicToCan(a, true)
        }
    },
    onChange: function(e, a, f, b, d) {
        this.calc = true;
        if (this.sliderIndex != b) {
            this.sliderIndex = b;
            this.calc = true;
            this.changePicBuffer(b)
        }
    },
    onDragStart: function(f, a, b, g, h, d) {
        this.sliderIndex = g
    },
    onSliderChange: function(h, b, f, i, g) {
        var d = this.sliderIndex;
        this.sliderIndex = i[0];
        if (d != i[0]) {
            this.calc = false;
            this.changePicBuffer(i[0])
        }
    },
    onDragEnd: function(d, a, f, g, b) {
        this.sliderIndex = g[0];
        this.calc = true;
        this.changePicBuffer(g[0])
    },
    makeBufferRequest: function(d) {
        var k = 0;
        for (var e = d; e < this.instanceUIDList.length; e++) {
            k = e;
            if (PacsClient.local.Global.BufferArray[e] == null) {
                break
            }
        }
        var h = this.instanceUIDList.length;
        for (var e = 0,
        b = 0; e < h && b < 4; e++) {
            var a = (e + k) % h;
            if (PacsClient.local.Global.BufferArray[a] == null) {
                b++
            }
            if (PacsClient.local.Global.recordsSuccess[a]) {
                continue
            }
            PacsClient.local.Global.recordsSuccess[a] = true;
            var g = this.instanceUIDList[a];
            var f = this;
            findPacsFile(f.patientMsg, g.Item2, a,
            function(i, j) {
                f.drawProgressOne(j);
                if (j == f.sliderIndex) {
                    f.putPicToCan(j, true)
                }
                f.makeBufferRequest(f.sliderIndex)
            },
            function(n, j) {
                var o = false;
                for (var i = 1; i < f.ws.length; i++) {
                    if (!f.ws[i].used && f.ws[i].readyState == 1) {
                        if (f.seriecCount == f.getPacsPicList().getStore().data.length || n == f.sliderIndex) {
                            if (PacsClient.local.Global.BufferArray[n] == null) {
                                if (n == f.sliderIndex) {
                                    Ext.Viewport.setMasked({
                                        xtype: "loadmask",
                                        message: "影像初始化中"
                                    })
                                }
                                f.ws[i].used = true;
                                var m = new Object();
                                m.pictureNumber = n;
                                m.devuid = "";
                                m.patientID = PacsClient.local.Global.pacsPid;
                                m.studyUID = f.studyStore[f.studyUidNum].StudyUID;
                                m.seriesUID = g.Item1;
                                m.instanceUID = j;
                                PacsClient.local.Global.recordsSuccess[n] = true;
                                if (f.ws[i].binaryType == "blob") {
                                    m.type = "getDcm";
                                    f.ws[i].type = "getDcm"
                                } else {
                                    m.type = "getDcmStr";
                                    f.ws[i].type = "getDcmStr"
                                }
                                f.ws[i].picNum = n;
                                f.ws[i].send(JSON.stringify(m));
                                o = true;
                                break
                            }
                        }
                    }
                }
                if (!o) {
                    PacsClient.local.Global.recordsSuccess[a] = false
                }
            })
        }
    },
    findMaxPiex: function(d) {
        return 0;
        var b = d.length;
        var a = 0;
        while (b--) {
            if (d[b] > a) {
                a = d[b]
            }
        }
        return a
    },
    dragStartFun: function(d, a, b) {
        this.startX = d.startX;
        this.startY = d.startY
    },
    dragEndFun: function(d, a, b) {},
    dragFun: function(g, d, f) {
        var b = g.pageX - this.startX,
        a = g.pageY - this.startY;
        this.xMove += b;
        this.yMove += a;
        this.lineMove(b, a);
        this.startX = g.pageX;
        this.startY = g.pageY;
        this.moveAngle(b, a);
        this.drawImgMsg()
    },
    handleScroll: function(a) {
        if (!this.getUseMouseWheelEvent()) {
            return
        }
        var b = a.wheelDelta ? a.wheelDelta / 40 : a.detail ? -a.detail: 0;
        if (b) {
            this.mouseZoomFun(b)
        }
        return a.preventDefault() && false
    },
    imageDataConvert: function() {
        var e = this;
        if (this.imgData == null || e.adj) {
            return 0
        }
        e.adj = true;
        var f = 1 << this.highBit;
        var a = 1 << this.bitsStored;
        var d = (this.currentC - this.currentW / 2 - this.rescaleIntercept) / this.rescaleSlope;
        var b = (this.currentC + this.currentW / 2 - this.rescaleIntercept) / this.rescaleSlope;
        if (this.newPallet) {
            if ((this.temp[0] & 61440) == 61440) {
                this.pallet = this.pacsWorkTools.getPallet(f, a, d | 0, b | 0, this.padding)
            } else {
                this.pallet = this.pacsWorkTools.getPallet(a, a, d | 0, b | 0, this.padding)
            }
        }
        this.imgData = this.pacsWorkTools.getImg(this.imgData, this.temp, this.pallet, this.reverFlag);
        if (this.canvasTemp.height != this.imageHeight || this.canvasTemp.width != this.imageWidth) {
            this.canvasTemp.height = this.imageHeight;
            this.canvasTemp.width = this.imageWidth
        }
        this.cxtTemp.putImageData(this.imgData, 0, 0);
        this.imgTemp.src = this.canvasTemp.toDataURL("image/jpeg");
        this.imgTemp.onload = function(g) {
            e.drawImgMsg()
        };
        this.imgTemp.onerror = function(g) {
            e.adj = false
        };
        if (this.imgTemp.complete) {
            e.drawImgMsg()
        }
    },
    invertImage: function() {
        this.imageDataConvert(this.temp)
    },
    imageAdjStart: function(d, b) {
        if (this.winListView2.innerItems.length > 0) {
            this.winListView2.destroy()
        }
        this.startX = d.startX | 0;
        this.startY = d.startY | 0;
        var a = this;
        this.n = 0;
        this.m = 0
    },
    imageAdj: function(f, d) {
        var b = (f.pageX | 0) - this.startX,
        a = (f.pageY | 0) - this.startY;
        this.startX = f.pageX | 0;
        this.startY = f.pageY | 0;
        this.currentW += b;
        this.currentW = this.currentW > 0 ? this.currentW: 1;
        this.currentC += a;
        this.imageDataConvert(this.temp)
    },
    imageAdjEnd: function(b, a) {
        this.imageDataConvert(this.temp)
    },
    pinchStartFun: function(e, d, a, b) {
        this.startX = this.startX + e.pageX >> 1;
        this.startY = this.startY + e.pageY >> 1;
        this.xX = this.xMove;
        this.yX = this.yMove
    },
    pinchFun: function(h, g, b, e) {
        var a = this.imageHeight * this.scaleX * h.scale | 0;
        var f = this.imageWidth * this.scaleX * h.scale | 0;
        if ((a > 200 || f > 200) && this.scaleX * h.scale < 2) {
            this.angleScale = this.scale;
            this.scale = this.scaleX * h.scale;
            this.angleX = this.xMove;
            this.angleY = this.yMove;
            this.xMove = (this.startX - (this.startX - this.xX) * this.scale / this.scaleX) | 0;
            this.yMove = (this.startY - (this.startY - this.yX) * this.scale / this.scaleX) | 0;
            this.currentImageHeight = a;
            this.currentImageWidth = f;
            for (var d = 0; d < this.lineStroke.length; d += 2) {
                this.lineStroke[d] = this.lineStrokeL[d] * this.scale + this.xMove | 0;
                this.lineStroke[d + 1] = this.lineStrokeL[d + 1] * this.scale + this.yMove | 0
            }
            this.getSliderSize().setValue(this.scale * 100 | 0);
            this.scaleAngle();
            this.drawImgMsg()
        }
    },
    pinchEndFun: function(e, d, a, b) {
        this.scaleX = this.scale
    },
    putPicToCan: function(b, e) {
        var a = PacsClient.local.Global.BufferArray[b].InstanceUid;
        if (PacsClient.local.Global.BufferArray[b].SamplesPerPixel == "1" && this.calc && this.instanceUid != a && e && PacsClient.local.Global.pacsOffLine == "1") {
            this.instanceUid = a;
            var d = this;
            readPacsDataBlob(d.patientMsg, a, this.sliderIndex,
            function(f, g) {
                if (d.sliderIndex != g) {
                    return
                }
                d.temp = PacsClient.local.Global.BufferArray[g].ByteData;
                d.padding = PacsClient.local.Global.BufferArray[g].PixelPaddingValue;
                d.put(PacsClient.local.Global.BufferArray[g])
            },
            function(f, g) {})
        } else {
            if (this.sliderIndex != b) {
                return
            }
            this.put(PacsClient.local.Global.BufferArray[b])
        }
    },
    put: function(g) {
        var f = this;
        this.patName = g.PatName;
        this.imageHeight = g.Height;
        this.imageWidth = g.Width;
        this.scale = Math.min(this.canvasHeight / this.imageHeight, this.canvasWidth / this.imageWidth);
        if (this.scale > 1) {
            this.scale = 1
        }
        this.scaleX = this.scale;
        this.currentImageHeight = g.Height * this.scale | 0;
        this.currentImageWidth = g.Width * this.scale | 0;
        this.xMove = (this.canvasWidth - this.currentImageWidth) >> 1;
        this.yMove = (this.canvasHeight - this.currentImageHeight) >> 1;
        this.bitsStored = g.BitsStored;
        this.highBit = g.HighBit;
        this.rescaleIntercept = g.RescaleIntercept;
        this.rescaleSlope = g.RescaleSlope;
        this.pixelSpacingX = g.PixelSpacingX;
        this.pixelSpacingY = g.PixelSpacingY;
        this.lineStroke = null;
        this.lineStroke = [];
        this.lineStrokeL = null;
        this.lineStrokeL = [];
        this.angleArray = [];
        this.angleArrayL = [];
        this.angleSelected.selected = -1;
        this.angleSelected.pos = -1;
        this.padding = padding = g.PixelPaddingValue;
        if (PacsClient.local.Global.pacsOffLine == "2") {
            this.temp = g.ByteData
        }
        if (!this.calc || this.temp == null) {
            this.imgTemp.src = "data:image/jpeg;base64," + g.Base64Img;
            if (this.imgTemp.complete) {
                f.drawImgMsg()
            }
            f.imgTemp.onload = function(i) {
                f.drawImgMsg()
            }
        } else {
            if (this.imgData == null || this.imgData.width != g.Width || this.imgData.height != g.Height) {
                var b = this.cxt;
                this.imgData = b.createImageData(g.Width, g.Height);
                b = null
            }
            if (this.newPallet) {
                var h = 1 << this.highBit;
                var a = 1 << this.bitsStored;
                this.currentC = g.DcmLevel;
                this.currentW = g.DcmWidth;
                var e = (this.currentC - this.currentW / 2 - this.rescaleIntercept) / this.rescaleSlope;
                var d = (this.currentC + this.currentW / 2 - this.rescaleIntercept) / this.rescaleSlope;
                e = e | 0;
                d = d | 0;
                if ((this.temp[0] & 61440) == 61440) {
                    this.pallet = this.pacsWorkTools.getPallet(h, a, e | 0, d | 0, this.padding)
                } else {
                    this.pallet = this.pacsWorkTools.getPallet(a, a, e | 0, d | 0, this.padding)
                }
                this.newPallet = false
            }
            this.imgData = this.pacsWorkTools.getImg(this.imgData, this.temp, this.pallet, this.reverFlag);
            if (this.canvasTemp.height != this.imageHeight || this.canvasTemp.width != this.imageWidth) {
                this.canvasTemp.height = this.imageHeight;
                this.canvasTemp.width = this.imageWidth
            }
            this.cxtTemp.putImageData(this.imgData, 0, 0);
            this.imgTemp.src = this.canvasTemp.toDataURL("image/jpeg");
            if (this.imgTemp.complete) {
                f.drawImgMsg()
            }
            this.imgTemp.onload = function(i) {
                f.drawImgMsg()
            }
        }
    },
    drawStartFun: function(d, a, b) {
        if (this.winListView2.innerItems.length > 0) {
            this.winListView2.destroy()
        }
        this.startX = d.startX;
        this.startY = d.startY;
        this.lineDrawing = true;
        this.linetmp = [(this.startX - this.xMove) / this.scale, (this.startY - this.yMove) / this.scale, 0, 0]
    },
    drawEndFun: function(d, a, b) {
        this.lineDrawing = false;
        this.lineStrokeL.push(this.linetmp[0] | 0);
        this.lineStrokeL.push(this.linetmp[1] | 0);
        this.lineStrokeL.push(this.linetmp[2] | 0);
        this.lineStrokeL.push(this.linetmp[3] | 0);
        this.lineStroke.push(this.startX);
        this.lineStroke.push(this.startY);
        this.lineStroke.push(d.pageX);
        this.lineStroke.push(d.pageY);
        this.getMagnifier().setHidden(true);
        this.drawImgMsg();
        this.linetmp = null
    },
    drawFun: function(g, b, f) {
        this.drawImgMsg();
        var a = this.cxt;
        a.beginPath();
        a.lineWidth = 3;
        a.strokeStyle = "rgba(255,255,0,1)";
        a.fillStyle = "rgba(255,0,0,1)";
        a.font = "12pt Calibri";
        a.moveTo(this.startX, this.startY);
        a.lineTo(g.pageX, g.pageY);
        var d = Math.sqrt(Math.pow(this.pixelSpacingX * (this.startX - g.pageX), 2) + Math.pow(this.pixelSpacingY * (this.startY - g.pageY), 2));
        d /= this.scale;
        if (this.startY > g.pageY) {
            a.fillText(d.toFixed(2) + "mm", g.pageX, g.pageY - 2)
        } else {
            a.fillText(d.toFixed(2) + "mm", this.startX, this.startY - 2)
        }
        a.stroke();
        a.closePath();
        this.linetmp[2] = (g.pageX - this.xMove) / this.scale;
        this.linetmp[3] = (g.pageY - this.yMove) / this.scale;
        this.drawMagnifier(g.pageX, g.pageY);
        a = null
    },
    modifyStartFun: function(a) {
        this.startX = a.pageX;
        this.startY = a.pageY;
        if (this.selectLine != this.calcD(this.selectLine, this.startX, this.startY)) {
            this.selectLine = this.findLine(this.startX, this.startY);
            this.drawImgMsg()
        }
    },
    modifyEndFun: function(a) {
        this.getMagnifier().setHidden(true);
        this.drawImgMsg()
    },
    modifyFun: function(f) {
        if (this.selectLine >= 0) {
            var b = f.pageX - this.startX,
            a = f.pageY - this.startY;
            var g = 15;
            if (this.startX > this.lineStroke[this.selectLine] - g && this.startX < this.lineStroke[this.selectLine] + g && this.startY > this.lineStroke[this.selectLine + 1] - g && this.startY < this.lineStroke[this.selectLine + 1] + g) {
                this.movePoint(this.selectLine, f.pageX, f.pageY)
            } else {
                if (this.startX > this.lineStroke[this.selectLine + 2] - g && this.startX < this.lineStroke[this.selectLine + 2] + g && this.startY > this.lineStroke[this.selectLine + 3] - g && this.startY < this.lineStroke[this.selectLine + 3] + g) {
                    this.movePoint(this.selectLine + 2, f.pageX, f.pageY)
                } else {
                    this.moveLine(this.selectLine, b, a)
                }
            }
            this.startX = f.pageX;
            this.startY = f.pageY;
            this.drawImgMsg();
            this.drawMagnifier(f.pageX, f.pageY)
        }
    },
    moveLine: function(a, b, d) {
        this.lineStroke[a] += b;
        this.lineStroke[a + 1] += d;
        this.lineStrokeL[a] = (this.lineStroke[a] - this.xMove) / this.scale;
        this.lineStrokeL[a + 1] = (this.lineStroke[a + 1] - this.yMove) / this.scale;
        this.lineStroke[a + 2] += b;
        this.lineStroke[a + 3] += d;
        this.lineStrokeL[a + 2] = (this.lineStroke[a + 2] - this.xMove) / this.scale;
        this.lineStrokeL[a + 3] = (this.lineStroke[a + 3] - this.yMove) / this.scale
    },
    movePoint: function(a, b, d) {
        this.lineStroke[a] = b;
        this.lineStroke[a + 1] = d;
        this.lineStrokeL[a] = (b - this.xMove) / this.scale;
        this.lineStrokeL[a + 1] = (d - this.yMove) / this.scale
    },
    drawOneLine: function(b) {
        var a = this.cxt;
        a.moveTo(this.lineStroke[b], this.lineStroke[b + 1]);
        a.lineTo(this.lineStroke[b + 2], this.lineStroke[b + 3]);
        length = Math.sqrt(Math.pow(this.pixelSpacingX * (this.lineStrokeL[b + 2] - this.lineStrokeL[b]), 2) + Math.pow(this.pixelSpacingY * (this.lineStrokeL[b + 1] - this.lineStrokeL[b + 3]), 2));
        if (this.lineStroke[b + 1] > this.lineStroke[b + 3]) {
            a.fillText(length.toFixed(2) + "mm", this.lineStroke[b + 2], this.lineStroke[b + 3] - 2)
        } else {
            a.fillText(length.toFixed(2) + "mm", this.lineStroke[b], this.lineStroke[b + 1] - 2)
        }
        a = null
    },
    drawSelectLine: function(b) {
        if (b > -1) {
            var a = this.cxt;
            a.beginPath();
            a.lineWidth = 3;
            a.strokeStyle = "rgba(55,255,0,1)";
            a.fillStyle = "rgba(155,0,33,1)";
            a.font = "12pt Calibri";
            this.drawOneLine(b);
            a.moveTo(this.lineStroke[b] + 6, this.lineStroke[b + 1]);
            a.arc(this.lineStroke[b], this.lineStroke[b + 1], 6, 0, Math.PI * 2, true);
            a.moveTo(this.lineStroke[b + 2] + 6, this.lineStroke[b + 3]);
            a.arc(this.lineStroke[b + 2], this.lineStroke[b + 3], 6, 0, Math.PI * 2, true);
            a.stroke();
            a.closePath();
            a = null
        }
    },
    findLine: function(a, e) {
        for (var d = this.lineStroke.length; d > 0; d -= 4) {
            var b = this.calcD(d - 4, a, e);
            if (b >= 0) {
                return b
            }
        }
        return - 1
    },
    calcD: function(f, a, h) {
        if (f < 0) {
            return - 2
        }
        var d = this.lineStroke[f];
        var b = this.lineStroke[f + 2];
        var g = this.lineStroke[f + 1];
        var e = this.lineStroke[f + 3];
        return this.scalcDistance(d, g, b, e, a, h) ? f: -1
    },
    scalcDistance: function(h, p, f, o, q, n) {
        var m = h < f ? h: f;
        var e = h >= f ? h: f;
        var j = p < o ? p: o;
        var b = p >= o ? p: o;
        if (q > m - 10 && q < e + 10 && n > j - 10 && n < b + 10) {
            var i = p - o;
            var g = f - h;
            var d = h * o - f * p;
            var a = Math.sqrt(i * i + g * g);
            var k = (i * q + g * n + d) / a | 0;
            if (k > -10 && k < 10) {
                return true
            } else {
                return false
            }
        } else {
            return false
        }
    },
    drawImgMsg: function() {
        var a = this.cxt;
        if (window.innerHeight != this.canvasHeight || window.innerWidth != this.canvasWidth) {
            this.reStarCanvans()
        } else {
            a.clearRect(0, 0, this.canvasWidth, this.canvasHeight)
        }
        a.drawImage(this.imgTemp, this.xMove, this.yMove, this.currentImageWidth, this.currentImageHeight);
        this.drawMsg(a);
        this.drawProgress();
        if (PacsClient.local.Global.BufferArray[this.sliderIndex].PixelSpacingX != "0") {
            this.drawRuler()
        }
        if (this.lineStroke.length > 0) {
            a.beginPath();
            this.drawLinePath();
            a.stroke();
            a.closePath()
        }
        this.drawSelectLine(this.selectLine);
        a = null;
        if (this.angleArray.length > 0) {
            this.drawAngle()
        }
        this.adj = false;
        Ext.Viewport.setMasked(false);
        this.toolBarCanuse = true;
        this.getBtnRemove().setHidden(this.selectLine < 0 && this.angleSelected.selected < 0)
    },
    reStarCanvans: function() {
        var b = this.getPacsImg().innerElement.dom.querySelector("canvas");
        b.height = window.innerHeight - 5;
        b.width = window.innerWidth;
        this.canvas = b;
        this.canvasHeight = window.innerHeight;
        this.canvasWidth = window.innerWidth;
        this.cxt = b.getContext("2d");
        this.cxt.strokeStyle = "white";
        this.cxt.lineWidth = 1;
        this.cxt.font = "1.2em sans-serif ";
        var a = Ext.create("Ext.draw.engine.Canvas", {});
        this.canvasTemp = a.innerElement.dom.querySelector("canvas");
        this.cxtTemp = this.canvasTemp.getContext("2d");
        this.canvasTemp.height = window.innerHeight;
        this.canvasTemp.width = window.innerWidth
    },
    drawMsg: function(b) {
        b.fillStyle = "rgba(222,22,222,1)";
        b.font = "12pt Calibri";
        var a = this.canvasWidth * 0.11 | 0;
        b.fillText("姓名 : " + this.patName, a, 60);
        b.fillText("窗宽 : " + this.currentW, a, 80);
        b.fillText("窗位 : " + this.currentC, a, 100);
        b.fillText("缩放 : " + this.scale.toFixed(2), a, 120);
        b.fillText("IMAGE : " + (this.sliderIndex + 1) + "/" + this.instanceUIDList.length, a, 140)
    },
    drawProgress: function() {
        if (this.toolNum != 0 || PacsClient.local.Global.BufferArray.length == 1) {
            return
        }
        var b = this.cxt;
        b.beginPath();
        b.lineWidth = 3;
        b.strokeStyle = "rgba(0,255,50,1)";
        var e = PacsClient.local.Global.BufferArray.length;
        var f = (this.canvasWidth * 0.79 - 40) / e;
        var a = this.canvasWidth * 0.91 - 20;
        while (e--) {
            if (PacsClient.local.Global.BufferArray[e] != null) {
                b.moveTo(a, this.canvasHeight - 34);
                a -= f;
                b.lineTo(a, this.canvasHeight - 34)
            } else {
                a -= f
            }
        }
        b.stroke();
        b.closePath();
        b = null
    },
    drawProgressOne: function(e) {
        if (this.toolNum != 0 || PacsClient.local.Global.BufferArray.length == 1) {
            return
        }
        var b = this.cxt;
        b.beginPath();
        b.lineWidth = 3;
        b.strokeStyle = "rgba(0,255,50,1)";
        var f = PacsClient.local.Global.BufferArray.length;
        var g = (this.canvasWidth * 0.79 - 40) / f;
        var a = this.canvasWidth * 0.12 + 20 + g * e;
        b.moveTo(a, this.canvasHeight - 34);
        a += g;
        b.lineTo(a, this.canvasHeight - 34);
        b.stroke();
        b.closePath();
        b = null
    },
    drawLinePath: function() {
        var b = this.cxt;
        b.lineWidth = 3;
        b.strokeStyle = "rgba(255,255,0,1)";
        b.fillStyle = "rgba(255,0,0,1)";
        var a = this.lineStroke.length;
        for (var d = 0; d < a; d += 4) {
            if (d != this.selectLine) {
                this.drawOneLine(d)
            }
        }
        b = null
    },
    lineMove: function(a, e) {
        var b = this.lineStroke.length;
        for (var d = 0; d < b; d += 2) {
            this.lineStroke[d] += a;
            this.lineStroke[d + 1] += e
        }
    },
    densityDistribution: function(d, e) {
        var b = d.length;
        var a = 10 * this.density.length / b;
        while (b--) {
            this.density[d[b]] += a
        }
    },
    drawDensity: function() {
        var a = this.cxt;
        var f = this.density.length;
        var b = this.canvasWidth * 0.2;
        var g = this.canvasWidth * 0.75 / f;
        a.beginPath();
        a.lineWidth = g;
        a.strokeStyle = "rgba(255,25,0,1)";
        for (var e = 0; e < f; e++) {
            a.moveTo(b, 100);
            a.lineTo(b, 100 - this.density[e]);
            b += g
        }
        a.stroke();
        a.closePath();
        a = null
    },
    drawRuler: function() {
        var m = this.cxt;
        m.beginPath();
        m.lineWidth = 1;
        m.strokeStyle = "rgba(25,225,0,1)";
        m.fillStyle = "rgba(222,22,222,1)";
        var o = this.canvasWidth * 0.8;
        if (o > this.currentImageWidth) {
            o = this.currentImageWidth
        }
        var f = o * 0.02;
        var h = f * this.pixelSpacingX / this.scale | 0;
        var g = this.scale * 50 / this.pixelSpacingX;
        var a = (h) * g | 0;
        if (!h) {
            h = 1
        }
        var n = this.xMove + (this.currentImageWidth - a >> 1);
        var b = this.canvasWidth * 0.1 | 0;
        var k = (this.canvasWidth * 0.95 | 0) - a;
        if (n < b) {
            n = b
        }
        if (n > k) {
            n = k
        }
        var j = this.yMove + this.currentImageHeight + 25;
        b = 25;
        k = this.canvasHeight * 0.9 | 0;
        if (j < b) {
            j = b
        }
        if (j > k) {
            j = k
        }
        m.moveTo(n, j);
        m.lineTo(n + a, j);
        for (var e = 0; e < h + 1; e++) {
            m.moveTo(n, j);
            m.lineTo(n, j - 20);
            n += g
        }
        o = this.canvasHeight * 0.8;
        if (o > this.currentImageHeight) {
            o = this.currentImageHeight
        }
        f = o * 0.02;
        var h = f * this.pixelSpacingY / this.scale | 0;
        var g = this.scale * 50 / this.pixelSpacingY;
        var a = (h) * g | 0;
        if (!h) {
            h = 1
        }
        var n = this.xMove + this.currentImageWidth + 25;
        var b = this.canvasWidth * 0.1 | 0 + 25;
        var k = (this.canvasWidth * 0.95 | 0) - 3;
        if (n < b) {
            n = b
        }
        if (n > k) {
            n = k
        }
        var j = this.yMove + (this.currentImageHeight - a >> 1);
        b = 25;
        k = (this.canvasHeight * 0.9 | 0) - a;
        if (j < b) {
            j = b
        }
        if (j > k) {
            j = k
        }
        m.moveTo(n, j);
        m.lineTo(n, j + a);
        for (var e = 0; e < h + 1; e++) {
            m.moveTo(n, j);
            m.lineTo(n - 20, j);
            j += g
        }
        n = this.canvasWidth - g - 5 | 0;
        j = this.canvasHeight - 30;
        m.moveTo(n, j - 15);
        m.lineTo(n, j);
        m.lineTo(n + g | 0, j);
        m.lineTo(n + g | 0, j - 15);
        m.fillText("5 CM", n + (g >> 1) - 19, j - 5);
        m.stroke();
        m.closePath();
        m = null
    },
    deleteTemp: function() {
        this.sliderIndex = null;
        this.patName = null;
        this.densityLength = null;
        this.removePng = null;
        this.density = null;
        this.pixelSpacingX = null;
        this.pixelSpacingY = null;
        this.lineStrokeL = null;
        this.lineStroke = null;
        this.imgTemp = null;
        this.winListView2 = null;
        this.newPallet = null;
        this.calc = null;
        this.scale = null;
        this.xMove = null;
        this.yMove = null;
        this.caleX = null;
        this.xX = null;
        this.yX = null;
        this.startX = null;
        this.startY = null;
        this.canvasHeight = null;
        this.canvasWidth = null;
        this.imageHeight = null;
        this.imageWidth = null;
        this.currentImageWidth = null;
        this.currentImageHeight = null;
        this.canvas = null;
        this.cxt = null;
        this.canvasTemp = null;
        this.cxtTemp = null;
        this.imgData = null;
        this.reverFlag = null;
        this.instanceJson = null;
        this.smallPic = null;
        this.seriesUID = null;
        this.instanceUIDList = null;
        this.currentW = null;
        this.currentC = null;
        this.bitsStored = null;
        this.highBit = null;
        this.rescaleIntercept = null;
        this.rescaleSlope = null;
        this.pallet = null;
        this.pacsWorkTools = null;
        this.temp = null;
        this.adj = null;
        this.selectLine = null;
        PacsClient.local.Global.BufferArray = null
    },
    closePacs: function() {
        if (Ext.os.is.iOS) {
            var a = new Array();
            kyeeCloseView.closeCurrentView(function (b) {
               

            
                this.pacsStart = false;
                this.deleteTemp();
                console.log("关闭PACS页面成功")
            },
            function(b) {
                console.error("关闭PACS页面失败")
            },
            a)
        }
    },
    onSizeChanging: function(g, a, b, h, j, f) {
        if (this.useSliderScale) {
            this.scale = this.getSliderSize().getValue()[0] / 100;
            this.xMove += (this.currentImageWidth >> 1) | 0;
            this.currentImageWidth = this.imageWidth * this.scale;
            this.xMove -= (this.currentImageWidth >> 1) | 0;
            this.yMove += (this.currentImageHeight >> 1) | 0;
            this.currentImageHeight = this.imageHeight * this.scale;
            this.yMove -= (this.currentImageHeight >> 1) | 0;
            for (var d = 0; d < this.lineStroke.length; d += 2) {
                this.lineStroke[d] = this.lineStrokeL[d] * this.scale + this.xMove | 0;
                this.lineStroke[d + 1] = this.lineStrokeL[d + 1] * this.scale + this.yMove | 0
            }
            this.scaleAngle();
            this.drawImgMsg()
        }
    },
    SliderSizeShow: function(a) {
        if (this.useSliderScale) {
            if (this.imageHeight < this.imageWidth) {
                a.setMinValue(20000 / this.imageWidth | 0)
            } else {
                a.setMinValue(20000 / this.imageHeight | 0)
            }
            this.drawImgMsg();
            a.setValue(this.scale * 100)
        }
    },
    drawMagnifier: function(j, f) {
        if (this.getMagnifier().getHidden()) {
            this.getMagnifier().setHidden(false)
        }
        var h = this.magnifiercxt;
        var a = this.MagnifierR >> 1;
        var k = this.MagnifierR << 1;
        var b = this.canvasWidth * 0.12;
        var g = this.canvasHeight * 0.02;
        if (window.innerHeight < window.innerWidth) {
            if (j < this.canvasWidth * 0.12 + k && f < this.canvasHeight * 0.02 + k) {
                var b = this.canvasWidth * 0.93 - k
            }
            if (this.magnifierleft != b) {
                this.magnifierleft = b;
                this.getMagnifier().setLeft(b);
                this.getMagnifier().setTop(g)
            }
        } else {
            if (j < this.canvasWidth * 0.12 + k && f < this.canvasHeight * 0.02 + k) {
                var g = this.canvasHeight * 0.98 - k
            }
            if (this.magnifiertop != g) {
                this.magnifiertop = g;
                this.getMagnifier().setLeft(b);
                this.getMagnifier().setTop(g)
            }
        }
        h.strokeStyle = "rgba(55,255,0,1)";
        h.fillRect(0, 0, this.MagnifierR, this.MagnifierR);
        h.save();
        h.translate((this.xMove + a - j), (this.yMove + a - f));
        h.drawImage(this.imgTemp, 0, 0, this.currentImageWidth, this.currentImageHeight);
        if (this.selectLine > -1) {
            h.beginPath();
            h.moveTo(this.lineStrokeL[this.selectLine] * this.scale, this.lineStrokeL[this.selectLine + 1] * this.scale);
            h.lineTo(this.lineStrokeL[this.selectLine + 2] * this.scale, this.lineStrokeL[this.selectLine + 3] * this.scale);
            h.stroke();
            h.closePath()
        }
        if (this.angleSelected.selected > -1) {
            var e = this.angleArrayL[this.angleSelected.selected];
            h.beginPath();
            h.moveTo(e[0] * this.scale, e[1] * this.scale);
            for (var d = 2; d < e.length; d += 2) {
                h.lineTo(e[d] * this.scale, e[d + 1] * this.scale);
                h.lineTo(e[d + 2] * this.scale, e[d + 3] * this.scale)
            }
            h.stroke();
            h.closePath()
        }
        if (this.lineDrawing) {
            h.beginPath();
            h.moveTo(this.linetmp[0] * this.scale, this.linetmp[1] * this.scale);
            h.lineTo(this.linetmp[2] * this.scale, this.linetmp[3] * this.scale);
            h.stroke();
            h.closePath()
        }
        if (this.angleDrawing) {
            h.beginPath();
            h.moveTo(this.angletmp[0] * this.scale, this.angletmp[1] * this.scale);
            for (var d = 2; d < this.angletmp.length; d += 2) {
                h.lineTo(this.angletmp[d] * this.scale, this.angletmp[d + 1] * this.scale)
            }
            h.stroke();
            h.closePath()
        }
        h.restore();
        h.beginPath();
        h.strokeStyle = "rgba(32,73,106,1)";
        h.arc(a, a, a, 0, 2 * Math.PI);
        h.stroke();
        h.closePath();
        h.beginPath();
        h.strokeStyle = "rgba(225,231,21,1)";
        h.moveTo(a - 5, a);
        h.lineTo(a + 5, a);
        h.moveTo(a, a - 5);
        h.lineTo(a, a + 5);
        h.stroke();
        h.closePath()
    }
});
Ext.define("IBase.view.BasePopupView", {
    extend: Ext.Panel,
    xtype: "popupview",
    config: {
        title: null,
        containItems: [],
        modal: true,
        centered: true,
        hideOnMaskTap: false,
        layout: "vbox",
        items: [{
            xtype: "titlebar",
            itemId: "basePopupTitleId",
            cls: "basePopup-title",
            docked: "top",
            items: {
                cls: "close",
                iconCls: "delete",
                align: "right",
                handler: function() {
                    this.up("popupview").destroy()
                }
            }
        },
        {
            xtype: "container",
            cls: "basePopup-container",
            itemId: "basePopupContainerId"
        }]
    },
    updateTitle: function(a) {
        this.down("#basePopupTitleId").setTitle(a)
    },
    updateContainItems: function(a) {
        this.down("#basePopupContainerId").add(a)
    },
    applyToolbar: function(a) {
        var b = Ext.factory({
            docked: "bottom"
        },
        "Ext.Toolbar");
        b.add(a);
        b.addCls("basePopup-toolbar");
        return b
    },
    updateToolbar: function(a, b) {
        if (b) {
            this.remove(b)
        } else {
            this.add(a)
        }
    }
});
Ext.define("PacsClient.view.dicomviewer.PacsSetView", {
    extend: IBase.view.BasePopupView,
    xtype: "PacsSetView",
    config: {
        title: "设置",
        cls: "labReport",
        containItems: [{
            layout: "vbox",
            items: [{
                xtype: "checkboxfield",
                itemId: "checkboxfield",
                labelWidth: "auto",
                name: "自动删除",
                label: '自动删除 <input id="inputTimes" style="width: 30px"/> 天未访问的数据',
                value: "1",
                checked: true
            },
            {
                xtype: "toolbar",
                items: [{
                    xtype: "segmentedbutton",
                    itemId: "basic",
                    centered: true,
                    items: [{
                        text: "Expand",
                        action: "expand"
                    },
                    {
                        text: "Collapse",
                        action: "collapse"
                    }]
                }]
            }]
        }],
        toolbar: {
            xtype: "button",
            text: "确定",
            cls: "labReport-PacsBtn",
            itemId: "labInfoTendencyChartId",
            width: "100%"
        }
    }
});
Ext.define("PacsClient.controller.PacsSetController", {
    extend: IBase.controller.BaseController,
    config: {
        refs: {
            pacsSetView: "PacsSetView",
            checkboxfield: "PacsSetView #checkboxfield",
            inputTimes: "#inputTimes"
        },
        control: {
            pacsSetView: {
                initialize: "start"
            },
            checkboxfield: {},
            inputTimes: {}
        }
    },
    start: function() {
        var a = this.getCheckboxfield();
        a.element.on({
            tap: {
                fn: this.rCheck,
                scope: this
            }
        })
    },
    rCheck: function(a, b) {
        if (b.style.width != "" || b.nodeName == "SPAN") {
            this.getCheckboxfield().setChecked(!this.getCheckboxfield().getChecked())
        }
    }
});
Ext.define("PacsClient.model.Pacs.SmallPic", {
    extend: Ext.data.Model,
    config: {
        fields: [{
            name: "StudyUidNum"
        },
        {
            name: "SeriesUid"
        },
        {
            name: "InstanceUid"
        },
        {
            name: "StuduDateTime"
        },
        {
            name: "ImgData"
        },
        {
            name: "SeriesDateTime"
        }]
    }
});
Ext.define("PacsClient.store.Pacs.SmallPic", {
    extend: Ext.data.Store,
    config: {
        storeId: "thumbnaillist",
        model: "PacsClient.model.Pacs.SmallPic",
        autoload: false
    }
});
Ext.define("PacsClient.model.Pacs.PacsFn", {
    extend: Ext.data.Model,
    config: {
        fields: [{
            name: "fnname",
            type: "string"
        },
        {
            name: "imagesrc",
            type: "string"
        },
        {
            name: "divclassname",
            type: "string"
        },
        {
            name: "name",
            type: "string"
        }]
    }
});
Ext.define("PacsClient.store.Pacs.PacsFn", {
    extend: IBase.store.BaseStore,
    config: {
        model: "PacsClient.model.Pacs.PacsFn",
        autoLoad: false,
        storeId: "pacsfnstore",
        data: [{
            fnname: "buttonPage",
            imagesrc: "resources/images/pacs/buttonPage.png",
            divclassname: "pacs-fn-move",
            name: "翻页"
        },
        {
            fnname: "buttonReverse",
            imagesrc: "resources/images/pacs/buttonReverse.png",
            divclassname: "pacs-fn-move",
            name: "反色"
        },
        {
            fnname: "buttonAdj",
            imagesrc: "resources/images/pacs/buttonAdj.png",
            divclassname: "pacs-fn-move",
            name: "调窗"
        },
        {
            fnname: "buttonMeasure",
            imagesrc: "resources/images/pacs/buttonMeasure.png",
            divclassname: "pacs-fn-move",
            name: "测量"
        },
        {
            fnname: "buttonReset",
            imagesrc: "resources/images/pacs/buttonReset.png",
            divclassname: "pacs-fn-move",
            name: "重置"
        },
        {
            fnname: "buttonScale",
            imagesrc: "resources/images/pacs/buttonScale.png",
            divclassname: "pacs-fn-move",
            name: "移动缩放"
        },
        {
            fnname: "buttonAngle",
            imagesrc: "resources/images/pacs/buttonAngle.png",
            divclassname: "pacs-fn-move",
            name: "量角器"
        }
        /**,
        {
            fnname: "buttonExit",
            imagesrc: "resources/images/pacs/buttonExit.png",
            divclassname: "pacs-fn-move",
            name: "退出"
        }*/
        ]
    }
});
Ext.application({
    name: "PacsClient",
    controllers: ["PacsController", "PacsSetController"],
    views: ["dicomviewer.PacsSetView"],
    stores: ["Pacs.SmallPic", "Pacs.PacsFn"],
    locals: ["MsgString", "Global"],
    icon: {},
    isIconPrecomposed: true,
    startupImage: {},
    launch: function() {
        Ext.override(Ext.util.SizeMonitor, {
            constructor: function(i) {
                var j = Ext.util.sizemonitor;
                if (Ext.browser.is.Firefox) {
                    return new j.OverflowChange(i)
                } else {
                    if (Ext.browser.is.WebKit) {
                        if (!Ext.browser.is.Silk && Ext.browser.engineVersion.gtEq("535") && !Ext.browser.engineVersion.ltEq("537.36")) {
                            return new j.OverflowChange(i)
                        } else {
                            return new j.Scroll(i)
                        }
                    } else {
                        if (Ext.browser.is.IE11) {
                            return new j.Scroll(i)
                        } else {
                            return new j.Scroll(i)
                        }
                    }
                }
            }
        });
        Ext.override(Ext.util.PaintMonitor, {
            constructor: function(i) {
                if (Ext.browser.is.Firefox || (Ext.browser.is.WebKit && Ext.browser.engineVersion.gtEq("536") && !Ext.browser.engineVersion.ltEq("537.36") && !Ext.os.is.Blackberry)) {
                    return new Ext.util.paintmonitor.OverflowChange(i)
                } else {
                    return new Ext.util.paintmonitor.CssAnimation(i)
                }
            }
        });
        Ext.fly("appLoadingIllustration").destroy();
        Ext.fly("appLoadingIndicator").destroy();
        Ext.Date.monthNames = ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"];
        if (Ext.MessageBox) {
            Ext.MessageBox.OK.text = "确定";
            Ext.MessageBox.CANCEL.text = "取消";
            Ext.MessageBox.YES.text = "是";
            Ext.MessageBox.NO.text = "否";
            Ext.MessageBox.YESNO[0].text = "否";
            Ext.MessageBox.YESNO[1].text = "是";
            Ext.MessageBox.YESNO.reverse();
            Ext.MessageBox.OKCANCEL[0].text = "取消";
            Ext.MessageBox.OKCANCEL[1].text = "确定";
            Ext.MessageBox.OKCANCEL.reverse()
        }
        /**
        var m = window.location.port;
        if (m == "") {
        	PacsClient.local.Global.wsStr = "ws://" + window.location.host + ":5000"
        	//PacsClient.local.Global.wsStr = "ws://192.168.0.147:8080/pacs_view/websocket"
        } else {
        	PacsClient.local.Global.wsStr = "ws://" + window.location.host.split(":")[0] + ":5000"
        	//PacsClient.local.Global.wsStr = "ws://192.168.0.147:8080/pacs_view/websocket"
        }*/
        // 内网：192.168.0.26   服务器：120.77.84.3
        PacsClient.local.Global.wsStr = "ws://120.77.84.3:5000";
        var e = location.search;
        e = e.substring(1);
        e = decodeURI(e);
        var d = e.split("&");
        var a = "";
        PacsClient.local.Global.pacsPid = "";
        for (var h = 0; h < d.length; h++) {
            var k = d[h].split("=");
            switch (k[0].toLowerCase()) {
			//RUL参数名在这里定义
            case "pacspid":
                if (usePatient) {
                    PacsClient.local.Global.pacsPid = k[1]
                }
                break;
            case "patientid":
                PacsClient.local.Global.pacsPid = k[1];
                break;
            case "pacsstudyuid":
                if (useStudy) {
                    PacsClient.local.Global.pacsStudyUid = [];
                    var g = k[1].split(";");
                    for (var f = 0; f < g.length; f++) {
                        if (g[f] != "") {
                            PacsClient.local.Global.pacsStudyUid.push(g[f])
                        }
                    }
                }
                break;
            case "pacsaccessnumber":
                if (useAccessnumber) {
                    PacsClient.local.Global.pacsAccessNumber = k[1]
                }
                break;
            case "pacsdatetime":
                if (useStudyDateTime) {
                    PacsClient.local.Global.pacsDataTime = k[1]
                }
                break;
            case "bedno":
                PacsClient.local.Global.pacsBedNum = k[1];
                break;
            case "name":
                PacsClient.local.Global.pacsPatientName = k[1];
                break;
            case "debug":
                a = k[1];
                break;
            case "iscover":
                PacsClient.local.Global.iscover = k[1];
                break
            }
        }
        /**
        if (a == "1") {
            PacsClient.local.Global.pacsPid = "03117795";
            PacsClient.local.Global.pacsAccessNumber = "ZH111208CT64025";
            PacsClient.local.Global.pacsBedNum = "2"
        }*/
        var b = Ext.create("PacsClient.view.dicomviewer.PacsMainView", {
            centered: false,
            style: "background-color:black",
            modal: true,
            height: "100%",
            width: "100%"
        });
        b.setZIndex(1);
        Ext.Viewport.add(b);
        b.show()
    },
    onUpdated: function() {
        Ext.Msg.confirm("应用程序升级", "当前应用程序已经升级到最新版是否重新加载？",
        function(a) {
            if (a === "yes") {
                localStorage.clear();
                window.location.reload()
            }
        })
    }
});